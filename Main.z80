;****************************************************************************************************************************************************
;*	RPG Engine Source File
;*
;****************************************************************************************************************************************************
;****************************************************************************************************************************************************
;*	Macros
;****************************************************************************************************************************************************

StatusOutputMacro: MACRO 
	ld a, [de]
	ld [hl+], a
	inc de
	ld a, [de]
	ld [hl+], a
	inc de
	ld a, [de]
	ld [hl+], a
	inc de
	ENDM

COMBAT_TILE_1: MACRO
	ld a, [COMBAT_INIT_BYTE]			
	bit 0, a							;if bit 0 = 1, then the player hasn't moved
	ret nz								;so return
	set 0, a
	res 1, a							;else flip bits 0 and 1
	ld [COMBAT_INIT_BYTE], a			;and store the result
	
	ld a, 100
	call RANDOM_NUM						;generate a random no between 0 and 99
	ld a, [RANDOM_NO]					;load the result into a
	inc a								;increment so that it is between 1 and 100
	cp ENCOUNTER_RATE					
	ret nc								;if the result is > the encounter rate, then return
	ENDM

COMBAT_TILE_2: MACRO
	ld a, [COMBAT_INIT_BYTE]			
	bit 1, a							;if bit 1 = 1, then the player hasn't moved
	ret nz								;so return
	set 1, a
	res 0, a							;else flip bits 0 and 1
	ld [COMBAT_INIT_BYTE], a			;and store the result
	
	ld a, 100
	call RANDOM_NUM						;generate a random no between 0 and 99
	ld a, [RANDOM_NO]					;load the result into a
	inc a								;increment so that it is between 1 and 100
	cp ENCOUNTER_RATE					
	ret nc								;if the result is > the encounter rate, then return	
	ENDM
	
COMBAT_INIT_ENEMY_PICK: MACRO
	ld a, 3
	call RANDOM_NUM						;generate a random no between 0 and 2
	ld a, [RANDOM_NO]					;load the result into a
	sla a								;and multiply it by 2
	ld hl, NEW_TILES					;NEW_TILES is reused to save memory
	ld d, 0
	ld e, a
	add hl, de							;hl now points to an enemy no
	ld a, [hl+]
	ld [ENEMY_NO], a					;so load the enemy number and level into ram so that they can be used to start combat
	ld a, [hl]
	ld [ENEMY_LEVEL], a
	call COMBAT
	ENDM

MAP_MUSIC_CHECK: MACRO
	ld a, d
	cpl
	ld d, a
	ld a, e
	cpl
	ld e, a
	inc de								;de = -de
	add hl, de							
	
	xor a
	or h								;if hl = de earlier, then 0 or h or l will = 0 as hl will equal 0
	or l
	ENDM
	
;****************************************************************************************************************************************************
;*	equates
;****************************************************************************************************************************************************
	
EVENT_LENGTH 		EQU 9
PLAYER_X	 		EQU 9
PLAYER_Y	 		EQU 7
SUBTRACT_32	 		EQU $FFE0
SUBTRACT_1024 		EQU $FC00
SUBTRACT_20			EQU $FFEC
SUBTRACT_10			EQU $FFF6
SUBTRACT_16			EQU $FFF0

PLAYER_UP			EQU	0
PLAYER_DOWN			EQU 1
PLAYER_LEFT			EQU 2
PLAYER_RIGHT		EQU 3

PLAYER_SPRITE		EQU $FE02

CURSOR_Y			EQU $FE04
CURSOR_X			EQU	$FE05
CURSOR_SPRITE		EQU $FE06

MESSAGE_X			EQU 7
MESSAGE_Y			EQU 104
MENU_X				EQU 7
MENU_Y				EQU 120

ITEM_LENGTH			EQU 24

SAVE_COUNTER		EQU $1FFA

BANK_MAP1			EQU 1
BANK_MAP2			EQU 2
BANK_TILESET		EQU 3
BANK_SOUND			EQU 4
BANK_STRING			EQU 5
BANK_COMBAT			EQU 6
BANK_ITEMDB			EQU 7
BANK_ENEMYTILES1	EQU 8
BANK_ENEMYTILES2	EQU 9
BANK_ENEMYTILES3	EQU 10
BANK_ENEMYTILES4	EQU 11
BANK_ENEMYTILES5	EQU 12
BANK_ENEMYTILES6	EQU 13
BANK_ENEMYTILES7	EQU 14
BANK_MAP3			EQU 15

GAMESTATE_OVERWORLD EQU 1
GAMESTATE_COMBAT	EQU 2

ENCOUNTER_RATE		EQU 5
ENEMY_LENGTH		EQU 35
ENCOUNTER_LENGTH	EQU 6
MOVE_LENGTH			EQU 13

ESCAPE_CHANCE		EQU 40

FADE_DELAY_TIME		EQU 15

MAX_LEVEL			EQU 30

DEFAULT_TEXT_SPEED	EQU 4

LONG_PAUSE			EQU 60

;****************************************************************************************************************************************************
;*	Includes
;****************************************************************************************************************************************************

	; required includes
	INCLUDE	"Hardware.inc"
	INCLUDE "BankNo.asm"
	INCLUDE "MapTiles.asm"
	INCLUDE "Character.asm"
	INCLUDE "UncrossableTiles.asm"
	INCLUDE "WindowData.asm"
	INCLUDE "MessageData.asm"
	INCLUDE "gbt_player.asm"
	INCLUDE "gbt_player_bank1.asm"
	INCLUDE "MusicData.asm"
	INCLUDE "ItemData.asm"
	INCLUDE "PlayerGrowth.asm"
	INCLUDE "ExpRequired.asm"
	INCLUDE "MoveData.asm"
	INCLUDE "EnemyData.asm"
	INCLUDE "EnemyTiles.asm"
	INCLUDE "EncounterData.asm"
	INCLUDE "DamageCalc.asm"
	
	;map includes
	INCLUDE "MapData.asm"
	
	
;****************************************************************************************************************************************************
;*	cartridge header
;****************************************************************************************************************************************************

	SECTION	"Org $00",ROM0[$00]
RST_00:	
	jp	$100

	SECTION	"Org $08",ROM0[$08]
RST_08:	
	jp	$100

	SECTION	"Org $10",ROM0[$10]
RST_10:
	jp	$100

	SECTION	"Org $18",ROM0[$18]
RST_18:
	jp	$100

	SECTION	"Org $20",ROM0[$20]
RST_20:
	jp	$100

	SECTION	"Org $28",ROM0[$28]
RST_28:
	jp	$100

	SECTION	"Org $30",ROM0[$30]
RST_30:
	jp	$100

	SECTION	"Org $38",ROM0[$38]
RST_38:
	jp	$100

	SECTION	"V-Blank IRQ Vector",ROM0[$40]
VBL_VECT:
	call NEW_gbt_update
	reti
	
	SECTION	"LCD IRQ Vector",ROM0[$48]
LCD_VECT:
	reti

	SECTION	"Timer IRQ Vector",ROM0[$50]
TIMER_VECT:
	reti

	SECTION	"Serial IRQ Vector",ROM0[$58]
SERIAL_VECT:
	reti

	SECTION	"Joypad IRQ Vector",ROM0[$60]
JOYPAD_VECT:
	reti
	
	SECTION	"Start",ROM0[$100]
	nop
	jp	Start

	; $0104-$0133 (Nintendo logo - do _not_ modify the logo data here or the GB will not run the program)
	DB	$CE,$ED,$66,$66,$CC,$0D,$00,$0B,$03,$73,$00,$83,$00,$0C,$00,$0D
	DB	$00,$08,$11,$1F,$88,$89,$00,$0E,$DC,$CC,$6E,$E6,$DD,$DD,$D9,$99
	DB	$BB,$BB,$67,$63,$6E,$0E,$EC,$CC,$DD,$DC,$99,$9F,$BB,$B9,$33,$3E

	; $0134-$013E (Game title - up to 11 upper case ASCII characters; pad with $00)
	DB	0,0,0,0,0,0,0,0,0,0,0
		;0123456789A

	; $013F-$0142 (Product code - 4 ASCII characters, assigned by Nintendo, just leave blank)
	DB	"    "
		;0123

	; $0143 (Color GameBoy compatibility code)
	DB	$00	; $00 - DMG 
			; $80 - DMG/GBC
			; $C0 - GBC Only cartridge

	; $0144 (High-nibble of license code - normally $00 if $014B != $33)
	DB	$00

	; $0145 (Low-nibble of license code - normally $00 if $014B != $33)
	DB	$00

	; $0146 (GameBoy/Super GameBoy indicator)
	DB	$00	; $00 - GameBoy

	; $0147 (Cartridge type - all Color GameBoy cartridges are at least $19)
	DB	$13	; $13 - ROM + MBC3 + RAM + BATT

	; $0148 (ROM size)
	DB	$03	; $03 - 2Mbit = 256KByte = 16 banks

	; $0149 (RAM size)
	DB	$02	; $02 - 8Kbytes = 1 bank

	; $014A (Destination code)
	DB	$00	; $01 - All others
			; $00 - Japan

	; $014B (Licensee code - this _must_ be $33)
	DB	$33	; $33 - Check $0144/$0145 for Licensee code.

	; $014C (Mask ROM version - handled by RGBFIX)
	DB	$00

	; $014D (Complement check - handled by RGBFIX)
	DB	$00

	; $014E-$014F (Cartridge checksum - handled by RGBFIX)
	DW	$00


;****************************************************************************************************************************************************
;*	Program Start
;****************************************************************************************************************************************************

	SECTION "Program Start",ROM0[$0150]
Start::
	di
	xor a
	ldh [rLCDC], a			;turns the screen off
	
	ld sp, $FFFE
	
	call RAM_CLEAR
	call OAM_CLEAR
	
	ld a, 1
	ld [MAP_X], a
	ld [MAP_Y], a			;move the player to map coords (1,1) as that is the tile with the titlescreen event
	
	ld a, BANK_MAP2
	ld [$2000], a			;set the current bank to bank 2 so that we can get map data
	ld [CURR_MAP_BANK], a
	ld hl, TitleScreen
	call MAP_INITIALISE		;load the titlescreen
	
	ld a, BANK_TILESET
	ld [rROMB0], a
	ld hl, WindowTiles
	ld bc, 121*16
	ld de, $8820
	call WINDOW_LOAD		;loads the window tiles into memory
	
	ld hl, Portrait1
	call PORTRAIT_LOAD		;loads portrait 1 into the portrait slot
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call FRAME_LOAD			;loads the empty frame into the window
	
	ld a, MESSAGE_Y
	ld [rWY], a
	ld a, MESSAGE_X
	ld [rWX], a				;sets the x and y coords of the window
	
	ld a, %11100100			;load a normal palette
	ldh [rBGP], a			;sets the palette
	
	ld a, %11100001			;load an altered palette into object palette 0 so that the cursor can be seen
	ldh [rOBP0], a
	
	ld hl, maptiles
	ld bc, 84*16
	ld de, $9010
	call LOAD_TILES			;loads the background tiles
	
	ld hl, Character
	ld bc, 6*16
	ld de, $8000
	call LOAD_TILES			;loads the sprite tiles
	
	ld hl, Chest
	ld bc, 2*16
	ld de, $81E0
	call LOAD_TILES			;loads the chest tiles
	
	ld a, $01
	ld [PLAYER_SPRITE], a	;sets the player sprite state to 1, so the player is facing down
	
	ld a, 11*8 + 16
	ld [CURSOR_Y], a
	ld a, 8*6
	ld [CURSOR_X], a		;moves the cursor so that it points to New game
	ld a, 5
	ld [CURSOR_SPRITE], a	;sets the sprite to reference the cursor
	
	ld a, %00000101
	ld [rTAC], a			;start the timer
	
	ld a, GAMESTATE_OVERWORLD
	ld [GAMESTATE], a		;set the game state to GAMESTATE_OVERWORLD
	
	call MAP_MUSIC			;start the music
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a			;set the current bank to the bank no stored in CURR_MAP_BANK
	
	ld a, %11000011		
	ldh [rLCDC], a		;turn the screen back on, sets which memory locations the window and bkg use and turns the window and the bkg on
	ld a, %00000001		;enable vblank interrupt and no others
	ld [rIE], a
	ei
	
Main::
	halt						;wait for vblank
	
	;gbt_update is no longer in the Main loop, as it runs during the VBLANK interrupt
	;this is so that music can still be played from within an event
	
	call READ_JOYPAD			;get the state of the joypad (before events so that if the event requires player input, it is not input from last frame)
	call MAIN_EVENT				;and run the current event (if possible)
	
	ld a, [joypad_pressed]
	bit 3, a					;if the player is pressing start
	jp nz, MENU					;jump to MENU
	ld a, [joypad_down]			
	and $F0						;clear out lower nibble, as upper nibble contains D-Pad bits
	or a
	jr z, Main					;if a = 0 (no buttons on D-Pad being pressed), jump to Main
	call MAP_UPDATE				;Else, call MAP_UPDATE
	jr Main	
	

;****************************************************************************************************************************************************
;*	Subroutines
;****************************************************************************************************************************************************
SECTION "Support Routines", ROM0
RAM_CLEAR::
	ld bc, 8*1024
	ld hl, _RAM 
.loop:
	ld a, 0
	ld [hl+], a
	dec bc
	ld a, b
	or c
	jr nz, .loop
	ret

OAM_CLEAR::
	ld hl, $FE00
	ld b, 160
.loop:
	xor a
	ld [hl+], a
	dec b
	jr nz, .loop
	ret
	
LOAD_TILES::
	ld a, [hl+]
	ld [de], a
	inc de
	dec bc
	ld a, b
	or c
	jr nz, LOAD_TILES
	ret			

WAIT_VBLANK::
	ld a, %00000001		;enable vblank interrupt so that no other interrupt can end the halt
	ld [rIE], a
	ei
	halt				;halts until the vblank interrupt is called
	ret

DELAY::
	push af					;value in a is retained
	ld a, b
	cp 0
	jr z, DELAY_ESCAPE		;returns without waiting if b = 0
.loop:
	call WAIT_VBLANK	;as the v-blank interrupt is called ~60 times a second
	dec b					;this function loops for ~x/60 seconds where x is the initial b value
	jr nz, .loop
DELAY_ESCAPE:
	pop af
	ret
	
;values to multiply stored in c and e with d = 0 and b = 8
;result stored in hl
;Code taken from Rodnay Zak’s ‘Programming the Z80’
Multiply::
	srl c
	jr nc, NOADD
	add hl, de
NOADD:
	sla e
	rl d
	dec b
	jp nz, Multiply
	ret

;Divides register a by register b and stores the result in c
;Uses registers a, b and c
DIVIDE::
	push af			;push af so that we can load b into a without destroying the value in a
	ld a, b
	or a				;a or a = 0 if and only if a = 0,
	jr z, DIVIDE_ZERO	;if b = 0, then we would get stuck in the loop, so jump to DIVIDE_ZERO
	pop af
.loop:
	sub b			;as integer division is repeated subtraction, b is subtracted from a until an underflow occurs
	ret c	
	inc c				
	jr .loop

DIVIDE_ZERO:
	pop af
	ld c, a			;ld c, a so that we have a result
	ret
	
MAP_CLEAR::
	ld bc, 32 * 32
	ld de, _SCRN0
.loop:
	ld a, 0
	ld [de], a
	inc de
	dec bc
	ld a, b
	or c
	jr nz, .loop
	ret
	
MAP_MUSIC::
	ld a, [CURR_MAP_ADR]
	ld h, a
	ld a, [CURR_MAP_ADR+1]
	ld l, a
	push hl
	
	ld a, [CURR_MAP_BANK]
	ld b, a
	
	ld a, BANK_MAP1
	cp b
	jr z, MAP_MUSIC_BANK_1
	ld a, BANK_MAP2
	cp b
	jr z, MAP_MUSIC_BANK_2
	ld a, BANK_MAP3
	cp b
	jp z, MAP_MUSIC_BANK_3
	jp MAP_MUSIC_DEFAULT
	
MAP_MUSIC_BANK_1:
MAP_1:	
	ld de, Map1
	MAP_MUSIC_CHECK
	or a
	jr nz, MAP_2
	ld de,song_data
    ld bc,BANK(song_data)
    ld a,$05
	jp MAP_MUSIC_END
	
MAP_MUSIC_BANK_2:
BANK2_MAP1:
	ld de, TitleScreen
	MAP_MUSIC_CHECK
	or a
	jr nz, BANK2_MAP2
	ld de, range_test2_data
	ld bc, BANK(range_test2_data)
	ld a, $05
	jp MAP_MUSIC_END
	
BANK2_MAP2:
	pop hl
	push hl
	ld de, Map2
	MAP_MUSIC_CHECK
	or a
	jr nz, BANK2_MAP3
	ld de, range_test2_data
	ld bc, BANK(range_test2_data)
	ld a, $05
	jr MAP_MUSIC_END
	
BANK2_MAP3:
	pop hl
	push hl
	ld de, Map3
	MAP_MUSIC_CHECK
	or a
	jr nz, BANK2_MAP5
	ld de, range_test2_data
	ld bc, BANK(range_test2_data)
	ld a, $05
	jr MAP_MUSIC_END
	
BANK2_MAP5:
	pop hl
	push hl
	ld de, Map5
	MAP_MUSIC_CHECK
	or a
	jr nz, BANK2_MAP6
	ld de, range_test2_data
	ld bc, BANK(range_test2_data)
	ld a, $05
	jr MAP_MUSIC_END
	
BANK2_MAP6:
	pop hl
	push hl
	ld de, Map6
	MAP_MUSIC_CHECK
	or a
	jr nz, MAP_MUSIC_DEFAULT
	ld de, range_test2_data
	ld bc, BANK(range_test2_data)
	ld a, $05
	jr MAP_MUSIC_END

MAP_MUSIC_BANK_3:
BANK3_MAP4:
	ld de, Map4
	MAP_MUSIC_CHECK
	or a
	jr nz, MAP_MUSIC_DEFAULT
	ld de, range_test2_data
	ld bc, BANK(range_test2_data)
	ld a, $05
	jr MAP_MUSIC_END
	

	
MAP_MUSIC_DEFAULT:	
	ld de,song_data
    ld bc,BANK(song_data)
    ld a,$05
MAP_MUSIC_END:
	pop hl
    call gbt_play ; Play song
	call gbt_loop
	ret
	
MAP_INITIALISE::
	
	ld a, [rLCDC]		;loads the current settings for the screen
	push af				;and pushes it to the stack so that the same settings can be used when done
	ld a, 0 
	ld [rLCDC], a		;turns the screen off
	call MAP_CLEAR		;clears the map
	
	ld a, h
	ld [CURR_MAP_ADR], a	;loads the upper byte of the new map address into memory
	ld a, l
	ld [CURR_MAP_ADR+1], a	;loads the lower byte of the new map address into memory
	ld a, [hl+]
	ld [CURR_MAP_WIDTH], a	;loads the height of the new map into memory
	ld c, a
	ld a, [hl+]
	ld [CURR_MAP_HEIGHT], a	;loads the width of the new map into memory
	ld e, a
	ld d, 0
	ld b, 8
	push hl
	ld hl, 0
	call Multiply		;multiplies map height by map width and stores the results in hl
	ld d, h				;transfers the contents of hl to de
	ld e, l
	pop hl				
	add hl, de			;adds map width x map height to the address of the map data so that hl now points to the event map
	ld a, h
	ld [CURR_MAP_EVENTMP_ADR], a	;loads the upper byte of the new map event map address into memory
	ld a, l
	ld [CURR_MAP_EVENTMP_ADR+1], a	;loads the lower byte of the new map event map address into memory
	add hl, de			;adds map width x map height to the address of the event map so that hl now points to the event data
	ld a, h
	ld [CURR_MAP_EVENTS_ADR], a		;loads the upper byte of the address of event data into memory
	ld a, l
	ld [CURR_MAP_EVENTS_ADR+1], a	;loads the lower byte of the address of event data into memory
	
	ld a, [CURR_MAP_HEIGHT]
	cp 32							;if the map height does not equal 32
	jp nz, MAP_INITIALISE_GT32		;then jump to MAP_INITIALISE_GT32
	ld a, [CURR_MAP_WIDTH]
	cp 32							;if the map height does not equal 32
	jp nz, MAP_INITIALISE_GT32		;then jump to MAP_INITIALISE_GT32
	
	ld a, [CURR_MAP_ADR]
	ld h, a
	ld a, [CURR_MAP_ADR+1]
	ld l, a							;load the current map address into hl
	inc hl							;increment hl by 2 to skip over the map width and height
	inc hl							
	ld b, 32						;set the counters for map width and height to 32
	ld c, 32						
	ld de, _SCRN0					

.loop:
	ld a, [hl+]						;load a byte of map data into a and increment hl
	ld [de], a						;output that byte in screen memory
	inc de							;increment de so that it points to the next tile in memory
	dec c							;decrement the counter
	jr nz, .loop					;if c !=0 then jump to .loop
	
	ld c, 32						;c = 32
	dec b							
	jr nz, .loop					;if b != 0 then jump to .loop
									
	
	;EVENT_OVERRIDE_INIT32
	ld a, [CURR_MAP_EVENTMP_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a							;loads into hl the address of the event map
	ld b, 32						;set the counters for map width and height to 32
	ld c, 32
	ld de, _SCRN0
	
EVENT_OVERRIDE_INIT32_LOOP:
	ld a, [hl]						
	or a							;if a= 0, then or a sets the zero flag
	jr z, EVENT_OVERRIDE_INIT32_INC	;if the current event being pointed to is event 0, then jump to EVENT_OVERRIDE_INIT32_INC
	
	push hl							;pushes hl, de and bc to the stack so that their values can be retained
	push de							;and so that hl, de and bc can be used during this section
	push bc							
	
	dec a
	ld hl, 0
	ld e, a
	ld d, 0
	ld b, 8
	ld c, EVENT_LENGTH
	call Multiply				;multiplies event length by the event number -1 
	ld d, h						;transfers hl to de
	ld e, l
	
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a	
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a								;loads into hl the address of the current map events
	
	add hl, de							;adds EVENT_LENGTH*(EVENT NUMBER-1) to hl so that it now points to the data for the event 				
	ld a, [hl]							;load the memory offset into a
	or a								;if it is 0, then the event is not permanent
	jr z, EVENT_OVERRIDE_INIT32_TILE	;so we can jump to EVENT_OVERRIDE_INIT32_TILE
	
	ld b, a								;loads a into b so that the value can be loaded back into a later						
	srl a								;shifts a right 3 times so that the bit reference is no longer part of a
	srl a
	srl a
	push hl								;pushes hl so that the current value is preserved
	ld hl, EVENT_PERMANENCE				;loads into hl the memory region used for event states
	ld d, 0
	ld e, a
	add hl, de							;adds the memory offset to hl
	ld a, b								
	and %00000111						;only bits used to reference a bit in memory can be set
	ld c, a								
	ld a, [hl]							;load the byte containing the bit referenced
	jr z, .loop_escape
.loop:
	srl a								;shifts a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl
	bit 0, a							;if bit 0 = 0, then the event has not occurred
	jr z, EVENT_OVERRIDE_INIT32_TILE	;so the program jumps to EVENT_OVERRIDE_INIT32_TILE to test the first tile override for the event
	
	inc hl								;if bit 0 !=0, then the event has occurred
	jr EVENT_OVERRIDE_INIT32_TILE		;so if hl is incremented then the program can test the 2nd tile override for the event
	
EVENT_OVERRIDE_INIT32_TILE:
	inc hl								;increment hl so that it points to the tile override
	ld a, [hl]							
	or a								
	jr z, EVENT_OVERRIDE_INIT32_INC_INIT;if the tile override = 0 then jump to EVENT_OVERRIDE_INIT32_INC_INIT
	pop bc
	pop de
	pop hl
	ld [de], a							;output the tile
	jr EVENT_OVERRIDE_INIT32_INC		
	
EVENT_OVERRIDE_INIT32_INC_INIT:
	pop bc
	pop de
	pop hl
	
EVENT_OVERRIDE_INIT32_INC:
	inc hl						
	inc de
	dec c
	ld a, c
	or a
	jr nz, EVENT_OVERRIDE_INIT32_LOOP	;if the counter using c !=0, then jump to EVENT_OVERRIDE_INIT32_LOOP
	ld a, b
	cp 1								;if the counter using b = 1, then jump to EVENT_OVERRIDE_INIT32_END
	jr z, EVENT_OVERRIDE_INIT32_END
	dec b								;else decrement our b counter
	ld c, 32							;set c to 32
	jr EVENT_OVERRIDE_INIT32_LOOP		;and jump back to the start of the loop
	
EVENT_OVERRIDE_INIT32_END:
	ld a, [MAP_X]
	ld b, 8
	ld c, a
	ld hl, 0
	ld de, 8
	call Multiply
	ld a, l
	sub 8
	ld [rSCX], a						;sets scrollx to (8*mapx)-8
	ld a, [MAP_Y]
	ld b, 8
	ld c, a
	ld hl, 0
	ld de, 8
	call Multiply
	ld a, l
	sub 8
	ld [rSCY], a						;sets scrolly to (8*mapx)-8
	
	pop af
	ld [rLCDC], a						;sets the screen back to how it was before the function
	ret

MAP_INITIALISE_GT32::
	ld a, [CURR_MAP_ADR]			;loads the map address into hl
	ld h, a
	ld a, [CURR_MAP_ADR+1]
	ld l, a
	inc hl
	inc hl							;skips over the width and height of the map
	
	ld a, [MAP_X]					
	dec a
	ld d, 0
	ld e, a							
	add hl, de						;adds mapX-1 to hl
	
	ld b, 8
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld a, [MAP_Y]
	dec a
	ld e, a 
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de						;adds Width * (MapY-1) to hl so that it points to the correct first tile to display
	
	ld c, 18
	ld b, 20
	
	xor a							;sets a to 0
	ld [rSCX], a
	ld [rSCY], a
	
	ld de, _SCRN0
	
.loop:
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, .loop				;outputs 20 tiles
	
	ld a, [CURR_MAP_WIDTH]
	sub 20
	push de
	ld d, 0
	ld e, a
	add hl, de					;increments hl by Width - 20
	pop de
	
	ld a, e
	add 12
	ld e, a
	ld a, d
	adc 0
	ld d, a						;increments de by 12 so that it points to the start of the next line

	ld b, 20					
	dec c
	
	jr nz, .loop
	
	;event_override_init
	ld a, [CURR_MAP_EVENTMP_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a
	
	ld a, [MAP_X]
	dec a
	ld e, a
	ld d, 0
	add hl, de						;adds MapX to hl so that it points to the correct column of the map
	
	ld a, [MAP_Y]
	dec a
	ld e, a
	ld b, 8
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de						;adds Width * (MapY-1) to hl so that it points to the correct first tile to display
	
	ld b, 20
	ld c, 18
	
	ld de, _SCRN0
	
EVENT_OVERRIDE_INIT_LOOP:
	ld a, [hl]
	or a
	jr z, EVENT_OVERRIDE_INIT_INC

	push hl							;pushes hl, de and bc to the stack so that their values can be retained
	push de							;and so that hl, de and bc can be used during this section
	push bc							
	
	dec a
	ld hl, 0
	ld e, a
	ld d, 0
	ld b, 8
	ld c, EVENT_LENGTH
	call Multiply				;multiplies event length by the event number -1 
	ld d, h						;transfers hl to de
	ld e, l
	
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a	
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a								;loads into hl the address of the current map events
	
	add hl, de							;adds EVENT_LENGTH*(EVENT NUMBER-1) to hl so that it now points to the data for the event 				
	ld a, [hl]							;load the memory offset into a
	or a								;if it is 0, then the event is not permanent
	jr z, EVENT_OVERRIDE_INIT_TILE		;so we can jump to EVENT_OVERRIDE_INIT_TILE
	
	ld b, a								;loads a into b so that the value can be loaded back into a later						
	srl a								;shifts a right 3 times so that the bit reference is no longer part of a
	srl a
	srl a
	push hl								;pushes hl so that the current value is preserved
	ld hl, EVENT_PERMANENCE				;loads into hl the memory region used for event states
	ld d, 0
	ld e, a
	add hl, de							;adds the memory offset to hl
	ld a, b								
	and %00000111						;only bits used to reference a bit in memory can be set
	ld c, a								
	ld a, [hl]							;load the byte containing the bit referenced
	jr z, .loop_escape
.loop:
	srl a								;shifts a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl
	bit 0, a							;if bit 0 = 0, then the event has not occurred
	jr z, EVENT_OVERRIDE_INIT_TILE		;so the program jumps to EVENT_OVERRIDE_INIT_TILE to test the first tile override for the event
	
	inc hl								;if bit 0 !=0, then the event has occurred
	jr EVENT_OVERRIDE_INIT_TILE			;so if hl is incremented then the program can test the 2nd tile override for the event
	
EVENT_OVERRIDE_INIT_TILE:
	inc hl								;increment hl so that it points to the tile override
	ld a, [hl]							
	or a								
	jr z, EVENT_OVERRIDE_INIT_INC_INIT	;if the tile override = 0 then jump to EVENT_OVERRIDE_INIT_INC_INIT
	pop bc
	pop de
	pop hl
	ld [de], a							;output the tile
	jr EVENT_OVERRIDE_INIT_INC		
	
EVENT_OVERRIDE_INIT_INC_INIT:
	pop bc
	pop de
	pop hl	
	
EVENT_OVERRIDE_INIT_INC:
	inc hl							;increment pointers
	inc de
	dec b
	jr nz, EVENT_OVERRIDE_INIT_LOOP	;if the counter using b != 0 then jump to EVENT_OVERRIDE_INIT_LOOP
	ld a, c
	cp 1
	jr z, EVENT_OVERRIDE_INIT_END	;if the counter using c = 1 then jump to EVENT_OVERRIDE_INIT_END
	dec c
	ld b, 20	;reset b to 20
	ld a, e
	add 12		;increment de by 12
	ld e, a
	ld a, d
	adc 0
	ld d, a
	
	ld a, [CURR_MAP_WIDTH]
	sub 20
	push de
	ld d, 0
	ld e, a
	add hl, de
	pop de
	jr EVENT_OVERRIDE_INIT_LOOP	

EVENT_OVERRIDE_INIT_END:
	
	pop af
	ld [rLCDC], a
	ret


MAP_UPDATE::
	ld a, [rTIMA]
	ld b, a						;Loads the value of the Timer Counter into b
	
	ld a, [rDIV]				;Loads the value of the Divider into a
	
	xor b						;Xors a and b
	ld [RANDOM_NO_SEED], a		;Stores the result in memory
	
	xor a						;a xor a = 0, so it sets a to 0
	ld [rTIMA], a				;Resets the Timer Counter
	
	ld a, [CURR_MAP_WIDTH]	
	cp 32						;if map width != 32 
	jp nz, MAP_UPDATE_NORM		;then jump to MAP_UPDATE_NORM
	ld a, [CURR_MAP_HEIGHT]		
	cp 32						;if map height != 32
	jp nz, MAP_UPDATE_NORM		;then jump to MAP_UPDATE_NORM
	
MAP32_UPDATE::					;map height and width = 32
	ld a, [joypad_down]
	bit 6, a						;if bit 6 is set, then the player is pressing up,
	jr nz, MAP32_UPDATE_UP			;so jump to MAP32_UPDATE_UP
	bit 7, a						;if bit 7 is set, then the player is pressing down,
	jp nz, MAP32_UPDATE_DOWN		;so jump to MAP32_UPDATE_DOWN
	bit 5, a						;if bit 5 is set, then the player is pressing left,
	jp nz, MAP32_UPDATE_LEFT		;so jump to MAP32_UPDATE_LEFT
	jp MAP32_UPDATE_RIGHT			;if the program reaches this point, then the player has to be pressing right, so jump to MAP32_UPDATE_RIGHT
	
MAP32_UPDATE_UP::
	call WAIT_VBLANK
	ld a, PLAYER_UP
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a		;updates the sprite

	ld a, [MAP_Y]
	cp 1						;if map y = 1
	ret z						;then return
	
	ld hl, _SCRN0				;we want to point to the tile above the player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X + 32(rSCY/8 -1 + PLAYER_Y)
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	dec a
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + 32(rSCY/8 -1), which is the tile above the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile above the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile above the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_Y]
	dec a
	ld [MAP_Y], a			;decrement MAP_Y by 1
	
	ld a, [rSCY]
	sub 8
	ld [rSCY], a
	
	call WAIT_VBLANK	;wait for VBLANK so that the function takes ~ the same amount of time as MAP_UPDATE_UP
	ret

MAP32_UPDATE_DOWN::
	call WAIT_VBLANK
	ld a, PLAYER_DOWN		
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a		;updates the sprite

	ld a, [MAP_Y]
	cp 15						;if map y = 15
	ret z						;then we are at the bottom of the map, so return
	
	ld hl, _SCRN0				;we want to point to the tile below the player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X + 32(rSCY/8 -1 + PLAYER_Y) + 64
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	dec a
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + 32(rSCY/8 -1)
	
	ld de, 64
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + PLAYER_X + 32(rSCY/8 -1 + PLAYER_Y) + 64, so it points to the tile below the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile below the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile below the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_Y]
	inc a
	ld [MAP_Y], a			;increment MAP_Y by 1
	
	ld a, [rSCY]
	add 8
	ld [rSCY], a
	
	call WAIT_VBLANK	;wait for VBLANK so that the function takes ~ the same amount of time as MAP_UPDATE_DOWN
	ret
	
MAP32_UPDATE_LEFT::
	call WAIT_VBLANK
	ld a, PLAYER_LEFT
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a		;updates the sprite
	
	ld a, [MAP_X]
	cp 1						;if map x = 1
	ret z						;then return
	
	ld hl, _SCRN0				;we want to point to the tile left of player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X -1 + 32(rSCY/8 + PLAYER_Y)
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	dec a
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + PLAYER_X -1 + 32(rSCY/8 + PLAYER_Y), which is the tile to the left of the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile to the left of the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile to the left of the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_X]
	dec a
	ld [MAP_X], a			;decrement MAP_X by 1
	
	ld a, [rSCX]
	sub 8
	ld [rSCX], a
	
	call WAIT_VBLANK	;wait for VBLANK so that the function takes ~ the same amount of time as MAP_UPDATE_LEFT
	ret
	
MAP32_UPDATE_RIGHT::
	call WAIT_VBLANK
	ld a, PLAYER_RIGHT
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a				;updates the sprite

	ld a, [MAP_X]
	ld b, a
	ld a, [CURR_MAP_WIDTH]
	sub 19
	cp b						;if map x = map width - 19
	ret z						;then return
	
	ld hl, _SCRN0				;we want to point to the tile to the right of player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X +1 + 32(rSCY/8 + PLAYER_Y)
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	inc a
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + PLAYER_X +1 + 32(rSCY/8 + PLAYER_Y), which is the tile to the right of the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile to the right of the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile to the right of the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_X]
	inc a
	ld [MAP_X], a			;Increment MAP_X by 1
	
	ld a, [rSCX]
	add 8
	ld [rSCX], a
	
	call WAIT_VBLANK	;wait for VBLANK so that the function takes ~ the same amount of time as MAP_UPDATE_RIGHT
	ret

	
MAP_UPDATE_NORM:
	ld a, [joypad_down]
	bit 6, a					;if bit 6 is set, then the player is pressing up,
	jr nz, MAP_UPDATE_UP		;so jump to MAP_UPDATE_UP
	bit 7, a					;if bit 7 is set, then the player is pressing down,
	jp nz, MAP_UPDATE_DOWN		;so jump to MAP_UPDATE_DOWN
	bit 5, a					;if bit 5 is set, then the player is pressing left,
	jp nz, MAP_UPDATE_LEFT		;so jump to MAP_UPDATE_LEFT
	jp MAP_UPDATE_RIGHT			;if the program reaches this point, then the player has to be pressing right, so jump to MAP_UPDATE_RIGHT
	
MAP_UPDATE_UP::
	call WAIT_VBLANK
	ld a, PLAYER_UP
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a		;updates the sprite

	ld a, [MAP_Y]
	cp 1						;if map y = 1
	ret z						;then return
	
	ld hl, _SCRN0				;we want to point to the tile above the player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X + 32(rSCY/8 -1 + PLAYER_Y)
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	dec a
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + 32(rSCY/8 -1), which is the tile above the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile above the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile above the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_Y]
	dec a
	ld [MAP_Y], a			;decrement MAP_Y by 1
	
	ld a, [CURR_MAP_ADR]	;we want to point to the first tile we should load in on the new row,
	ld h, a					;so we want hl to contain map (+2) + (mapX-1) + (mapWidth*(mapY-1))
	ld a, [CURR_MAP_ADR+1]
	ld l, a					;loads into hl the address of the current map
	inc hl
	inc hl					;skips over the map width and height
	
	ld a, [MAP_X]
	dec a
	ld d, 0
	ld e, a
	add hl, de				;hl now contains map (+2) + (mapX-1)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	dec a
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de			;hl now contains map (+2) + (mapX-1) + (mapWidth*(mapY-1))
	
	ld c, 20
	ld de, NEW_TILES
TILES_LOOP:
	ld a, [hl+]			;loads into a one of the new tiles
	ld [de], a			;and outputs it in ram
	inc de
	dec c
	jr nz, TILES_LOOP	;if the counter !=0, then jump to TILES_LOOP
	
	ld a, [CURR_MAP_EVENTMP_ADR]	;we want to point to the first event tile we should load in on the new row,
	ld h, a							;so we want hl to contain eventmap + (mapX-1) + (mapWidth(mapY-1))
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a
	
	ld a, [MAP_X]
	dec a
	ld d, 0
	ld e, a
	add hl, de						;hl now contains eventmap + (mapX-1)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	dec a
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de						;hl now contains eventmap + (mapX-1) + (mapWidth(mapY-1))
	
	ld c, 20
	ld de, NEW_TILES
EVENT_TILES_LOOP:
	ld a, [hl]						
	or a							;or a is the same as cp 0
	jr z, EVENT_TILES_INC			;so if the event tile = 0, then jump to EVENT_TILES_INC
	
	push hl
	push bc
	push de							;hl, bc and de need to be preserved, but also need to be used here, so they are pushed to the stack
	
	dec a							;we want hl to point to the event referenced,
	ld c, a							;so we want hl to contain events_adr + EVENT_LENGTH(tile-1)
	ld b, 8
	ld hl, 0
	ld e, EVENT_LENGTH
	ld d, 0
	call Multiply
	ld d, h
	ld e, l
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a
	add hl, de						;hl now points to the event referenced by the tile
	
	ld a, [hl]
	or a 							;if the byte used for permanence is 0, then the event is not permanent
	jr z, EVENT_TILES_TILECHECK		;so we can skip checking bits in memory and we can jump to EVENT_TILES_TILECHECK
	
	push hl							;as hl contains the address of the event referenced by the event tile, we need to preserve the value in hl
	
	ld b, a							;a contains the memory offset and bit reference 
	ld hl, EVENT_PERMANENCE
	
	ld a, b
	srl a
	srl a
	srl a							;a now only contains the memory offset
	ld d, 0
	ld e, a
	add hl, de						;so it can be added to hl so that it points to the correct byte
	
	ld a, b
	and %00000111
	ld c, a							;loads a into c so that the bit reference can be used as a counter
	ld a, [hl]						;loads the byte referenced into a
	jr z, .loop_escape				;if the bit referenced is bit 0, then jump to .loop_escape
.loop:
	srl a							;shift a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl					
	bit 0, a						;test bit 0
	jr z, EVENT_TILES_TILECHECK		;if it is 0 then jump to EVENT_TILES_TILECHECK to check the first tile override
	inc hl							;else increment hl so that the 2nd tile override will be checked
	
EVENT_TILES_TILECHECK:
	inc hl							;increment hl so that it points to the tile override
	ld a, [hl]						
	or a
	jr z, EVENT_TILES_INC_INIT		;if the tile override = 0, then jump to EVENT_TILES_INC_INIT
	pop de
	pop bc 
	pop hl
	ld [de], a						;else load the event tile into RAM in place of the background tile
	jr EVENT_TILES_INC

EVENT_TILES_INC_INIT:	
	pop de
	pop bc
	pop hl
	
EVENT_TILES_INC:
	inc hl						;increment the pointers
	inc de
	dec c						;decrement the counter
	jr nz, EVENT_TILES_LOOP		;if the counter != 0, then jump to EVENT_TILES_LOOP
	
	ld hl, _SCRN0				;we want hl to point to the first point to output tiles,
	ld a, [rSCX]				;so we want hl to contain _SCRN0 + rSCX/8 + 32(rSCY/8)
	srl a
	srl a
	srl a						;3 right shifts is equivalent to dividing by 8
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0 + rSCX/8
	
	ld a, [rSCY]
	ld d, 0
	ld e, a
	
	srl e
	srl e
	srl e						;3 right shifts to divide by 8
	sla e						
	rl d						;rl d rotates d left through the carry bit, so sla e and rl d is equivalent to a left shift for de
	sla e							
	rl d
	sla e
	rl d
	sla e
	rl d
	sla e
	rl d						;5 left shifts to multiply by 32
	add hl, de
	
	ld de, SUBTRACT_32			
	add hl, de					;subtract 32
	
	ld a, h
	cp $98
	jr nc, EVENT_TILES_OUT_INIT	;if there is a carry, then h > $98, so hl < $9800
	
	ld hl, $9BE0				;if hl < $9800, then rSCX is at the top of the screen, so we set hl to be at the bottom
	ld a, [rSCX]
	srl a
	srl a
	srl a
	ld d, 0
	ld e, a
	add hl, de
	
EVENT_TILES_OUT_INIT:
	ld b, 20
	ld de, NEW_TILES
	call WAIT_VBLANK		;make sure we are in vblank so that we can output the tiles
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	
	ld a, [de]					;load a tile into a
	ld [hl+], a					;and output it
	inc de
	
	ld a, l
	and $F0
	ld c, a
	dec hl
	ld a, l
	and $F0
	inc hl
	cp c
	jr z, .loop_dec				;if the upper nibble of l = the upper nibble of l from hl -1, then jump to .loop_dec
	bit 4, a
	jr z, .loop_dec				;if bit 4 of l = 0, then jump to .loop_dec 
	push de
	ld de, SUBTRACT_32			
	add hl, de					;else subtract hl by 32
	pop de

.loop_dec	
	dec b
	jr nz, .loop				;if the counter != 0, then jump to .loop
	
	ld a, [rSCY]
	sub 8
	ld [rSCY], a				;ScrollY= ScrollY - 8
	ret

MAP_UPDATE_DOWN::
	call WAIT_VBLANK
	ld a, PLAYER_DOWN		
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a				;updates the sprite

	ld a, [CURR_MAP_HEIGHT]
	sub 17
	ld c, a
	ld a, [MAP_Y]
	cp c						;if map y = MAP_HEIGHT - 17
	ret z						;then we are at the bottom of the map, so return
	
	ld hl, _SCRN0				;we want to point to the tile below the player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X + 32(rSCY/8 -1 + PLAYER_Y) + 64
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	dec a
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + 32(rSCY/8 -1)
	
	ld de, 64
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + PLAYER_X + 32(rSCY/8 -1 + PLAYER_Y) + 64, so it points to the tile below the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile below the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile below the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_Y]
	inc a
	ld [MAP_Y], a			;increment MAP_Y by 1
	
	ld a, [CURR_MAP_ADR]	;we want to point to the first tile we should load in on the new row,
	ld h, a					;so we want hl to contain map (+2) + (mapX-1) + (mapWidth*(mapY-1 + 17))
	ld a, [CURR_MAP_ADR+1]
	ld l, a					;loads into hl the address of the current map
	inc hl
	inc hl					;skips over the map width and height
	
	ld a, [MAP_X]
	dec a
	ld d, 0
	ld e, a
	add hl, de				;hl now contains map (+2) + (mapX-1)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	add 16					;-1+17 is the same as + 16
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de			;hl now contains map (+2) + (mapX-1) + (mapWidth*(mapY-1 + 17))
	
	ld c, 20
	ld de, NEW_TILES
D_TILES_LOOP:
	ld a, [hl+]			;loads into a one of the new tiles
	ld [de], a			;and outputs it in ram
	inc de
	dec c
	jr nz, D_TILES_LOOP	;if the counter !=0, then jump to TILES_LOOP
	
	ld a, [CURR_MAP_EVENTMP_ADR]	;we want to point to the first event tile we should load in on the new row,
	ld h, a							;so we want hl to contain eventmap + (mapX-1) + (mapWidth(mapY-1 + 17))
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a
	
	ld a, [MAP_X]
	dec a
	ld d, 0
	ld e, a
	add hl, de						;hl now contains eventmap + (mapX-1)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	add 16							;-1+17 is the same as + 16
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de						;hl now contains eventmap + (mapX-1) + (mapWidth(mapY-1 + 17))
	
	ld c, 20
	ld de, NEW_TILES
D_EVENT_TILES_LOOP:
	ld a, [hl]						
	or a							;or a is the same as cp 0
	jr z, D_EVENT_TILES_INC			;so if the event tile = 0, then jump to D_EVENT_TILES_INC
	
	push hl
	push bc
	push de							;hl, bc and de need to be preserved, but also need to be used here, so they are pushed to the stack
	
	dec a							;we want hl to point to the event referenced,
	ld c, a							;so we want hl to contain events_adr + EVENT_LENGTH(tile-1)
	ld b, 8
	ld hl, 0
	ld e, EVENT_LENGTH
	ld d, 0
	call Multiply
	ld d, h
	ld e, l
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a
	add hl, de						;hl now points to the event referenced by the tile
	
	ld a, [hl]
	or a 							;if the byte used for permanence is 0, then the event is not permanent
	jr z, D_EVENT_TILES_TILECHECK	;so we can skip checking bits in memory and we can jump to D_EVENT_TILES_TILECHECK
	
	push hl							;as hl contains the address of the event referenced by the event tile, we need to preserve the value in hl
	
	ld b, a							;a contains the memory offset and bit reference 
	ld hl, EVENT_PERMANENCE
	
	ld a, b
	srl a
	srl a
	srl a							;a now only contains the memory offset
	ld d, 0
	ld e, a
	add hl, de						;so it can be added to hl so that it points to the correct byte
	
	ld a, b
	and %00000111
	ld c, a							;loads a into c so that the bit reference can be used as a counter
	ld a, [hl]						;loads the byte referenced into a
	jr z, .loop_escape				;if the bit referenced is bit 0, then jump to .loop_escape
.loop:
	srl a							;shift a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl					
	bit 0, a						;test bit 0
	jr z, D_EVENT_TILES_TILECHECK	;if it is 0 then jump to D_EVENT_TILES_TILECHECK to check the first tile override
	inc hl							;else increment hl so that the 2nd tile override will be checked
	
D_EVENT_TILES_TILECHECK:
	inc hl							;increment hl so that it points to the tile override
	ld a, [hl]						
	or a
	jr z, D_EVENT_TILES_INC_INIT	;if the tile override = 0, then jump to D_EVENT_TILES_INC_INIT
	pop de
	pop bc 
	pop hl
	ld [de], a						;else load the event tile into RAM in place of the background tile
	jr D_EVENT_TILES_INC

D_EVENT_TILES_INC_INIT:	
	pop de
	pop bc
	pop hl
	
D_EVENT_TILES_INC:
	inc hl						;increment the pointers
	inc de
	dec c						;decrement the counter
	jr nz, D_EVENT_TILES_LOOP	;if the counter != 0, then jump to D_EVENT_TILES_LOOP
	
	ld hl, _SCRN0				;we want hl to point to the first point to output tiles,
	ld a, [rSCX]				;so we want hl to contain _SCRN0 + rSCX/8 + 32(rSCY/8)
	srl a
	srl a
	srl a						;3 right shifts is equivalent to dividing by 8
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0 + rSCX/8
	
	ld a, [rSCY]
	ld d, 0
	ld e, a
	
	srl e
	srl e
	srl e						;3 right shifts to divide by 8
	sla e						
	rl d						;rl d rotates d left through the carry bit, so sla e and rl d is equivalent to a left shift for de
	sla e							
	rl d
	sla e
	rl d
	sla e
	rl d
	sla e
	rl d						;5 left shifts to multiply by 32
	add hl, de
	
	ld de, 18*32		
	add hl, de					
	
	ld a, h
	cp $9B
	jr c, D_EVENT_TILES_OUT_INIT	;if there is a carry, then hl < $9B, so if there is not then hl >= $9B
	jr z, D_EVENT_TILES_OUT_INIT	;if the zero flag is set, then h = $9B, so hl is not > $9BFF
	
	ld de, SUBTRACT_1024
	add hl, de
	
D_EVENT_TILES_OUT_INIT:
	ld b, 20
	ld de, NEW_TILES
	call WAIT_VBLANK		;make sure we are in vblank so that we can output the tiles
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK

	ld a, [de]					;load a tile into a
	ld [hl+], a					;and output it
	inc de
	
	ld a, l
	and $F0
	ld c, a
	dec hl
	ld a, l
	and $F0
	inc hl
	cp c
	jr z, .loop_dec				;if the upper nibble of l = the upper nibble of l from hl -1, then jump to .loop_dec
	bit 4, a
	jr z, .loop_dec				;if bit 4 of l = 0, then jump to .loop_dec 
	push de
	ld de, SUBTRACT_32			
	add hl, de					;else subtract hl by 32
	pop de

.loop_dec	
	dec b
	jr nz, .loop				;if the counter != 0, then jump to .loop
	
	ld a, [rSCY]
	add 8
	ld [rSCY], a				;ScrollY= ScrollY + 8	
	ret

MAP_UPDATE_LEFT::
	call WAIT_VBLANK
	ld a, PLAYER_LEFT
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a				;updates the sprite
	
	ld a, [MAP_X]
	cp 1						;if map x = 1
	ret z						;then return
	
	ld hl, _SCRN0				;we want to point to the tile left of player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X -1 + 32(rSCY/8 + PLAYER_Y)
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	and $1F
	
	or a
	jr z, MAP_UPDATE_LEFT_NO_DEC
	
	dec a
MAP_UPDATE_LEFT_NO_DEC:
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + PLAYER_X -1 + 32(rSCY/8 + PLAYER_Y), which is the tile to the left of the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile to the left of the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile to the left of the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_X]
	dec a
	ld [MAP_X], a			;decrement MAP_X by 1
	
	ld a, [CURR_MAP_ADR]	;we want to point to the first tile we should load in on the new row,
	ld h, a					;so we want hl to contain map (+2) + (mapX-1) + (mapWidth*(mapY-1))
	ld a, [CURR_MAP_ADR+1]
	ld l, a					;loads into hl the address of the current map
	inc hl
	inc hl					;skips over the map width and height
	
	ld a, [MAP_X]
	dec a
	ld d, 0
	ld e, a
	add hl, de				;hl now contains map (+2) + (mapX-1)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	dec a
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de			;hl now contains map (+2) + (mapX-1) + (mapWidth*(mapY-1))
	
	ld c, 18
	ld de, NEW_TILES
L_TILES_LOOP:
	ld a, [hl]			;loads into a one of the new tiles
	ld [de], a			;and outputs it in ram
	inc de
	
	push de
	ld a, [CURR_MAP_WIDTH]			;increment hl by map width so that it points to the tile on the next row down
	ld d, 0
	ld e, a
	add hl, de
	pop de
	
	dec c
	jr nz, L_TILES_LOOP				;if the counter !=0, then jump to L_TILES_LOOP
	
	ld a, [CURR_MAP_EVENTMP_ADR]	;we want to point to the first event tile we should load in on the new row,
	ld h, a							;so we want hl to contain eventmap + (mapX-1) + (mapWidth(mapY-1))
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a
	
	ld a, [MAP_X]
	dec a
	ld d, 0
	ld e, a
	add hl, de						;hl now contains eventmap + (mapX-1)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	dec a
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de						;hl now contains eventmap + (mapX-1) + (mapWidth(mapY-1))
	
	ld c, 18
	ld de, NEW_TILES
L_EVENT_TILES_LOOP:
	ld a, [hl]						
	or a							;or a is the same as cp 0
	jr z, L_EVENT_TILES_INC			;so if the event tile = 0, then jump to L_EVENT_TILES_INC
	
	push hl
	push bc
	push de							;hl, bc and de need to be preserved, but also need to be used here, so they are pushed to the stack
	
	dec a							;we want hl to point to the event referenced,
	ld c, a							;so we want hl to contain events_adr + EVENT_LENGTH(tile-1)
	ld b, 8
	ld hl, 0
	ld e, EVENT_LENGTH
	ld d, 0
	call Multiply
	ld d, h
	ld e, l
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a
	add hl, de						;hl now points to the event referenced by the tile
	
	ld a, [hl]
	or a 							;if the byte used for permanence is 0, then the event is not permanent
	jr z, L_EVENT_TILES_TILECHECK		;so we can skip checking bits in memory and we can jump to L_EVENT_TILES_TILECHECK
	
	push hl							;as hl contains the address of the event referenced by the event tile, we need to preserve the value in hl
	
	ld b, a							;a contains the memory offset and bit reference 
	ld hl, EVENT_PERMANENCE
	
	ld a, b
	srl a
	srl a
	srl a							;a now only contains the memory offset
	ld d, 0
	ld e, a
	add hl, de						;so it can be added to hl so that it points to the correct byte
	
	ld a, b
	and %00000111
	ld c, a							;loads a into c so that the bit reference can be used as a counter
	ld a, [hl]						;loads the byte referenced into a
	jr z, .loop_escape				;if the bit referenced is bit 0, then jump to .loop_escape
.loop:
	srl a							;shift a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl					
	bit 0, a						;test bit 0
	jr z, L_EVENT_TILES_TILECHECK	;if it is 0 then jump to L_EVENT_TILES_TILECHECK to check the first tile override
	inc hl							;else increment hl so that the 2nd tile override will be checked
	
L_EVENT_TILES_TILECHECK:
	inc hl							;increment hl so that it points to the tile override
	ld a, [hl]						
	or a
	jr z, L_EVENT_TILES_INC_INIT		;if the tile override = 0, then jump to L_EVENT_TILES_INC_INIT
	pop de
	pop bc 
	pop hl
	ld [de], a						;else load the event tile into RAM in place of the background tile
	jr L_EVENT_TILES_INC

L_EVENT_TILES_INC_INIT:	
	pop de
	pop bc
	pop hl
	
L_EVENT_TILES_INC:
	push de
	ld a, [CURR_MAP_WIDTH]		;increment hl by map width so that it points to the tile on the next row down
	ld e, a
	ld d, 0
	add hl, de
	pop de
								;increment the pointers
	inc de
	dec c						;decrement the counter
	jr nz, L_EVENT_TILES_LOOP	;if the counter != 0, then jump to L_EVENT_TILES_LOOP
	
	ld hl, _SCRN0				;we want hl to point to the first point to output tiles,
	ld a, [rSCX]				;so we want hl to contain _SCRN0 + rSCX/8 + 32(rSCY/8)
	srl a
	srl a
	srl a						;3 right shifts is equivalent to dividing by 8
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0 + rSCX/8
	
	ld a, [rSCY]
	ld d, 0
	ld e, a
	
	srl e
	srl e
	srl e						;3 right shifts to divide by 8
	sla e						
	rl d						;rl d rotates d left through the carry bit, so sla e and rl d is equivalent to a left shift for de
	sla e							
	rl d
	sla e
	rl d
	sla e
	rl d
	sla e
	rl d						;5 left shifts to multiply by 32
	add hl, de
	
	dec hl						;hl = hl -1
		
	ld a, l						
	and $0F
	cp $0F							;If r1 doesn't end if $F
	jr nz, L_EVENT_TILES_OUT_INIT 	;then jump to L_EVENT_TILES_OUT_INIT
	
	ld a, l
	bit 4, l
	jr z, L_EVENT_TILES_OUT_INIT	;If bit 4 = 0, then jump to L_EVENT_TILES_OUT_INIT
	
	ld de, 32
	add hl, de
	
L_EVENT_TILES_OUT_INIT:
	ld b, 18
	ld de, NEW_TILES
	call WAIT_VBLANK		;make sure we are in vblank so that we can output the tiles
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [de]					;load a tile into a
	ld [hl], a					;and output it
	
	inc de
	push de
	ld de, 32					
	add hl, de					;increment hl by 32 so that it points to the row below
	pop de
	
	ld a, h
	cp $9C						
	jr c, .loop_dec				;if there is a carry, then a < $9C so hl <= $9BFF
	
	push de
	ld de, SUBTRACT_1024
	add hl, de
	pop de
	
.loop_dec	
	dec b
	jr nz, .loop				;if the counter != 0, then jump to .loop
	
	ld a, [rSCX]
	sub 8
	ld [rSCX], a				;ScrollX= ScrollX - 8
	ret

MAP_UPDATE_RIGHT::
	call WAIT_VBLANK
	ld a, PLAYER_RIGHT
	ld [PLAYER_DIR], a			;sets the player direction
	ld [PLAYER_SPRITE], a				;updates the sprite

	ld a, [MAP_X]
	ld b, a
	ld a, [CURR_MAP_WIDTH]
	sub 19
	cp b						;if map x = map width - 19
	ret z						;then return
	
	ld hl, _SCRN0				;we want to point to the tile to the right of player, so we want hl to contain 
	ld a, [rSCX]				;_SCRN0+ rSCX/8 + PLAYER_X +1 + 32(rSCY/8 + PLAYER_Y)
	srl a						
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_X
	inc a
	and $1F
	
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0+ rSCX/8 + PLAYER_X
	
	ld a, [rSCY]
	srl a
	srl a
	srl a						;right shift is the same as dividing by 2, so srl a 3 times is the same as dividing a by 8
	add PLAYER_Y
	ld e, a
	ld b, 8
	ld c, 32
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de				;hl now contains _SCRN0+ rSCX/8 + PLAYER_X +1 + 32(rSCY/8 + PLAYER_Y), which is the tile to the right of the player
	
	ld a, h
	cp $9C					;if h contains $9C, then it is pointing too far ahead,
	jr nz, .loop_init
	ld h, $98				;so set h back to $98 so that it is pointing to the correct tile
	
.loop_init:	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl]				;loads the tile to the right of the player into a
	ld b, a					;and stores it in b so it can be used in a comparison
	ld de, UncrossableTiles
	ld a, [de]
	ld c, a					;the first byte at UncrossableTiles contains the no of tiles, so it is stored in c as a counter
	inc de					;de is incremented so it points at the first tile
.loop:
	ld a, [de]				;load into a one of the uncrossable tiles 
	cp b					;compare it with the tile to the right of the player
	ret z					;if they are the same, return
	inc de					;else increment de
	dec c					;and decrement the counter
	jr nz, .loop			;if the counter !=0, then jump to .loop
	
	ld a, [MAP_X]
	inc a
	ld [MAP_X], a			;Increment MAP_X by 1
	
	ld a, [CURR_MAP_ADR]	;we want to point to the first tile we should load in on the new row,
	ld h, a					;so we want hl to contain map (+2) + (mapX-1 + 19) + (mapWidth*(mapY-1))
	ld a, [CURR_MAP_ADR+1]
	ld l, a					;loads into hl the address of the current map
	inc hl
	inc hl					;skips over the map width and height
	
	ld a, [MAP_X]
	add 18					;-1+19 is the same as + 18
	ld d, 0
	ld e, a
	add hl, de				;hl now contains map (+2) + (mapX-1 + 19)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	dec a
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de			;hl now contains map (+2) + (mapX-1 + 19) + (mapWidth*(mapY-1))
	
	ld c, 18
	ld de, NEW_TILES
R_TILES_LOOP:
	ld a, [hl]			;loads into a one of the new tiles
	ld [de], a			;and outputs it in ram
	inc de
	
	push de
	ld a, [CURR_MAP_WIDTH]			;increment hl by map width so that it points to the tile on the next row down
	ld d, 0
	ld e, a
	add hl, de
	pop de
	
	dec c
	jr nz, R_TILES_LOOP				;if the counter !=0, then jump to R_TILES_LOOP
	
	ld a, [CURR_MAP_EVENTMP_ADR]	;we want to point to the first event tile we should load in on the new row,
	ld h, a							;so we want hl to contain eventmap + (mapX-1 + 19) + (mapWidth(mapY-1))
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a
	
	ld a, [MAP_X]
	add 18							;-1+19 is the same as + 18
	ld d, 0
	ld e, a
	add hl, de						;hl now contains eventmap + (mapX-1+19)
	
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	ld b, 8
	ld a, [MAP_Y]
	dec a
	ld e, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de						;hl now contains eventmap + (mapX-1 + 19) + (mapWidth(mapY-1))
	
	ld c, 18
	ld de, NEW_TILES
R_EVENT_TILES_LOOP:
	ld a, [hl]						
	or a							;or a is the same as cp 0
	jr z, R_EVENT_TILES_INC			;so if the event tile = 0, then jump to R_EVENT_TILES_INC
	
	push hl
	push bc
	push de							;hl, bc and de need to be preserved, but also need to be used here, so they are pushed to the stack
	
	dec a							;we want hl to point to the event referenced,
	ld c, a							;so we want hl to contain events_adr + EVENT_LENGTH(tile-1)
	ld b, 8
	ld hl, 0
	ld e, EVENT_LENGTH
	ld d, 0
	call Multiply
	ld d, h
	ld e, l
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a
	add hl, de						;hl now points to the event referenced by the tile
	
	ld a, [hl]
	or a 							;if the byte used for permanence is 0, then the event is not permanent
	jr z, R_EVENT_TILES_TILECHECK		;so we can skip checking bits in memory and we can jump to R_EVENT_TILES_TILECHECK
	
	push hl							;as hl contains the address of the event referenced by the event tile, we need to preserve the value in hl
	
	ld b, a							;a contains the memory offset and bit reference 
	ld hl, EVENT_PERMANENCE
	
	ld a, b
	srl a
	srl a
	srl a							;a now only contains the memory offset
	ld d, 0
	ld e, a
	add hl, de						;so it can be added to hl so that it points to the correct byte
	
	ld a, b
	and %00000111
	ld c, a							;loads a into c so that the bit reference can be used as a counter
	ld a, [hl]						;loads the byte referenced into a
	jr z, .loop_escape				;if the bit referenced is bit 0, then jump to .loop_escape
.loop:
	srl a							;shift a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl					
	bit 0, a						;test bit 0
	jr z, R_EVENT_TILES_TILECHECK	;if it is 0 then jump to R_EVENT_TILES_TILECHECK to check the first tile override
	inc hl							;else increment hl so that the 2nd tile override will be checked
	
R_EVENT_TILES_TILECHECK:
	inc hl							;increment hl so that it points to the tile override
	ld a, [hl]						
	or a
	jr z, R_EVENT_TILES_INC_INIT		;if the tile override = 0, then jump to R_EVENT_TILES_INC_INIT
	pop de
	pop bc 
	pop hl
	ld [de], a						;else load the event tile into RAM in place of the background tile
	jr R_EVENT_TILES_INC

R_EVENT_TILES_INC_INIT:	
	pop de
	pop bc
	pop hl
	
R_EVENT_TILES_INC:
	push de
	ld a, [CURR_MAP_WIDTH]		;increment hl by map width so that it points to the tile on the next row down
	ld e, a
	ld d, 0
	add hl, de
	pop de
								;increment the pointers
	inc de
	dec c						;decrement the counter
	jr nz, R_EVENT_TILES_LOOP	;if the counter != 0, then jump to R_EVENT_TILES_LOOP
	
	ld hl, _SCRN0				;we want hl to point to the first point to output tiles,
	ld a, [rSCX]				;so we want hl to contain _SCRN0 + rSCX/8 + 32(rSCY/8)
	srl a
	srl a
	srl a						;3 right shifts is equivalent to dividing by 8
	ld d, 0
	ld e, a
	add hl, de					;hl now contains _SCRN0 + rSCX/8
	
	ld a, [rSCY]
	ld d, 0
	ld e, a
	
	srl e
	srl e
	srl e						;3 right shifts to divide by 8
	sla e						
	rl d						;rl d rotates d left through the carry bit, so sla e and rl d is equivalent to a left shift for de
	sla e							
	rl d
	sla e
	rl d
	sla e
	rl d
	sla e
	rl d						;5 left shifts to multiply by 32
	add hl, de
	
	ld de, 20
	add hl, de
	
	push hl						
	ld a, [rSCX]				
	srl a
	srl a
	srl a						
	ld d, 0
	ld e, a
	
	ld a, d
	cpl
	ld d, a
	ld a, e
	cpl
	ld e, a
	inc de
	add hl, de			;subtracts scrollX/8 from hl so that it contains _SCRN0 + 32(ScrollY/8) + 20
	
	ld de, SUBTRACT_20 	;subtracts 20 so hl contains _SCRN0 + 32(ScrollY/8)
	add hl, de
	
	ld de, 31			;adds 31 so that hl contains _SCRN0 + 32(ScrollY/8) + 31, which is the final tile for the row which output should start on
	add hl, de
	
	ld d, h
	ld e, l
	pop hl
	
	
	ld a, d
	cp h				;if the carry flag is set then h > d, so hl > de so hl does not point to the correct line  
	jr c, R_HL_DEC		;so we need to jump to R_HL_DEC so that hl does point to the correct line
	ld a, e
	cp l							
	jr nc, R_EVENT_TILES_OUT_INIT	;if e < l, then jump to R_EVENT_TILES_OUT_INIT
	jr z, R_EVENT_TILES_OUT_INIT	;if e = l, then jump to R_EVENT_TILES_OUT_INIT
									
R_HL_DEC:						
	ld de, SUBTRACT_32
	add hl, de
	
R_EVENT_TILES_OUT_INIT:
	ld b, 18
	ld de, NEW_TILES
	call WAIT_VBLANK		;make sure we are in vblank so that we can output the tiles
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [de]					;load a tile into a
	ld [hl], a					;and output it
	
	inc de
	push de
	ld de, 32					
	add hl, de					;increment hl by 32 so that it points to the row below
	pop de
	
	ld a, h
	cp $9C						
	jr c, .loop_dec				;if there is a carry, then a < $9C so hl <= $9BFF
	
	push de
	ld de, SUBTRACT_1024
	add hl, de
	pop de
	
.loop_dec	
	dec b
	jr nz, .loop				;if the counter != 0, then jump to .loop
	
	ld a, [rSCX]
	add 8
	ld [rSCX], a				;ScrollX= ScrollX + 8
	ret

	
MAIN_EVENT::
	ld a, [CURR_MAP_EVENTMP_ADR]		;load into hl the pointer to the event map
	ld h, a
	ld a, [CURR_MAP_EVENTMP_ADR+1]
	ld l, a
	
	ld a, [MAP_X]
	add PLAYER_X-1
	ld d, 0
	ld e, a
	add hl, de							;add to hl Map_X + PLAYER_X -1
	
	ld a, [MAP_Y]
	add PLAYER_Y-1
	ld e, a
	ld b, 8
	ld a, [CURR_MAP_WIDTH]
	ld c, a
	push hl
	ld hl, 0
	call Multiply
	ld d, h
	ld e, l
	pop hl
	add hl, de							;add to hl MAP_WIDTH(Map_Y + PLAYER_Y - 1)
	
	ld a, [hl]
	or a								
	jr z, MAIN_EVENT_END				;if the event tile = 0, then jump to MAIN_EVENT_END
	
	ld b, 8
	dec a
	ld c, a
	ld hl, 0
	ld d, 0
	ld a, EVENT_LENGTH
	ld e, a
	call Multiply
	ld d, h
	ld e, l
	ld a, [CURR_MAP_EVENTS_ADR]
	ld h, a
	ld a, [CURR_MAP_EVENTS_ADR+1]
	ld l, a
	add hl, de						;adds EVENT_LENGTH(EVENT_NO-1) to hl, so that it points to the start of the event referenced
	
	ld a, [hl]
	or a
	jr z, MAIN_EVENT_RUN
	
	
	ld b, a								;loads a into b so that the value can be loaded back into a later						
	srl a								;shifts a right 3 times so that the bit reference is no longer part of a
	srl a
	srl a
	push hl								;pushes hl so that the current value is preserved
	ld hl, EVENT_PERMANENCE				;loads into hl the memory region used for event states
	ld d, 0
	ld e, a
	add hl, de							;adds the memory offset to hl
	ld a, b								
	and %00000111						;only bits used to reference a bit in memory can be set
	ld c, a								
	ld a, [hl]							;load the byte containing the bit referenced
	jr z, .loop_escape
.loop:
	srl a								;shifts a until the bit referenced is bit 0
	dec c
	jr nz, .loop
.loop_escape:
	pop hl
	bit 0, a							;if bit 0 = 1, then the event has occurred
	jr nz, MAIN_EVENT_END				;so the program jumps to MAIN_EVENT_END
	
	
MAIN_EVENT_RUN::
	inc hl
	inc hl
	inc hl							;increment hl by 3 so that it points to the event code
	push hl							
	ret								;ret jumps to the address on the stack, so this jumps to the code for the event
	
MAIN_EVENT_END::					;all events jump back here after they are done
	ret

;code taken from template at https://github.com/exezin/gb-template/blob/master/src/bank0.asm 	
READ_JOYPAD:
	ld  a,%00100000  ;select dpad
	ld  [rP1],a
	ld  a,[rP1]		 ;takes a few cycles to get accurate reading
	ld  a,[rP1]
	ld  a,[rP1]
	ld  a,[rP1]
	cpl 			 ;complement a
	and %00001111    ;select dpad buttons
	swap a
	ld  b,a

	ld  a,%00010000  ;select other buttons
	ld  [rP1],a  
	ld  a,[rP1]
	ld  a,[rP1]
	ld  a,[rP1]
	ld  a,[rP1]
	cpl
	and %00001111
	or  b
					 ;lower nibble is other
	ld  b,a
	ld  a,[joypad_down]
	cpl
	and b
	ld  [joypad_pressed],a
					 ;upper nibble is dpad
	ld  a,b
	ld  [joypad_down],a
	ret

JOY_RIGHT:
	and %00010000
	cp  %00010000
	jp  nz,JOY_FALSE
	ld  a,$01
	ret
JOY_LEFT:
	and %00100000
	cp  %00100000
	jp  nz,JOY_FALSE
	ld  a,$01
	ret
JOY_UP:
	and %01000000
	cp  %01000000
	jp  nz,JOY_FALSE
	ld a, $01
	ret
JOY_DOWN:
	and %10000000
	cp  %10000000
	jp  nz,JOY_FALSE
	ld a, $01
	ret
JOY_A:
	and %00000001
	cp  %00000001
	jp  nz,JOY_FALSE
	ld  a,$01
	ret
JOY_B:
	and %00000010
	cp  %00000010
	jp  nz,JOY_FALSE
	ld  a,$01
	ret
JOY_SELECT:
	and %00000100
	cp  %00000100
	jp  nz,JOY_FALSE
	ld  a,$01
	ret
JOY_START:
	and %00001000
	cp  %00001000
	jp  nz,JOY_FALSE
	ld  a,$01
	ret
JOY_FALSE:
	ld  a,$00
	ret

RANDOM_NUM::				;generates a random number between 0 and the value in a-1
	ld b, a					;loads the upper limit into b so it can be used as a divisor
	ld a, [RANDOM_NO_SEED]	;loads our seed into a so it can be divided by b
	
	call DIVIDE				;divides a by b
	add b					;as DIVIDE returns when a-b causes an overflow, adding b sets a to be in range
							;as if a-b causes an overflow, then a < b so it is in range
	ld [RANDOM_NO], a		
	call RANDOMISE			;Resets the seed so that if RANDOM_NUM is called several times in a row, it doesn't return the same value
	ret

RANDOMISE::
	ld a, [rTIMA]
	ld b, a						;Loads the value of the Timer Counter into b
	
	ld a, [rDIV]				;Loads the value of the Divider into a
	
	xor b						;Xors a and b
	ld [RANDOM_NO_SEED], a		;Stores the result in memory
	
	xor a						;a xor a = 0, so it sets a to 0
	ld [rTIMA], a				;Resets the Timer Counter
	ret

WINDOW_LOAD::			;loads the window tiles into memory
	ld a, [hl+]			;loads the byte at [hl] into a and increments hl
	ld [de], a			;loads the byte in a into [de], so the byte hl was pointing to has been copied into [de]
	inc de				
	dec bc
	ld a, b	
	or c				;or c as for any value of b and any value of c, b or c will only be 0 if both b and c are 0
	jr nz, WINDOW_LOAD	
	ret
								
FRAME_LOAD::					;loads the empty frame into the window
	ld a, [hl+]
	ld [de], a
	inc de
	ld a, e						
	and 20						 			
	cp 20						;Checks if de is pointing to the 1st non visible tile for that row. if it is
	call z, FRAME_LOAD_RESET	;it calls FRAME_LOAD_RESET which increments de by 12
	dec bc
	ld a, b
	or c
	jr nz, FRAME_LOAD
	ret

FRAME_LOAD_RESET:				;as 12 tiles of the window are not visible, this function shifts de along by 12
	push hl						
	ld hl, 12					
	add hl, de					;hl used as the only 16 bit additions are add hl, nn and add sp, nn
	ld d, h						
	ld e, l
	pop hl						;original hl value is kept and de has been incremented by 12
	ret

ACTIVE_FRAME_LOAD::	;loads the empty frame into the window
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, [hl+]
	ld [de], a
	inc de
	ld a, e						
	and 20						 			
	cp 20						;Checks if de is pointing to the 1st non visible tile for that row. if it is
	call z, ACTIVE_FRAME_LOAD_RESET	;it calls FRAME_LOAD_RESET which increments de by 12
	dec bc
	ld a, b
	or c
	jr nz, ACTIVE_FRAME_LOAD
	ret

ACTIVE_FRAME_LOAD_RESET:			;as 12 tiles of the window are not visible, this function shifts de along by 12
	push hl						
	ld hl, 12					
	add hl, de					;hl used as the only 16 bit additions are add hl, nn and add sp, nn
	ld d, h						
	ld e, l
	pop hl						;original hl value is kept and de has been incremented by 12
	ret

PORTRAIT_FRAME_CLEAR::
	push af						;makes sure that the values in af and bc are retained	
	push bc						;as both af and bc are used
								;hl is not retained as this function is only called at a point where hl's value doesn't matter
								
	ld hl, $9C24				;first space of the frame to empty
	ld b, 15*3					;no of tiles to clear
	call WAIT_VBLANK		;make sure we are in vblank so that data can be written to the screen
	
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, $81						;loads the number for space into a
	ld [hl+], a						;loads the space into the frame
	ld a, l							
	and $13
	cp $13							;if l and $13 = $13, then hl is pointing to the end of the frame,
	call z, PORTRAIT_FRAME_INC		;so hl must be incremented to point to the start of the next row
	dec b
	jr nz, .loop					
	
	pop bc
	pop af
	ret
	
PORTRAIT_FRAME_INC::
	push de
	ld de, 17
	add hl, de
	pop de
	ret


FRAME_CLEAR::
	push af						;makes sure that the values in af and bc are retained	
	push bc						;as both af and bc are used
								;hl is not retained as this function is only called at a point where hl's value doesn't matter
								
	ld hl, $9C21				;first space of the frame to empty
	ld b, 18*3					;no of tiles to clear
	call WAIT_VBLANK		;make sure we are in vblank so that data can be written to the screen
	
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	
	ld a, $81						;loads the number for space into a
	ld [hl+], a						;loads the space into the frame
	ld a, l							
	and $13
	cp $13							;if l and $13 = $13, then hl is pointing to the end of the frame,
	call z, MESSAGE_HL_14_INC		;so hl must be incremented to point to the start of the next row
	dec b
	jr nz, .loop					
	
	pop bc
	pop af
	ret

RAM_MESSAGE_CLEAR::
	xor a
	ld b, 54
	ld hl, RAM_MESSAGE
.loop:					;Clears RAM_MESSAGE so that when inserting values into it, any data that was left in it from last use does not interfere
	ld [hl+], a
	dec b
	jr nz, .loop
	ret

PORTRAIT_LOAD::			;loads the portait pointed to by hl
	ld de, $8E00
	ld b, 9*16
.loop:
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, .loop
	ret
	
ACTIVE_PORTRAIT_LOAD::	;loads the portait pointed to by hl
	ld de, $8E00
	ld b, 9*16
.loop:
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK

	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, .loop
	ret
	
MESSAGE_OUTPUT::
	call FRAME_CLEAR				;clears the frame
	
	ld a, [rLCDC]
	or LCDCF_WINON					;turns the window on
	ld [rLCDC], a
	
	ld c, 0							;c is used as a counter for how many characters are in the message
	push de							
.loop:								;counts how many characters are in the message
	ld a, [de]
	inc de
	inc c
	cp $80							;checks for the null terminator
	jr nz, .loop
	
	dec c							;as the above loop includes the null terminator, c must be decremented for the actual length of the message
	pop de							
	ld a, c							
	cp 55							;carry flag is set if a < 55
	jp nc, MESSAGE_LONG_OUTPUT		;so if a > 54 (message limit), then the program jumps to MESSAGE_LONG_OUTPUT

MESSAGE_SHORT_OUTPUT:
	ld hl, $9C21					
	ld c, 0							;c is used as a counter for the no of characters output per line
	call WAIT_VBLANK			;as we are writing to vram, we need to be in vblank
	ld a, [de]						
.loop:
	push bc
	call DELAY
	pop bc
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	ld a, [de]
	ld [hl+], a						;load tile number to vram
	inc de							
	inc c							
	ld a, c
	cp 18							;if 18 tiles have been output,
	call z, MESSAGE_HL_14_INC		;add 14 to hl so that it points to the start of the next line
	ld a, [de]						;load the next tile number
	cp $80							;if the tile number isn't the null value
	jr nz, .loop					;then jump to the start of the loop
	ret

MESSAGE_HL_14_INC:				;increments hl by 14 and resets c to 0
	push de
	ld de, 14
	add hl, de						
	pop de
	ld c, 0
	call WAIT_VBLANK			;make sure we are in vblank for the next row
	ret
	
MESSAGE_LONG_OUTPUT::
	push de				
	ld hl, 54
	add hl, de
	ld d, h
	ld e, l
.loop:							;this loop decrements de until it finds the end of a word or sentence
	ld a, [de]
	cp $81						;if the tile is a space
	jr z, .loop_escape			;then jump to .loop_escape
	cp $82						;if the tile is an exclamation mark
	jr z, .loop_escape			;then ...
	cp $8F						;if the tile is a fullstop
	jr z, .loop_escape			;then ...
	cp $A0						;if the tile is a question mark
	jr z, .loop_escape			;then ...
	dec de						
	jr .loop				
.loop_escape:
	ld a, d 
	ld [MESSAGE_END_D], a
	ld a, e
	inc a						;inc a so that the punctuation is included in the message
	ld [MESSAGE_END_E], a		;the end of the message to be output it stored in RAM
	pop de						;and the start of the message is stored in de
	ld hl, $9C21
	ld c, 0						;c is used as a counter for the no of tiles output per line
	call WAIT_VBLANK		;make sure we are in vblank
Outputloop:
	push bc
	call DELAY
	pop bc
	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK	
	
	ld a, [de]
	ld [hl+], a
	inc de
	inc c
	ld a, c
	cp 18						;if 18 tiles have been output, then hl is incremented by 14 so that it points to the start of the next line
	call z, MESSAGE_HL_14_INC	
	
	ld a, [MESSAGE_END_D]
	cp d						;check if d is the same as the d value for the end of the message
	jr nz, Outputloop			;if not then we are not at the end of the message, so loop
	ld a, [MESSAGE_END_E]		
	cp e						;check if e is the same as the e value for the end of the message
	jr nz, Outputloop			;if not then we are not at the end of the message, so loop
	
.loop:
	push bc
	call READ_JOYPAD			;loads the state of inputs into [joypad_pressed]
	pop bc
	ld a, [joypad_pressed]
	call JOY_A					;returns 01 if a is pressed and 0 if not
	or a						;if a = 0, or a sets the zero flag
	jp nz, MESSAGE_OUTPUT		;so if the zero flag isn't set, then a has been pressed
	
	ld a, [joypad_pressed]
	call JOY_B
	or a 
	jp nz, MESSAGE_OUTPUT
	jr .loop					;neither a or b have been pressed, so the program jumps back to the start of the loop

	
PORTRAIT_MESSAGE_OUTPUT::			;essentially the same as MESSAGE_OUTPUT but with new labels and different constants
	call PORTRAIT_FRAME_CLEAR		;clears the frame
	
	ld a, [rLCDC]
	or LCDCF_WINON					;turns the window on
	ld [rLCDC], a
	
	ld c, 0							;c is used as a counter for how many characters are in the message
	push de							
.loop:								;counts how many characters are in the message
	ld a, [de]
	inc de
	inc c
	cp $80							;checks for the null terminator
	jr nz, .loop
	
	dec c							;as the above loop includes the null terminator, c must be decremented for the actual length of the message
	pop de							
	ld a, c							
	cp 46									;carry flag is set if a < 46
	jp nc, PORTRAIT_MESSAGE_LONG_OUTPUT		;so if a > 45 (message limit), then the program jumps to MESSAGE_LONG_OUTPUT

PORTRAIT_MESSAGE_SHORT_OUTPUT:
	ld hl, $9C24					
	ld c, 0							;c is used as a counter for the no of characters output per line
	call WAIT_VBLANK				;as we are writing to vram, we need to be in vblank						
.loop:
	push bc
	call DELAY
	pop bc
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK
	ld a, [de]
	ld [hl+], a						;load tile number to vram
	inc de							
	inc c							
	ld a, c
	cp 15									;if 15 tiles have been output,
	call z, PORTRAIT_MESSAGE_HL_17_INC		;add 17 to hl so that it points to the start of the next line
	ld a, [de]								;load the next tile number
	cp $80									;if the tile number isn't the null value
	jr nz, .loop							;then jump to the start of the loop
	ret

PORTRAIT_MESSAGE_HL_17_INC:				;increments hl by 17 and resets c to 0
	push de
	ld de, 17
	add hl, de						
	pop de
	ld c, 0
	call WAIT_VBLANK			;make sure we are in vblank for the next row
	ret
	
PORTRAIT_MESSAGE_LONG_OUTPUT::
	push de				
	ld hl, 45
	add hl, de
	ld d, h
	ld e, l
.loop:							;this loop decrements de until it finds the end of a word or sentence
	ld a, [de]
	cp $81						;if the tile is a space
	jr z, .loop_escape			;then jump to .loop_escape
	cp $82						;if the tile is an exclamation mark
	jr z, .loop_escape			;then ...
	cp $8F						;if the tile is a fullstop
	jr z, .loop_escape			;then ...
	cp $A0						;if the tile is a question mark
	jr z, .loop_escape			;then ...
	dec de						
	jr .loop				
.loop_escape:
	ld a, d 
	ld [MESSAGE_END_D], a
	ld a, e
	ld [MESSAGE_END_E], a		;the end of the message to be output it stored in RAM
	pop de						;and the start of the message is stored in de
	ld hl, $9C24
	ld c, 0						;c is used as a counter for the no of tiles output per line
	call WAIT_VBLANK		;make sure we are in vblank
PORTRAIT_Outputloop:
	push bc
	call DELAY
	pop bc
	
	ld a, [rLY]
	cp 153
	call z, WAIT_VBLANK
	cp 144
	call c, WAIT_VBLANK	
	
	ld a, [de]
	ld [hl+], a
	inc de
	inc c
	ld a, c
	cp 15						;if 15 tiles have been output, then hl is incremented by 17 so that it points to the start of the next line
	call z, PORTRAIT_MESSAGE_HL_17_INC	
	
	ld a, [MESSAGE_END_D]
	cp d						;check if d is the same as the d value for the end of the message
	jr nz, PORTRAIT_Outputloop			;if not then we are not at the end of the message, so loop
	ld a, [MESSAGE_END_E]		
	cp e						;check if e is the same as the e value for the end of the message
	jr nz, PORTRAIT_Outputloop			;if not then we are not at the end of the message, so loop
	
.loop:
	push bc
	call READ_JOYPAD			;loads the state of inputs into [joypad_pressed]
	pop bc
	ld a, [joypad_pressed]
	call JOY_A					;returns 01 if a is pressed and 0 if not
	or a						;if a = 0, or a sets the zero flag
	jp nz, PORTRAIT_MESSAGE_OUTPUT		;so if the zero flag isn't set, then a has been pressed
	
	ld a, [joypad_pressed]
	call JOY_B
	or a 
	jp nz, PORTRAIT_MESSAGE_OUTPUT
	jr .loop					;neither a or b have been pressed, so the program jumps back to the start of the loop
	
;Converts a number into bcd and stores the result in memory
;Uses registers a,b and c
BcdConvert_init::
	ld b, a
	xor a					;xor a, as it is = ld a, 0 but it takes less cycles
	ld [upper_result], a	;sets the upper result to 0. This clears out the value from the last bcdConvert, incase this value doesn't use it
	ld a, b					
	
BcdConvert::
	ld b, a					;as cp can only be used with a, b is used to temporarily store the value in a
	ld a, c					
	cp 10					;if input/10 >= 10
	jp nc, BcdConvert_GTE100;jump to BcdConvert_GTE100
	ld a, b
	cp 10					;if input < 10, then it doesn't need to be converted
	jp c, BcdConvertEnd		
	
BcdConvertLoop:
	add 6					;to convert binary to bcd, you add 6 x no of times where x is input/10
	dec c					
	jp nz, BcdConvertLoop
BcdConvertEnd:
	ld [lower_result], a
	ret
	
BcdConvert_GTE100:			;as the input is eight bit, we know that the upper result can only be either 0, 1 or 2
	cp 20					;if input/10 >= 20, then input >= 200
	jp nc, BcdConvert_GTE200
	ld a, 1					;as the input is in the range 100<= input < 200, the upper result for this input must be 1
	ld [upper_result], a
	ld a, c					
	sub 10					;as the function jumps back to BcdConvert to handle the lower result, c must be subtracted by 10
	ld c, a					
	ld a, b					;b was used to store the input
	sub 100					;the input must be subtracted by 100 for handling the lower result
	jp BcdConvert
	
BcdConvert_GTE200:
	ld a, 2					;as the input is in the range 200<= input and it is eight bit so it can't be > 255, the upper result has to be 2
	ld [upper_result], a
	ld a, c
	sub 20					;as the function jumps back to BcdConvert to handle the lower result, c must be subtracted by 20
	ld c, a					
	ld a, b					;b was used to store the input
	sub 200					;the input must be subtracted by 200 for handling the lower result
	jp BcdConvert	

NEW_gbt_update::
	push af
	push bc
	push de
	push hl					;push all registers so that their values don't change after the interrupt
	
	ld a, [$4000]
	push af					;push the current bank
	ld a, BANK_SOUND
	ld [$2000], a			;and set the current bank to the bank holding music data
	
	call gbt_update			
	
	pop af					;set the bank back to what it was
	ld [$2000], a
	
	pop hl					;and get all register values back off the stack
	pop de
	pop bc
	pop af
	ret

MENU::
	ld a, [$4000]		;$4000 is the first byte of the bank, and the first byte contains the bank number
	push af				;pushes the current bank to the stack
	ld a, BANK_TILESET
	ld [$2000], a 		;changes the bank to bank 3
	
	ld a, MENU_Y
	ld [rWY], a
	ld a, MENU_X
	ld [rWX], a			;changes the window x and y to the correct values for the menu
	
	ld de, _SCRN1
	ld hl, MenuFrame
	ld bc, 20*3
	call ACTIVE_FRAME_LOAD	;loads the menu	frame	
	
	ld a, 1
	ld [CURSOR_STATE], a
	ld a, 16
	ld [CURSOR_X], a
	ld a, 144
	ld [CURSOR_Y], a
	
	ld a, [rLCDC]
	or LCDCF_WINON					;turns the window on
	ld [rLCDC], a
	
MENU_LOOP::
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	bit 1, a					;if b is being pressed
	jr nz, MENU_LOOP_ESCAPE		;then jump to MENU_LOOP_ESCAPE
	bit 3, a					;if start is being pressed
	jr nz, MENU_LOOP_ESCAPE		;then jump to MENU_LOOP_ESCAPE
	
	bit 5, a					;if left is being pressed
	jr nz, MENU_LEFT			;then jump to MENU_LEFT
	bit 4, a					;if right is being pressed
	jr nz, MENU_RIGHT			;then jump to MENU_RIGHT
	
	bit 0, a					;if a is being pressed
	jr nz, MENU_A				;jump to MENU_A
	
	jr MENU_LOOP
	
MENU_A:
	ld a, [CURSOR_STATE]
	cp 1						;if cursor state = 1
	jp z, MENU_ITEMS			;then jump to MENU_ITEMS
	cp 2						;if cursor state = 2
	jp z, MENU_PARTY			;then jump to MENU_PARTY
	jp MENU_SAVE				;if cursor state != 1 or 2 then it must equal 3, so jump to MENU_SAVE
MENU_LEFT:
	ld a, [CURSOR_STATE]
	cp 1						;if cursor state = 1
	jr z, MENU_LOOP				;then jump to MENU_LOOP
	
	dec a
	ld [CURSOR_STATE], a
	jr MENU_CURSOR_UPDATE

MENU_RIGHT:
	ld a, [CURSOR_STATE]
	cp 3						;if cursor state = 1
	jr z, MENU_LOOP				;then jump to MENU_LOOP
	
	inc a
	ld [CURSOR_STATE], a
	jr MENU_CURSOR_UPDATE 
	
MENU_LOOP_ESCAPE:
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT
	jp z, MENU_ITEMS_COMBAT_USE_REM2

	call WAIT_VBLANK
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a				;turn the window off
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a			;move the cursor to 0,0 so that it can't be seen
	
	ld a, MESSAGE_Y				;set the window x,y back to the x,y for message output
	ld [rWY], a
	ld a, MESSAGE_X
	ld [rWX], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD		;load the portrait window frame
	
	call WAIT_VBLANK
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a
	
	pop af
	ld [$2000], a				;set the memory bank back to what it was before
	jp Main

	

MENU_CURSOR_UPDATE:	
	cp 1						
	jr nz, MENU_CURSOR_UPDATE2	;if the cursor state != 1 then jump to MENU_CURSOR_UPDATE2
	ld a, 16					
	ld [CURSOR_X], a			;cursor y doesn't change and cursor x is set to 16
	jp MENU_LOOP
MENU_CURSOR_UPDATE2:
	cp 2
	jr nz, MENU_CURSOR_UPDATE3	;if the cursor state != 2 then jump to MENU_CURSOR_UPDATE3
	ld a, 64
	ld [CURSOR_X], a
	jp MENU_LOOP
MENU_CURSOR_UPDATE3:
	ld a, 112					;cursor state can only be 1, 2 or 3 for the menu, so no checks are needed here
	ld [CURSOR_X], a
	jp MENU_LOOP
	
MENU_ITEMS::
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a				;turn the window off
	
	xor a
	ld [rWY], a					;set the window y to 0 so that the window takes up the whole screen
	ld [$FE00], a				
	ld [$FE01], a				;set the player sprite x and y to 0 so that they can't be seen
	ld [CURSOR_X], a
	ld [CURSOR_Y], a			;set the cursor x and y to 0 so that it temporarily can't be seen
	
	ld de, ITEMCODE_DISP
	ld c, 16*2
	xor a						
.loop:							;clears ITEMCODE_DISP
	ld [de], a
	inc de
	dec c
	jr nz, .loop
	
	ld hl, INVENTORY
	ld c, 16
	ld b, 0						;as the loop decrements c at the start, for it to run 255 times, c must start as 0 as 0-1 = 255 with 8 bit registers
	ld de, ITEMCODE_DISP
ITEMCODE_LOOP_INIT:
	push bc						;When the program reaches this label, the large window needs to be loaded, 
	push de						;but the values in bc, de and hl need to be kept so they are all pushed to the stack
	push hl
	
	ld de, _SCRN1
	ld hl, LargeWindowFrame
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD		;load the large window frame
	
	ld a, [rLCDC]
	or LCDCF_WINON					;turns the window on
	ld [rLCDC], a
	
	pop hl
	pop de
	pop bc
	
ITEMCODE_LOOP:					;This loop copies up to 16 item codes from inventory into ITEMCODE_DISP so that the items can be displayed
	ld a, [hl]
	inc hl
	inc hl
	dec b						;decrement our bounds counter
	jr z, ITEMCODE_LOOP_ESCAPE	;if it equals zero then we have reached the end of inventory, so escape the loop
	or a						;if a = 0 then we are not pointing at an item code
	jr z, ITEMCODE_LOOP			;so go back to the start of the loop
	ld a, c						
	or a						;if c = 0, then we have 16 item codes copied, so we can leave the loop
	jr z, ITEMCODE_LOOP_ESCAPE	
	cp 16						;if c != 16
	jr nz, ITEMCODE_LOOP_INC	;then jump to ITEMCODE_LOOP_INC
	dec hl						
	dec hl
	ld a, h						;else load the address of the first non zero item code into memory
	ld [TOP_ITEMCODE], a
	ld a, l
	ld [TOP_ITEMCODE+1], a
	inc hl
	inc hl
ITEMCODE_LOOP_INC
	dec hl
	dec hl						;decrement so that hl points back to the item code
	ld a, [hl+]					
	dec c						
	ld [de], a					;output the item code into ITEMCODE_DISP so that we can display the item name later
	inc de
	ld a, [hl+]					;load the quantity of the item as well
	ld [de], a					;and output it into ITEMCODE_DISP so that we can display the quantity as well
	inc de
	jr ITEMCODE_LOOP			
	
ITEMCODE_LOOP_ESCAPE:
	ld de, ITEMCODE_DISP		
	ld b, 16
	ld c, 0
.loop:							;this loop counts how many item codes have been copied to ITEMCODE_DISP
	ld a, [de]
	or a						;if a = 0
	jr z, .loop_escape			;then jump to .loop_escape
	inc c						;else increment c, which stores the no of item codes
	inc de						;increment de so that it points to the next item code
	inc de						
	dec b						;if b = 0 then we have counted 16 item codes
	jr nz, .loop				;so if b != 0, then we haven't, so jump to .loop
	
.loop_escape:
	ld a, BANK_ITEMDB			;changes the current bank so that we can get item names from the item database 
	ld [$2000], a				
	ld hl, $9C22				;load into hl the first point on the window to output
	ld de, ITEMCODE_DISP		
	ld a, [de]
	or a						;if the first item in ITEMCODE_DISP = 0 then there are no items to display
	jp z, ITEM_OUTPUT_DONE		;so jump to ITEM_OUTPUT_DONE
	
ITEM_OUTPUT_LOOP:
	push bc						;push bc, de and hl so that they can be used here and also have their values retained
	push de
	push hl
	ld hl, ITEM_DB				;we want hl to point to the item no of our current item in the item db
	ld a, [de]					;so we want hl to contain ITEM_DB + ITEM_LENGTH*(ITEM_CODE-1)
	dec a
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ITEM_LENGTH
	call Multiply
	inc hl						;increment hl so that it points to the item name
	
	
	ld de, CUR_ITEM_NAME
	ld c, 10
name_loop:						;copies the item name into memory so that we can output it easier
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, name_loop
	
	ld de, CUR_ITEM_NAME
	pop hl						;pop hl as hl contains the address to output to
	ld c, 10
OUTPUT_LOOP:
	ld a, [rLY]				
	cp 153						;if the current scanline = 153
	call z, WAIT_VBLANK			;then we are not in vblank, so call WAIT_VBLANK
	cp 144						;if the current scanline < 144
	call c, WAIT_VBLANK			;then we are not in vblank, so call WAIT_VBLANK
	ld a, [de]					
	ld [hl+], a
	inc de
	dec c
	jr nz, OUTPUT_LOOP 
	
	pop de						;pop de as de points to the item code in ITEMCODE_DISP
	inc de						;increment so that it points to the quantity of that item
	ld a, [de]					
	ld [input], a				;load the quantity into input so that it can be converted to bcd
	ld bc, $0A00
	call DIVIDE					;divide a by 10 and store the result in c. This is necessary for the bcd function to work
	ld a, [input]				;reload the input into a 
	call BcdConvert_init		;and call BcdConvert_init
	
	ld a, [upper_result]		
	and $0F						 
	add $91						;add $91 as that is the tile no for 0
	ld [CUR_ITEM_NAME], a		;reuse CUR_ITEM_NAME here to store the tile no for the quantity as we have already output the name
	ld a, [lower_result]		
	and $F0						;and $F0 that the lower nibble containing the third tile no isn't considered here
	swap a						;swap the upper and lower nibble so that adding $91 will set it to the correct tile no
	add $91
	ld [CUR_ITEM_NAME+1], a
	ld a, [lower_result]		
	and $0F						;and $0F so that the upper nibble containing the second tile no isn't considered here
	add $91
	ld [CUR_ITEM_NAME+2], a
	
	inc hl						;increment hl by 3 so that it points to the correct point on screen to output the quantity
	inc hl
	inc hl
	
	call WAIT_VBLANK			;wait for vblank so that we can output the tiles
	ld a, [CUR_ITEM_NAME]
	ld [hl+], a
	ld a, [CUR_ITEM_NAME+1]
	ld [hl+], a
	ld a, [CUR_ITEM_NAME+2]
	ld [hl+], a
	
	pop bc						;pop bc as it contains our loop counter
	dec c						;decrement the loop counter
								;no comparison is needed here as if it is zero then the zero flag will be set
								;the code beneath to do with hl and will not change the zero flag as they are 16 bit operations
	push de					
	ld de, 16					
	add hl, de					;increment hl by 16 so that it points to the first tile to output on the next row
	pop de
	inc de						;increment de so that it points to the next item code
	jp nz, ITEM_OUTPUT_LOOP 	;if c != 0, then jump to ITEM_OUTPUT_LOOP
	
ITEM_OUTPUT_DONE:
	ld a, BANK_TILESET			;set the bank back to bank 3 
	ld [$2000], a

	ld hl, INVENTORY
	ld de, INVENTORY+510
	ld b, 0
.loop:							;this loop counts how many items are in the inventory
	ld a, h
	cp d
	jr nz, .loop_main			;if h != d, then jump to .loop_main
	ld a, l
	cp e
	jr nz, .loop_main			;if l != e, then jump to .loop_main
	jr .loop_escape				;else hl points to the end of inventory, so jump to .loop_escape
.loop_main:
	ld a, [hl]					;load into a the item code at hl
	inc hl						;increment hl so that it points to the next item code
	inc hl
	or a						;if the item code = 0, then jump to .loop
	jr z, .loop
	inc b						;else increment b and then jump to .loop
	jr .loop

.loop_escape:
	ld de, ITEMCODE_DISP
	ld a, [de]
	or a							;if the first item in ITEMCODE_DISP != 0, then jump to ITEMS_BEFORE_CHECK
	jr nz, ITEMS_BEFORE_CHECK	
	ld a, b
	or a							;if the number of items in inventory = 0, then there are no items before or after
	jr z, MENU_ITEMS_LOOP_INIT 		;so jump to MENU_ITEMS_LOOP_INIT
	cp 17							;else if the number of items is < 17,
	jr c, ITEMS_BEFORE				;then jump to ITEMS_BEFORE
	
	
ITEMS_BEFORE_CHECK:					;ITEM_BEFORE_CHECK, ITEMS_BEFORE_CHECK2, ITEM_AFTER_CHECK, ITEM_AFTER_CHECK2 and ITEM_AFTER_CHECK3
									;were rewritten after INVENTORY_REMOVE was updated,
									;so they are the only bits of code that don't expect empty spaces between item codes
	ld a, b
	cp 17							;if the number of items it < 17,
	jr c, MENU_ITEMS_LOOP_INIT		;then there are no items before or after the current top item code so jump to MENU_ITEMS_LOOP_INIT
	
	ld de, INVENTORY
	ld a, [TOP_ITEMCODE]
	cp d							;if TOP_ITEMCODE = d, then the upper half of TOP_ITEMCODE is in range to be at the top
	jr z, ITEMS_BEFORE_CHECK2		;so to check if it is jump to ITEMS_BEFORE_CHECK2
	jr ITEMS_BEFORE					;else, we are not at the top so jump to ITEMS_BEFORE
ITEMS_BEFORE_CHECK2:
	ld a, [TOP_ITEMCODE+1]		
	cp e							;if TOP_ITEMCODE+1 = e, then we are at the top of the INVENTORY,
	jr z, ITEMS_AFTER_CHECK			;so jump to ITEMS_AFTER_CHECK
	
ITEMS_BEFORE:	
	ld hl, $9E21
	call WAIT_VBLANK				;wait for vblank so that we can load the tile into vram
	ld a, $F3						;load the tile number for <- into a
	ld [hl], a						;and output it at the bottom of the window
	
ITEMS_AFTER_CHECK:					;ITEM_BEFORE_CHECK, ITEMS_BEFORE_CHECK2, ITEM_AFTER_CHECK, ITEM_AFTER_CHECK2 and ITEM_AFTER_CHECK3
									;were rewritten after INVENTORY_REMOVE was updated,
									;so they are the only bits of code that don't expect empty spaces between item codes
	ld a, [TOP_ITEMCODE]
	ld h, a
	ld a, [TOP_ITEMCODE+1]
	ld l, a
	ld de, 32
	add hl, de
	ld a, [hl]						
	or a							;if [TOP_ITEMCODE + 32] = 0, then there are no items left to display
	jr z, MENU_ITEMS_LOOP_INIT		;so jump to MENU_ITEMS_LOOP_INIT
	ld de, INVENTORY+480+32			;load into de the highest value TOP_ITEMCODE can have
	ld a, h	
	cp d							;if h = d
	jr z, ITEMS_AFTER_CHECK2		;then jump to ITEMS_AFTER_CHECK2 so we can check if l = e
	jr ITEM_AFTER_CHECK3			;else jump to ITEM_AFTER_CHECK3
ITEMS_AFTER_CHECK2:
	ld a, l
	cp e							;if l = e
	jr z, MENU_ITEMS_LOOP_INIT		;then jump to MENU_ITEMS_LOOP_INIT
	
ITEM_AFTER_CHECK3:
	ld a, [$9C22]					
	cp $81							;if the first point to output text has the tile number for space
	jr z, MENU_ITEMS_LOOP_INIT		;then there cannot be any items after, so jump to ITEMS_AFTER
	
ITEMS_AFTER:
	ld hl, $9E32					;load into hl the point to output the arrow
	call WAIT_VBLANK				;wait for vblank so that we can write to vram
	ld a, $F4						;tile number for ->
	ld [hl], a
	
MENU_ITEMS_LOOP_INIT:
	call WAIT_VBLANK				;wait for vblank so that we can access the cursor's x position
	ld a, [CURSOR_X]
	or a							;if the cursor x != 0,
	jr nz, MENU_ITEMS_LOOP			;then jump to MENU_ITEMS_LOOP
	ld a, 16						;else set the cursor x to 16 and the y to 24
	ld [CURSOR_X], a				
	ld a, 24
	ld [CURSOR_Y], a
MENU_ITEMS_LOOP:
	halt							;stops the program until vblank occurs
	call READ_JOYPAD				;gets the state of the buttons pressed and stores them in memory
	ld a, [joypad_pressed]			
	
	bit 0, a						;if a is being pressed
	jr nz, MENU_ITEMS_USE			;then jump to MENU_ITEMS_USE
	
	bit 5, a						;if left is being pressed
	jp nz, MENU_ITEMS_PAGE_UP		;then jump to MENU_ITEMS_PAGE_UP
	bit 4, a						;if right is being pressed
	jp nz, MENU_ITEMS_PAGE_DOWN		;then jump to MENU_ITEMS_PAGE_DOWN
	
	bit 1, a						;if b is being pressed
	jp nz, MENU_LOOP_ESCAPE			;then jump to MENU_LOOP_ESCAPE
	bit 3, a						;if start is being pressed
	jp nz, MENU_LOOP_ESCAPE			;then jump to MENU_LOOP_ESCAPE
	
	bit 6, a						;if up is being pressed
	jp nz, MENU_ITEMS_CURSOR_UP		;then jump to MENU_ITEMS_CURSOR_UP
	bit 7, a						;if down is being pressed
	jp nz, MENU_ITEMS_CURSOR_DOWN	;hen jump to MENU_ITEMS_CURSOR_DOWN
	
	jr MENU_ITEMS_LOOP

MENU_ITEMS_USE::
	ld a, BANK_ITEMDB				;change the memory bank so that we can access the item data
	ld [$2000], a
									
	ld a, [CURSOR_Y]				
	sub 24							;sub 24 as y = 24 is the smallest value the y can take in the menu
	ld c, a
	ld a, 8
	ld b, a
	ld a, c
	ld c, 0
	call DIVIDE						;divides the (cursor y -24) by 8
	
	ld a, c							;loads the result of the division into a
	sla a							;left shift is the same as a * 2
	ld hl, ITEMCODE_DISP
	ld d, 0
	ld e, a
	add hl, de						;hl points to the item code in ITEMCODE_DISP that the cursor is pointing to on screen
	
	ld a, [hl]
	push af
	or a							;if the cursor is pointing to 0
	jp z, MENU_ITEMS_EMPTY			;then we don't want to run code for it, so jump to MENU_ITEMS_EMPTY
	dec a							;decrement the item code as there is no item 0
	ld d, 0
	ld e, a
	ld hl, ITEM_DB
	ld b, 8
	ld c, ITEM_LENGTH
	call Multiply					;multiplies the item length by the (item code-1)
	ld de, 11
	add hl, de						;add 11 so that hl points to the function call for the event
	push hl							;pushes that function address to the stack
	ret								;returns to that address
MENU_ITEMS_USE_REM::				;USE_RETURN jumps back to this point if we are in the overworld
	pop af							;get the item code back into a
	call INVENTORY_REMOVE			;and remove 1 of that item from the inventory
	ld a, BANK_TILESET				;set the bank back to bank 3
	ld [$2000], a
	jr MENU_JUMP_TO_ITEMCODE_LOOP

MENU_ITEMS_COMBAT_USE_REM::
	pop af							;get the item code back into a
	call INVENTORY_REMOVE			;and remove the item from the inventory	
	call WAIT_VBLANK				;As we want to move the cursor and we don't know if we are in vblank, wait for vblank
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a			;move the cursor to 0,0 so that it can't be seen
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a				;turn the window off
	
	ld a, MESSAGE_Y				;set the window x,y back to the x,y for message output
	ld [rWY], a
	ld a, MESSAGE_X
	ld [rWX], a
	
	call COMBAT_ENEMY_SHOW
	
	ld a, BANK_TILESET			
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD		;load the window frame
	
	call COMBAT_ENEMY_ATTACK_GENERATE	;Generates an attack for the enemy
	call COMBAT_ENEMY_TURN				;And then takes the enemy turn
	inc sp
	inc sp
	jp COMBAT_MAIN_INIT_RET

MENU_ITEMS_COMBAT_USE_REM2::	
	call WAIT_VBLANK				;As we want to move the cursor and we don't know if we are in vblank, wait for vblank
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a			;move the cursor to 0,0 so that it can't be seen
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a				;turn the window off
	
	ld a, MESSAGE_Y				;set the window x,y back to the x,y for message output
	ld [rWY], a
	ld a, MESSAGE_X
	ld [rWX], a
	
	ld a, BANK_TILESET			;set the current bank to bank 3 so that we can get the frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD		;load the window frame
	
	call WAIT_VBLANK			;as it is unlikely we are still in VBLANK, wait so that we can properly display the enemy
	call COMBAT_ENEMY_SHOW
	jp COMBAT_MAIN_INIT_RET
	
MENU_JUMP_TO_ITEMCODE_LOOP:			;if the program has reached this label, then something in the menu has changed
									;so this function prepares the registers and TOP_ITEMCODE so that we can redraw the screen correctly 
	ld de, ITEMCODE_DISP
	ld c, 16*2
	xor a
.loop:								;clears ITEMCODE_DISP
	ld [de], a
	inc de
	dec c
	jr nz, .loop
	
	ld a, [TOP_ITEMCODE]
	ld h, a
	ld a, [TOP_ITEMCODE+1]
	ld l, a
	ld de, INVENTORY
	ld a, h							
	cp d							;if d != h
	jr nz, MENU_ITEMS_RESET_INIT	;then jump to MENU_ITEMS_RESET_INIT 
	ld a, l
	cp e							;if e != l
	jr nz, MENU_ITEMS_RESET_INIT	;then jump to MENU_ITEMS_RESET_INIT 
	ld b, 0							;else, we want b to contain the same value that was used for the top of the inventory earlier so b = 0
	jr MENU_ITEMS_RESET
MENU_ITEMS_RESET_INIT:			;in preparation, we want be to contain the number of times it should loop
								;so we want b to contain 256 - (TOP_ITEMCODE - INVENTORY)/2
	ld a, d
	cpl
	ld d, a
	ld a, e
	cpl
	ld e, a
	inc de							;de now contains -de
	add hl, de						;hl = TOP_ITEMCODE - INVENTORY
	srl h				
	rr l							;divides hl by 2
	
	ld a, h
	cpl
	ld h, a
	ld a, l
	cpl
	ld l, a
	inc hl							;2's complement, so hl now contains -(TOP_ITEMCODE - INVENTORY)/2
	
	ld de, 256
	add hl, de						;add 256 so hl now contains 256 - (TOP_ITEMCODE - INVENTORY)/2
		
	ld b, l							;we only want the lower half of hl though, so load l into b
MENU_ITEMS_RESET:
	ld a, [TOP_ITEMCODE]
	ld h, a
	ld a, [TOP_ITEMCODE+1]
	ld l, a							;set the other registers to the correct values
	ld c, 16
	ld de, ITEMCODE_DISP
	jp ITEMCODE_LOOP_INIT			;and then jump to ITEMCODE_LOOP_INIT

MENU_ITEMS_EMPTY::
	pop af							
	ld a, BANK_TILESET				;set the bank back to bank 3
	ld [$2000], a
	jp MENU_ITEMS_LOOP				;nothing on screen will have changed so we can just jump to MENU_ITEMS_LOOP
	
MENU_ITEMS_PAGE_UP::
	ld a, [$9E21]					
	cp $F3							;if the tile at $9E21 != $F3, then the arrow is not there
	jp nz, MENU_ITEMS_LOOP			;so jump to MENU_ITEMS_LOOP
	
	ld a, [TOP_ITEMCODE]
	ld h, a
	ld a, [TOP_ITEMCODE+1]
	ld l, a
	ld b, 16
	ld de, INVENTORY-2
	ld a, [$9C22]
	cp $81							;if the tile at the first point where text is output is not the tile for a space
	jr nz, .loop					;then jump to .loop
	ld b, 15						;else load into b 15, as the page must be empty so we want to go back 15 items instead of 16
	
.loop:
	ld a, d
	cp h							;if d != h
	jr nz, .loop_main				;then jump to .loop_main
	ld a, e
	cp l							;id e != l
	jr nz, .loop_main				;then jump to .loop_main
	inc hl
	inc hl							;inc hl twice so that it points to the item code that was just in a
	jr .loop_escape					;and then exit the loop
.loop_main:
	ld a, b
	or a							;if the loop counter = 0
	jr z, .loop_escape				;then exit the loop
	ld a, [hl]
	dec hl							;decrement hl twice so that it points to the previous item code
	dec hl
	or a							;if [hl] = 0
	jr z, .loop						;then jump back to the start of the loop
	dec b							;else decrement b and jump back to the start of the loop
	jr .loop
	
.loop_escape:	
	ld a, h
	ld [TOP_ITEMCODE], a
	ld a, l
	ld [TOP_ITEMCODE+1], a
	jp MENU_JUMP_TO_ITEMCODE_LOOP	;now that TOP_ITEMCODE has been updated, we can jump to MENU_JUMP_TO_ITEMCODE_LOOP to redraw the display
	
MENU_ITEMS_PAGE_DOWN::
	ld a, [$9E32]					
	cp $F4							;if the tile at $9E32 != $F4, then the left arrow is not there
	jp nz, MENU_ITEMS_LOOP			;so jump to MENU_ITEMS_LOOP
	
	ld a, [TOP_ITEMCODE]
	ld h, a
	ld a, [TOP_ITEMCODE+1]
	ld l, a
	ld b, 0
.loop:								;this loop finds a memory location that is 16 item codes lower in memory than TOP_ITEMCODE
	ld a, b
	cp 16							;if our counter = 16
	jr z, .loop_escape				;then exit the loop
	ld a, [hl]		
	inc hl							;increment hl twice so that it points to the next item code
	inc hl							
	or a							;if [hl] = 0
	jr z, .loop						;then jump back to the start of the loop
	inc b							;else, increment the counter and then jump back to the start of the loop
	jr .loop
	
.loop_escape:
	ld a, h
	ld [TOP_ITEMCODE], a
	ld a, l
	ld [TOP_ITEMCODE+1], a
	jp MENU_JUMP_TO_ITEMCODE_LOOP	;now that TOP_ITEMCODE has been updated, we can jump to MENU_JUMP_TO_ITEMCODE_LOOP to redraw the display 

MENU_ITEMS_CURSOR_UP::
	ld a, [CURSOR_Y]
	cp 24							;if our cursor y = 24, then we are at the top of the screen
	jp z, MENU_ITEMS_LOOP			;so jump back to MENU_ITEMS_LOOP
	
	sub 8							;else cursor y = cursor y - 8
	ld [CURSOR_Y], a
	jp MENU_ITEMS_LOOP
	
MENU_ITEMS_CURSOR_DOWN::
	ld a, [CURSOR_Y]				
	cp 144							;if our cursor y = 144, then we are at the bottom of the screen
	jp z, MENU_ITEMS_LOOP			;so jump back to MENU_ITEMS_LOOP
									
									;we want to check if the item code for the name below the name that the cursor is pointing to = 0
									;so we want hl to contain 2((CURSOR_Y-24)/8 +1) + ITEMCODE_DISP
	sub 24							
	ld c, a
	ld a, 8
	ld b, a
	ld a, c
	ld c, 0
	call DIVIDE						;divides CURSOR_Y-24 by 8 and stores the result in c
	
	ld a, c							;loads the result into a
	inc a							
	sla a							;equivalent to a = a*2, we do this so that we will skip over item quantities
	ld hl, ITEMCODE_DISP
	ld d, 0
	ld e, a
	add hl, de
	ld a, [hl]						
	or a							;if the item code = 0, then there is no item beneath the cursor
	jp z, MENU_ITEMS_LOOP			;so jump back to MENU_ITEMS_LOOP
	
	ld a, [CURSOR_Y]				;else CURSOR_Y = CURSOR_Y + 8
	add 8
	ld [CURSOR_Y], a
	jp MENU_ITEMS_LOOP
	
	
MENU_PARTY::
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a					;turn the window off
	
	xor a
	ld [rWY], a						;set the window y to 0 so that the window fills the screen
	
	ld [CURSOR_X], a				;move the cursor to 0,0 so that it cannot be seen
	ld [CURSOR_Y], a
	
	ld [$FE00], a					;move the player to 0,0 so that they cannot be seen
	ld [$FE01], a
	
	ld de, _SCRN1
	ld hl, StatusScreen
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD			;load the base status screen into the window
	
	ld a, BANK_COMBAT				;set the bank to bank 6 so that we can get the growth rate for different stats
	ld [$2000], a
	
	ld hl, HealthGrowRate			
	ld de, CALC_MAXHEALTH
	call PLAYER_STATS_CALC
	
	
	ld a, BANK_ITEMDB				;set the current bank to bank 7 so that we can get item data
	ld [$2000], a
	ld hl, ATTACK_ITEM
	ld c, 3							;loops 3 times as there are 3 item slots
STATS_ITEMS_LOOP:
	ld a, [hl]
	or a							;if the item code for that slot = 0
	jr z, STATS_ITEMS_LOOP_DEC		;then jump to STATS_ITEMS_LOOP_DEC
	
	push bc
	push hl
	
	ld hl, ITEM_DB
	ld d, 0
	dec a
	ld e, a
	ld b, 8
	ld c, ITEM_LENGTH
	call Multiply					;hl now contains the address of the item number of the item we are checking
	
	ld de, 17						
	add hl, de						;increment hl by 17 so that it points to the stat data for that item
	
	ld a, [hl+]						
	ld b, a							;load the byte which says which stats are increasing or decreasing into b
	ld c, 6						
	ld de, CALC_MAXHEALTH
STATS_ITEMS_LOOP_STATS_UPDATE_LOOP
	ld a, [hl+]							;load into a the amount the stat will change by
	bit 0, b							;test the bit for that stat
	jr nz, STATS_ITEMS_LOOP_STATS_ADD 	;if the bit = 1, then jump to STATS_ITEMS_LOOP_STATS_ADD
	
	push bc
	ld b, a								;store the change in stat in b
	ld a, [de]							;load into a the current calculated stat
	sub b								;and subtract the change in the stat
	pop bc
	ld [de], a							;store the new value in place of the old one
	inc de
	jr nc, STATS_ITEMS_LOOP_STATS_INC	;if sub b caused a carry, then the calculation caused an underflow
	ld a, 0								;so we need to set the stat to 0
	dec de
	ld [de], a
	inc de
	jr STATS_ITEMS_LOOP_STATS_INC
	
STATS_ITEMS_LOOP_STATS_ADD:
	push bc
	ld b, a								;store the change in stat in b
	ld a, [de]							;load into a the current calculated stat
	add b								;and add the change in the stat
	pop bc
	ld [de], a							;store the new value in place of the old one
	inc de
	jr nc, STATS_ITEMS_LOOP_STATS_INC	;if add b caused a carry, then the calculation caused an overflow
	ld a, 255							;so we need to set the stat to 255
	dec de
	ld [de], a
	inc de
	
	
STATS_ITEMS_LOOP_STATS_INC:
	rrc b										;rotate b so that bit 0 contains the bit for the next stat
	dec c										;decrement the counter
	jr nz, STATS_ITEMS_LOOP_STATS_UPDATE_LOOP	;if c != 0, then jump to STATS_ITEMS_LOOP_STATS_UPDATE_LOOP
	
	pop hl										
	pop bc										;pop bc to regain the other loop counter
STATS_ITEMS_LOOP_DEC:									
	inc hl										;increment hl so that it points to the next item code
	dec c
	jr nz, STATS_ITEMS_LOOP
	
	ld a, [HEALTH]
	ld b, a
	ld a, [CALC_MAXHEALTH]	
	cp b										;if health is not > max health
	jr nc, STATS_OUTPUT_STORE_LOOP_INIT			;then jump to STATS_OUTPUT_STORE_LOOP_INIT
	ld [HEALTH], a								;else health = max health
	
STATS_OUTPUT_STORE_LOOP_INIT:	
	ld de, HEALTH
	ld hl, ITEMCODE_DISP		;as ITEMCODE_DISP is not being used here and is cleared out when it is needed by MENU_ITEMS, it is reused here
	ld bc, 9
STATS_OUTPUT_STORE_LOOP:
	push bc
	ld a, [de]
	ld [input], a				;load the quantity into input so that it can be converted to bcd
	ld bc, $0A00
	push de
	push hl
	call DIVIDE					;divide a by 10 and store the result in c. This is necessary for the bcd function to work
	ld a, [input]				;reload the input into a 
	call BcdConvert_init		;and call BcdConvert_init
	
	pop hl
	ld a,[upper_result]
	and $0F						
	add $91						;add $91 as that is the tile for 0, so the bcd result + $91 will be the tile number for that number
	ld [hl+], a
	ld a, [lower_result]
	and $F0						;and $F0 so that we are only dealing with the 2nd number to output
	swap a						;swap so adding $91 will work
	add $91						;add $91 as that is the tile for 0, so the bcd result + $91 will be the tile number for that number
	ld [hl+], a
	ld a, [lower_result]
	and $0F						;and $0F so that we are only dealing with the 3rd number to output
	add $91						;add $91 as that is the tile for 0, so the bcd result + $91 will be the tile number for that number
	ld [hl+], a
	pop de
	inc de						;increment de so that it points to the next stat to output
	pop bc
	dec c						
	jr nz, STATS_OUTPUT_STORE_LOOP
	
	call WAIT_VBLANK					;wait for vblank so that we can output data into vram
	ld de, ITEMCODE_DISP
										;a macro was used here as there is no pattern for the position hl should take
										;I attempted to use a loop, however it required waiting for vblank several times
										;whereas this method only requires waiting once
	ld hl, $9C2C
	StatusOutputMacro					;the macro defined at the start of the program replaces this label
	ld hl, $9D64
	StatusOutputMacro
	ld hl, $9D70
	StatusOutputMacro
	ld hl, $9C30
	StatusOutputMacro
	ld hl, $9C70
	StatusOutputMacro
	ld hl, $9C90
	StatusOutputMacro
	ld hl, $9CD0
	StatusOutputMacro
	ld hl, $9CF0
	StatusOutputMacro
	ld hl, $9D30
	StatusOutputMacro
	
	;This bit of code was rewritten when I realised that I had missed gold/money
	;So it isn't a clean integration into the code, but it works
	ld a, [GOLD]
	ld [input], a
	ld bc, $0A00
	call DIVIDE					;divide a by 10 and store the result in c. This is necessary for the bcd function to work
	ld a, [input]				;reload the input into a 
	call BcdConvert_init
	
	ld a, [upper_result]
	add $91
	ld [$9D90], a
	
	ld a, [lower_result]
	and $F0
	swap a
	add $91
	ld [$9D91], a
	
	ld a, [lower_result]
	and $0F
	add $91
	ld [$9D92], a
	;End of rewritten code
	
	ld hl, $9DC9
	ld de, ATTACK_ITEM
	ld bc, 3
STATS_EQUIPMENT_OUTPUT_LOOP:				;outputs the names for the 3 items that can be equipped
	ld a, [de]
	push de
	or a									;if the item code is 0
	jr z, STATS_EQUIPMENT_OUTPUT_LOOP_INC	;then jump to STATS_EQUIPMENT_OUTPUT_LOOP_INC
	
	push bc
	push hl
	ld hl, ITEM_DB
	ld de, ITEM_LENGTH
	ld b, 8
	dec a
	ld c, a
	call Multiply							;hl now contains the pointer to the item code for the item we are outputting
	inc hl									;increment so that it points to the item name
	
	ld de, CUR_ITEM_NAME
	ld c, 10
.loop:										;copy the item name into CUR_ITEM_NAME
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, .loop
	pop hl
	
	call WAIT_VBLANK						;wait for vblank so that we can output into vram
	
	ld c, 10
	ld de, CUR_ITEM_NAME
.loop2:										;output the item name
	ld a, [de]
	ld [hl+], a
	inc de
	dec c
	jr nz, .loop2
	
	ld de, SUBTRACT_10						;subtract 10 from hl so that it can be incremented by the same amount if the item code is 0 or not
	add hl, de								
	
	pop bc
STATS_EQUIPMENT_OUTPUT_LOOP_INC:
	ld de, 32
	add hl, de								;increment hl by 32 so that it points to the next point to output the item name
	pop de
	inc de
	dec c
	jr nz, STATS_EQUIPMENT_OUTPUT_LOOP	
	
	ld a, [rLCDC]
	or LCDCF_WINON					;turns the window on
	ld [rLCDC], a
	
.loop:
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	and %00001011					;if the player is not pressing start, a or b
	jr z, .loop						;then jump to .loop
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a					;set the player sprite back to the correct x,y
	
	ld a, BANK_TILESET				;set the bank back to bank 3 as MENU_LOOP_ESCAPE is expecting the current bank to be bank 3
	ld [$2000], a
	
	jp MENU_LOOP_ESCAPE
	
MENU_SAVE::
	ld a, [rLCDC]					;turns the screen off
	res 5, a
	ld [rLCDC], a
	
	ld a, BANK_TILESET				;sets the bank to bank 3 so that we can load the frame data into the window
	ld [$2000], a
	
	ld a, MESSAGE_X					;sets the window x and y so that only the message frame is visible
	ld [rWX], a
	ld a, MESSAGE_Y
	ld [rWY], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD			;loads the message frame into the window
	
	ld a, BANK_STRING				;sets the bank to bank 5 so that we can get the string data
	ld [$2000], a
	
	ld de, SaveMessage
	ld b, 0
	call MESSAGE_OUTPUT				;outputs "Do you want to save the game?"
	
	ld a, [rLCDC]
	or LCDCF_WINON					;turns the window on
	ld [rLCDC], a
	
	ld a, 2
	ld [CURSOR_STATE], a			;reuses cursor state to store if the cursor is next to "Yes" or "No"
	
MENU_SAVE_LOOP:
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	bit 0, a						;if a is being pressed
	jr nz, MENU_SAVE_LOOP_ESCAPE	;then jump to MENU_SAVE_LOOP_ESCAPE
	bit 5, a						;if left is being pressed
	jr nz, MENU_SAVE_LEFT			;then jump to MENU_SAVE_LEFT
	bit 4, a						;if right is being pressed
	jr nz, MENU_SAVE_RIGHT			;then jump to MENU_SAVE_RIGHT
	jr MENU_SAVE_LOOP
	
MENU_SAVE_LOOP_ESCAPE:	
	ld a, [CURSOR_STATE]
	cp 1							;if CURSOR_STATE = 1
	call z, SAVE_SAVE				;then call SAVE_SAVE to save the game
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a					;turn the window off
	
	ld a, BANK_TILESET
	ld [$2000], a					;set the bank to bank 3 as MENU_LOOP_ESCAPE is expecting the current bank to be bank 3
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD			;reload the PortraitWindowFrame into the window
	
	jp MENU_LOOP_ESCAPE				;jump to MENU_LOOP_ESCAPE so that the player and the cursor can be set to the correct x,y 
									;and so that the bank can be set back to the bank holding the current map

MENU_SAVE_LEFT:
	ld a, [CURSOR_STATE]
	cp 2							;if the cursor state != 2
	jr nz, MENU_SAVE_LOOP			;then jump to MENU_SAVE_LOOP
	ld a, 1
	ld [CURSOR_STATE], a			;set the cursor state to 1
	call WAIT_VBLANK				;wait for VBLANK so that we can write data to vram
	ld a, 32
	ld [CURSOR_X], a				;move the cursor so that it is next to "Yes"
	jr MENU_SAVE_LOOP
	
MENU_SAVE_RIGHT:
	ld a, [CURSOR_STATE]
	cp 1							;if the cursor state != 1
	jr nz, MENU_SAVE_LOOP			;then jump to MENU_SAVE_LOOP
	ld a, 2
	ld [CURSOR_STATE], a			;set the cursor state to 2
	call WAIT_VBLANK				;wait for VBLANK so that we can write data to vram
	ld a, 112
	ld [CURSOR_X], a				;move the cursor so that it is next to "No"
	jr MENU_SAVE_LOOP
	
SAVE_CHECK::
	ld a, $0A
	ld [$0000], a					;enables sram so that we can read/write to it
	
	ld hl, $A000					;load into hl the address of the start of sram
									
									;If the first 6 bytes of sram contain the tile numbers for "Daniel", then a save file exists
	ld a, [hl+]
	cp $A5							;if [hl] != $A5
	jr nz, SAVE_CHECK_FALSE			;then a save file does not exist, so jump to SAVE_CHECK_FALSE
	ld a, [hl+]
	cp $C2							;if [hl] != $C2
	jr nz, SAVE_CHECK_FALSE			;then a save file does not exist, so jump to SAVE_CHECK_FALSE
	ld a, [hl+]
	cp $CF							;if [hl] != $CF
	jr nz, SAVE_CHECK_FALSE			;then a save file does not exist, so jump to SAVE_CHECK_FALSE
	ld a, [hl+]
	cp $CA							;if [hl] != $CA
	jr nz, SAVE_CHECK_FALSE			;then a save file does not exist, so jump to SAVE_CHECK_FALSE
	ld a, [hl+]
	cp $C6							;if [hl] != $C6
	jr nz, SAVE_CHECK_FALSE			;then a save file does not exist, so jump to SAVE_CHECK_FALSE
	ld a, [hl+]
	cp $CD							;if [hl] != $CD
	jr nz, SAVE_CHECK_FALSE			;then a save file does not exist, so jump to SAVE_CHECK_FALSE
	
	ld a, 0
	ld [$0000], a					;disable reading/writing to sram
	ld a, 1							;a save exists, so load 1 into a
	ret
SAVE_CHECK_FALSE:
	ld a, 0							;a save doesn't exist, so have a = 0 when the program returns
	ld [$0000], a					;disable reading/writing to sram
	ret

SAVE_LOAD::
	ld a, $0A						;enable reading/writing to sram
	ld [$0000], a

	ld hl, $A006					;load into hl the first location in sram not used by the signature
	ld de, $C000					;load into de the first location of system ram
	ld bc, SAVE_COUNTER				;load into bc the number of bytes to copy
	
.loop:								;copies data from sram into system ram
	ld a, [hl+]
	ld [de], a
	inc de
	
	dec bc
	ld a, b
	or c
	jr nz, .loop
	
	xor a							;disable reading/writing to sram
	ld [$0000], a
	ret
	
SAVE_DELETE::
	ld a, $0A
	ld [$0000], a					;enable reading/writing to sram
	
	ld hl, $A000					;load into hl the address of the start of sram
	ld bc, 8192						;load into bc the size of sram (8kB)
.loop:								;write 0 to all 8kB of sram
	xor a
	ld [hl+], a
	dec bc
	ld a, b
	or c
	jr nz, .loop
	
	xor a
	ld [$0000], a					;disable reading/writing to sram
	ret
	
	
	;Able to save data from $C000 to $DFF9 and saves that to $A006 to $BFFF
SAVE_SAVE::							;essentially the same as SAVE_LOAD, but data is copied from system ram to sram instead of the other way around
	ld a, $0A
	ld [$0000], a			;enable read/write to SRAM
	
	ld a, $A5				;write the signature to SRAM
	ld [$A000], a
	ld a, $C2
	ld [$A001], a
	ld a, $CF
	ld [$A002], a
	ld a, $CA
	ld [$A003], a
	ld a, $C6
	ld [$A004], a
	ld a, $CD
	ld [$A005], a
	
	xor a
	ld [$0000], a
	
	ld a, $0A
	ld [$0000], a

	ld hl, $A006					;load into hl the first location in sram not used by the signature
	ld de, $C000					;load into de the first location of system ram
	ld bc, SAVE_COUNTER				;load into bc the number of bytes to copy
	
.loop:								;copies data from system ram into sram
	ld a, [de]
	ld [hl+], a
	inc de
	
	dec bc
	ld a, b
	or c
	jr nz, .loop
	
	xor a
	ld [$0000], a					;disable reading/writing to sram
	ret
	
INVENTORY_ADD::					;When the function is called, register a contains the no for the item to be added
	ld b, a
	ld hl, INVENTORY+508		;Final item in the inventory
	ld c, 255					;Use a counter so that we don't go out of bounds
.loop:
	ld a, [hl]
	cp b
	jr z, .loop_escape			;if the item no hl points to is the same as the item no in b, then jump to .loop_escape
	dec c
	jr z, .loop_escape			;if c = 0, then jump to .loop_escape
	dec hl						
	dec hl						;decrement hl by 2 so that it points to the next item in the inventory
	jr .loop
	
.loop_escape:
	cp b						
	jr nz, ADD_NEW_ENTRY		;if a != b, then an item with the same item no as b was not found, so jump to ADD_NEW_ENTRY
	inc hl						;inc hl so that it points to the number of the item that the player has
	ld a, [hl]					
	cp 255						;if the entry has 255 of that item,
	jr z, ADD_NEW_ENTRY			;then jump to ADD_NEW_ENTRY
	
	inc a						;add 1 to the no of that item
	ld [hl], a					;and load it into memory
	ret
	
ADD_NEW_ENTRY:	
	ld hl, INVENTORY
	ld c, 0
ENTRY_LOOP:
	ld a, [hl]
	inc hl						;increment hl so that it points to the next entry
	inc hl
	dec c
	ret z						;If c = 0, then there is no space for the item, so return
	or a						;If [hl-2] != 0, then we are not pointing to an empty entry 
	jr nz, ENTRY_LOOP			;so jump to ENTRY_LOOP
	dec hl
	dec hl						;decrement hl so that it points to the newest empty entry
	ld a, b						;load the item no into a
	ld [hl+], a					;and output it in the empty entry
	ld a, 1
	ld [hl], a					;as it is a new entry, the quantity is 1
	ret

INVENTORY_REMOVE::			;When the function is called, register a contains the no for the item to be removed
	ld b, a
	ld hl, INVENTORY+508
	ld c, 255
.loop:
	ld a, [hl]
	cp b					;if the item no being pointed to by hl = the item no stored in b
	jr z, .loop_escape		;then jump .loop_escape
	dec c	
	jr z, .loop_escape		;if the counter = 0, then jump to .loop_escape
	dec hl
	dec hl					;dec hl twice so that it points to the next item no
	jr .loop
	
.loop_escape:
	cp b					;if b = 0 then the item wasn't found
	ret nz					;so return
	
	inc hl
	ld a, [hl]				
	cp 1					;if the number of the item left = 1
	jr z, REMOVE_CLEAR 		;then jump to REMOVE_CLEAR so that it can be cleared from memory
	dec a					;else decrement a and store the result in memory
	ld [hl], a
	ret
	
REMOVE_CLEAR::	
	dec hl					;dec hl so it points to the start of the entry
	xor a					;xor a is equivalent to ld a,0 and a xor a will always = 0
	ld [hl+], a
	ld [hl], a
	
	dec hl					;decrement hl so that it points to the first 0
	ld de, INVENTORY+508
.loop:
	ld a, h
	cp d					;if h != d
	jr nz, .loop_main		;then jump to .loop_main
	ld a, l
	cp e					;if l != e
	jr nz, .loop_main		;then jump to .loop_main
	ret						;else hl = de so return
	
.loop_main:	
	inc hl
	inc hl					;increment hl twice so that it points to the next item code
	ld a, [hl]
	ld b, a					;store the item code in b
	xor a
	ld [hl], a				;and clear the space
	inc hl					
	ld a, [hl]				
	ld c, a					;store the quantity in c
	xor a					;and clear the space
	ld [hl], a
	
	dec hl					;decrement hl 3 times so that it points back to the first empty space
	dec hl
	dec hl
	ld a, b					;load the item code back into a
	ld [hl+], a				;and output it into the inventory, incrementing hl as well
	ld a, c					;load the quantity back into a
	ld [hl+], a				;and output it into the inventory, incrementing hl as well
	jr .loop				;hl now points the the first open space again
	
USE_RETURN::
	ld a, [GAMESTATE]
	cp GAMESTATE_OVERWORLD		;if we are in the overworld, then to get to this point we must be in the inventory
	jp z, MENU_ITEMS_USE_REM	;so jump to  MENU_ITEMS_USE_REM
	jp MENU_ITEMS_COMBAT_USE_REM;else we must be in combat, so jump to MENU_ITEMS_COMBAT_USE_REM
	
USE_ATK_EQUIP::
	ld a, [GAMESTATE]
	cp GAMESTATE_OVERWORLD		;if we are not in the overworld
	jp nz, USE_DEFAULT			;then jump to USE_DEFAULT
	
	ld hl, ATTACK_ITEM			;store the memory address of ATTACK_ITEM
	ld a, h
	ld [NEW_TILES], a			;reuse the memory used for new tiles as it is reset when needed for map updates
	ld a, l
	ld [NEW_TILES+1], a
	
	ld a, [ATTACK_ITEM]			
	or a						;if there is no item equipped
	jr z, USE_EQUIP_SET			;then jump to USE_EQUIP_SET 
	
	call INVENTORY_ADD			;else add the item currently equipped back into the inventory
	xor a
	ld [ATTACK_ITEM], a			;and clear the slot
	jr USE_EQUIP_SET

USE_DEF_EQUIP::
	ld a, [GAMESTATE]
	cp GAMESTATE_OVERWORLD		;if we are not in the overworld
	jp nz, USE_DEFAULT			;then jump to USE_DEFAULT
	
	ld hl, DEFENCE_ITEM			;store the memory address of DEFENCE_ITEM
	ld a, h
	ld [NEW_TILES], a			;reuse the memory used for new tiles as it is reset when needed for map updates
	ld a, l
	ld [NEW_TILES+1], a
	
	ld a, [DEFENCE_ITEM]
	or a						;if there is no item equipped
	jr z, USE_EQUIP_SET			;then jump to USE_EQUIP_SET 
	
	call INVENTORY_ADD			;else add the item currently equipped back into the inventory
	xor a
	ld [DEFENCE_ITEM], a		;and clear the slot
	jr USE_EQUIP_SET

USE_GEN_EQUIP::
	ld a, [GAMESTATE]
	cp GAMESTATE_OVERWORLD		;if we are not in the overworld
	jp nz, USE_DEFAULT			;then jump to USE_DEFAULT
	
	ld hl, GENERAL_ITEM			;store the memory address of GENERAL_ITEM
	ld a, h
	ld [NEW_TILES], a			;reuse the memory used for new tiles as it is reset when needed for map updates
	ld a, l
	ld [NEW_TILES+1], a
	
	ld a, [GENERAL_ITEM]
	or a						;if there is no item equipped
	jr z, USE_EQUIP_SET			;then jump to USE_EQUIP_SET 
	
	call INVENTORY_ADD			;else add the item currently equipped back into the inventory
	xor a
	ld [GENERAL_ITEM], a		;and clear the slot
	jr USE_EQUIP_SET
	
USE_EQUIP_SET:
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a				;turns the window off so that we can changed the window to the message frame instead of the menu frame
	
	call WAIT_VBLANK			;wait for vblank so that we can access the cursor x and y
	ld a, [CURSOR_Y]
	ld [CURSOR_STATE], a		;as cursor state is not used in the item part of the menu, we can reuse it here to hold the cursor y
	
	xor a
	ld [CURSOR_Y], a
	ld [CURSOR_X], a			;sets the cursor x and y to 0 so that it is not visible
	
	ld a, PLAYER_Y * 8 + 16		;sets the player x and y back so that the player is visible while the messages are being output
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a
	
	xor a
	ld de, RAM_MESSAGE
	ld c, 54
.loop:							;clears RAM_MESSAGE so that we can write the message into it
	ld [de], a
	inc de
	dec c
	jr nz, .loop
	
	ld a, BANK_STRING			;sets the bank to bank 5 so that we can get the message data 
	ld [$2000], a
	
	ld hl, YouEquipped
	ld de, RAM_MESSAGE
	ld c, 18
YouEquipped_loop:				;copies the "You equipped the " message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, YouEquipped_loop
	
	ld a, BANK_ITEMDB			;sets the bank to bank 7 so that we can get the item name
	ld [$2000], a	
	
	add sp, 2					;adds 2 to the stack pointer so that it points to the item code pushed to the stack earlier
	pop af						;pop af so that the item code is still on the stack
	dec sp
	dec sp
	dec sp
	dec sp						;dec sp 4 times so that we are pointing to a part in hram below the item code and below the return address
	
	ld b, a
	ld a, [NEW_TILES]
	ld h, a
	ld a, [NEW_TILES+1]
	ld l, a
	ld a, b
	ld [hl], a					;stores the item code into either ATTACK_ITEM, DEFENCE_ITEM or GENERAL_ITEM depending on which was written to NEW_TILES
	
	ld hl, ITEM_DB				;we want hl to point to the item no of our current item in the item db
	dec a
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ITEM_LENGTH
	call Multiply
	inc hl							;increment hl so that it points to the item name
	
	
	ld de, RAM_MESSAGE+18
	ld c, 10
EQUIP_RAM_name_loop:						;copies the item name into the ram message
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, EQUIP_RAM_name_loop
	
	ld a, $80						;adds the null terminator to the end of the message
	ld [de], a
	
	ld a, MESSAGE_Y
	ld [rWY], a
	ld a, MESSAGE_X
	ld [rWX], a						
	
	ld a, BANK_TILESET				;sets the bank to bank 3 so that we can load the frame data into the window
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD
	
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;outputs the message stored in RAM_MESSAGE
	
EQUIP_input_loop:
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	ld a, BANK_ITEMDB				;sets the bank back to bank 7 as that is what the menu items code is expecting the bank to be
	ld [$2000], a
	
	ld a, [rLCDC]					;turns the window off again
	res 5, a
	ld [rLCDC], a
	
	ld a, [CURSOR_STATE]
	ld [CURSOR_Y], a				;set the cursor back to the y position it had
	ld a, 16
	ld [CURSOR_X], a
	
	xor a
	ld [rWY], a						;and set the window y back to 0
	
	ld [$FE00], a					
	ld [$FE01], a					;sets the player x and y back to 0 so that they cannot be seen	
	ret
	
USE_DEFAULT::					;outputs "You used the item", itemname "But it did nothing"
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a				;turns the window off so that we can changed the window to the message frame instead of the menu frame
	
	call WAIT_VBLANK			;wait for vblank so that we can access the cursor x and y
	ld a, [CURSOR_Y]
	ld [CURSOR_STATE], a		;as cursor state is not used in the item part of the menu, we can reuse it here to hold the cursor y
	
	xor a
	ld [CURSOR_Y], a
	ld [CURSOR_X], a			;sets the cursor x and y to 0 so that it is not visible
	
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT
	call z, COMBAT_ENEMY_SHOW
	jr z, .loop_init
	
	ld a, PLAYER_Y * 8 + 16		;sets the player x and y back so that the player is visible while the messages are being output
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a

.loop_init:
	xor a
	ld de, RAM_MESSAGE
	ld c, 54
.loop:							;clears RAM_MESSAGE so that we can write the message into it
	ld [de], a
	inc de
	dec c
	jr nz, .loop
	
	ld a, BANK_STRING			;sets the bank to bank 5 so that we can get the message data 
	ld [$2000], a
	
	ld hl, YouUsed
	ld de, RAM_MESSAGE
	ld c, 18
YouUsed_loop:					;copies the "You used the item" message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, YouUsed_loop
	
	ld a, BANK_ITEMDB			;sets the bank to bank 7 so that we can get the item name
	ld [$2000], a	
	
	add sp, 2					;adds 2 to the stack pointer so that it points to the item code pushed to the stack earlier
	pop af						;pop af so that the item code is still on the stack
	dec sp
	dec sp
	dec sp
	dec sp						;dec sp 4 times so that we are pointing to a part in hram below the item code and below the return address
	
	ld hl, ITEM_DB				;we want hl to point to the item no of our current item in the item db
	dec a
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ITEM_LENGTH
	call Multiply
	inc hl							;increment hl so that it points to the item name
	
	
	ld de, RAM_MESSAGE+18
	ld c, 10
RAM_name_loop:						;copies the item name into the ram message
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, RAM_name_loop
	
	ld a, $80						;adds the null terminator to the end of the message
	ld [de], a
	
	ld a, MESSAGE_Y
	ld [rWY], a
	ld a, MESSAGE_X
	ld [rWX], a						
	
	ld a, BANK_TILESET				;sets the bank to bank 3 so that we can load the frame data into the window
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD
	
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;outputs the message stored in RAM_MESSAGE
	
input_loop:
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	ld a, BANK_STRING				;set the bank back to bank 5 so we can output the 2nd message
	ld [$2000], a
	
	ld de, ButItDid
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;outputs "But it did nothing"
	
	add sp, 2						;adds 2 so that it points to the item code
	pop af							;retrieves the item code
	push af							;and pushes it back onto the stack
	dec sp
	dec sp							;decrement so that we point to the return address
	
	call INVENTORY_ADD				;adds the item back so that we can remove it later and end up with the correct amount
	
input_loop2:
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	ld a, BANK_ITEMDB				;sets the bank back to bank 7 as that is what the menu items code is expecting the bank to be
	ld [$2000], a
	
	ld a, [rLCDC]					;turns the window off again
	res 5, a
	ld [rLCDC], a
	
	ld a, [CURSOR_STATE]
	ld [CURSOR_Y], a				;set the cursor back to the y position it had
	ld a, 16
	ld [CURSOR_X], a
	
	xor a
	ld [rWY], a						;and set the window y back to 0
	
	ld [$FE00], a					
	ld [$FE01], a					;sets the player x and y back to 0 so that they cannot be seen
	ret

USE_POTION::
	ld a, [$4000]					;get the current bank
	push af							;and push it to the stack
	
	ld a, BANK_COMBAT				;set the current bank to bank 6 so that we can get player growth rates
	ld [$2000], a
	
	
	ld hl, HealthGrowRate			
	ld de, CALC_MAXHEALTH
	call PLAYER_STATS_CALC			;calculates the playerstats
	
	ld a, [CALC_MAXHEALTH]
	ld b, a							;load the maximum health into b so that it can be used for comparisions
	ld a, [HEALTH]
	push af							;push health, so that we can get the old value for health off of the stack after incrementing health
	cp b
	jr z, USE_POTION_NO_ADD			;if health = maximum health, then health can't increase so jump to USE_POTION_NO_ADD
	add 10							;base amount that the potion will heal by
	jr c, USE_POTION_OVERFLOW 		;if there was an overflow, then jump to USE_POTION_OVERFLOW
	
	cp b							;if the new value for health >= max health, then we want health = max health so that it is in bounds
	jr nc, USE_POTION_OVERFLOW		;so if there is not a carry, then health >= max health, so jump to USE_POTION_OVERFLOW
	
USE_POTION_NO_ADD:
	ld [HEALTH], a
	
	pop af							;get the old value for health off of the stack and store it in b
	ld b, a
	ld a, [HEALTH]
	
	sub b							;subtract the new value for health from the old value
	ld [NEW_TILES], a				;and store the difference in NEW_TILES
	
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT
	call z, COMBAT_UPDATE_HEALTH
	jr USE_POTION_GRAPHICAL
	
USE_POTION_OVERFLOW:
	ld a, [CALC_MAXHEALTH]			;adding 10 health caused an overflow, so set health to the max value
	jr USE_POTION_NO_ADD
	
USE_POTION_GRAPHICAL:	
	ld a, [rLCDC]					;get the current state of the screen
	push af							;and push it to the stack
	
	res 5, a
	ld [rLCDC], a					;turn the window off
	
	ld a, BANK_TILESET				;set the current bank to bank 3 so that we can set frame data
	ld [$2000], a
	
	ld a, MESSAGE_X					;move the window so that the message can be output correctly
	ld [rWX], a
	ld a, MESSAGE_Y
	ld [rWY], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD			;load the normal frame
	
	ld a, [CURSOR_X]
	push af
	ld a, [CURSOR_Y]
	push af							;push the cursor x,y so that it can return to that position
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a				;move the cursor to 0,0 so that it can't be seen
	
	call WAIT_VBLANK				;wait for vblank so that if we need to show the enemy tiles,
									;they can all be loaded in
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT				;if we are in combat,
	call z, COMBAT_ENEMY_SHOW		;then show the enemy tiles
	
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT				;if we are in combat,
	jr z, USE_POTION_OUTPUT1		;then jump to USE_POTION_OUTPUT1 so that the player isn't visible
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a					;move the player to the correct x,y position
		
	
USE_POTION_OUTPUT1:
	ld a, BANK_STRING				;set the current bank to bank 5 so that we can get message data
	ld [$2000], a

	ld de, YouUsedThePotion
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;Output "You used the Potion"
	call WAIT_FOR_A_OR_B			
	
	call RAM_MESSAGE_CLEAR			;clear RAM_MESSAGE so that no left over data is displayed
	ld b, 25
	ld de, YouRegainedHealth
	ld hl, RAM_MESSAGE
.loop:								;copies the message into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, .loop
	
	ld a, [NEW_TILES]				;get the differnce in health
	ld [input], a					;and store it in input so that it can be converted to bcd
	ld bc, $0A00
	call DIVIDE						;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]			;get the upper result which stores the first digit
	and $0F
	add $91							;add $91 as that is the tile no for 0
	ld [RAM_MESSAGE+13], a			;store it in RAM_MESSAGE		
	
	ld a, [lower_result]			
	and $F0							;and $F0 so that the lower half doesn't affect any calculations
	swap a							;swap so that adding will give the correct tile no
	add $91							;add $91 as that is the tile no for 0
	ld [RAM_MESSAGE+14], a					
	
	ld a, [lower_result]
	and $0F							;and $0F so that the upper half doesn't affect any calculations
	add $91							;add $91 as that is the tile no for 0
	ld [RAM_MESSAGE+15], a					
	
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;outputs "You regained ", [NEW_TILES], "health"
	call WAIT_FOR_A_OR_B
	
	ld a, BANK_TILESET				;set the current bank to bank 3 so that we can change frame
	ld [$2000], a
	
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT				;if we are in combat,
	jr z, USE_POTION_PLAYER_HIDE	;then don't change the frame and jump to USE_POTION_PLAYER_HIDE
	ld de, _SCRN1
	ld hl, LargeWindowFrame
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD			;load the frame used in the item menu
	xor a
	ld [rWY], a						;move the window back to the correct y position
USE_POTION_PLAYER_HIDE:	
	xor a
	ld [$FE00], a
	ld [$FE01], a					;move the player back to 0,0
	
	call WAIT_VBLANK				;wait for vblank so that if we need to show the enemy tiles,
									;they can all be loaded in 
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT				;if we are in combat,
	call z, COMBAT_ENEMY_HIDE		;then call COMBAT_ENEMY_HIDE
	
	pop af
	ld [CURSOR_Y], a
	pop af
	ld [CURSOR_X], a 				;move the cursor back to the x,y position it had before
	
	
	pop af
	ld [rLCDC], a					;set the screen back to how it was

	pop af
	ld [$2000], a					;and set the bank back to what it was before
	
	ld a, [GAMESTATE]
	cp GAMESTATE_COMBAT				;if we are not in combat
	ret nz							;then return
	
	ld a, [rLCDC]					;else turn the window off
	res 5, a
	ld [rLCDC], a
	
	xor a							;and move the cursor to 0,0
	ld [CURSOR_Y], a
	ld [CURSOR_X], a
	ret
	
COMBAT::
	ld a, [$4000]
	push af							;push the current bank no so that it is not lost
	ld a, BANK_COMBAT
	ld [$2000], a					;set the bank to bank 6 so that we can calculate stats

	ld a, [rLCDC]
	push af							;push the current state of the screen so that any settings are kept
	xor a
	ld [rLCDC], a					;turn the window off
	
	call gbt_stop					;stop the current song
	
	ld a, GAMESTATE_COMBAT
	ld [GAMESTATE], a
	
	
	;Create a list of the moves that the player can use
	
	ld a, BANK_ITEMDB 			;Set the current bank to bank 7 as that is where move data is stored
	ld [$2000], a
	
	ld hl, MoveData
	ld de, 12
	add hl, de					;Increment hl by 12 so that it points to the level the move is available at
	
	ld de, COMBAT_MOVES_LIST	
	push de						;push de so that we can use d and so that we only pop and push de when we need to alter it
	
	ld b, 255					;Loop counter
	ld c, 1						;Used to tell which move no we are on
MOVE_LIST_LOOP:
	ld a, [LEVEL]
	ld d, a
	ld a, [hl]
	cp d						
	jr z, MOVE_LIST_LOOP_ADD	;if the level that the move is learnt = current level, then jump to MOVE_LIST_LOOP_ADD
	jr c, MOVE_LIST_LOOP_ADD	;else if the level that the move is learnt < current level, then jump to MOVE_LIST_LOOP_ADD
	jr MOVE_LIST_LOOP_INC		;else, the player cannot use that move so jump to MOVE_LIST_LOOP_INC
	
MOVE_LIST_LOOP_ADD:
	pop de						;pop de so that we can access our place in COMBAT_MOVES_LIST
	ld a, c						;load into a the current move no
	ld [de], a					;add the move no to the list
	inc de						;inc so that we point to the next move
	push de						;and push so that we can use d again
MOVE_LIST_LOOP_INC:	
	ld de, MOVE_LENGTH
	add hl, de					;increment hl by MOVE_LENGTH so that we point to the level that the next move is learnt at
	inc c						;increment our move counter
	dec b						;decrement the loop counter
	jr nz, MOVE_LIST_LOOP		;if the loop counter != 0, then jump to MOVE_LIST_LOOP
	pop de						;pop de so that the stack pointer is at the same point it was before we set up the loop
	
	
	ld a, BANK_COMBAT			;Set the current bank back to bank 6 so that we can calculate stats
	ld [$2000], a
	
	call MAP_CLEAR					;clear the background
	xor a
	ld [$FE00], a
	ld [$FE01], a					;move the player to 0,0
	
	xor a
	ld [rSCX], a
	ld [rSCY], a
	
	ld a, [ENEMY_NO]
	dec a							;a = enemy_no -1 so that we can get the correct enemy data
	ld hl, EnemyData
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ENEMY_LENGTH
	call Multiply					;hl = enemydata + enemy_length * enemy_no-1
									;so hl points to the enemy referenced by enemy_no
	ld de, 10
	add hl, de						;increment hl by 10 so that it skips over the name
	
	ld de, ENEMY_HEALTH				;ld into de the memory location to output stats
	ld c, 6							;6 as there are 6 stats to calculate
	
.loop:
	push bc							;push bc and de so that the registers can be used and the values can be retained
	push de
	
	ld a, [hl+]						
	ld b, a							;load into b the m term
	ld a, [hl+]						;load into a the c term
	push hl							;push hl so that we can get back to the enemy data after calculations
	
	ld h, 0
	ld l, a
	ld e, b
	ld d, 0
	ld b, 8
	ld a, [ENEMY_LEVEL]
	ld c, a
	
	call Multiply					;hl = c + mx where x = enemy level
	
	ld a, h
	or a							;if h = 0
	jr z, .loop_inc					;then there wasn't an overflow so jump to .loop_inc	 
	
	ld a, 255						;else load 255 into l
	ld l, a
	
.loop_inc:
	ld a, l							;load the lower half of hl into a
	pop hl
	pop de
	
	ld [de], a						;load into memory the calculated stat
	inc de							;increment so that de points to the next output location
	
	pop bc
	dec c							
	jr nz, .loop					;if c != 0, then there are more stats to calculate so jump to .loop
	
	ld de, 9						;increment hl by 9 so that it points to the memory reference for the tiles for that enemy
	add hl, de
	
	ld b, 8
	
	ld a, [ENEMY_NO]
	cp 40							
	jr z, COMBAT_ENEMY_TILES_LOAD 	;if enemy_no = 40
	jr c, COMBAT_ENEMY_TILES_LOAD	;or enemy_no > 40, then the bank for the current enemy is bank 8
	inc b							;else bank no += 1
	
	cp 80
	jr z, COMBAT_ENEMY_TILES_LOAD 	;if enemy_no = 80
	jr c, COMBAT_ENEMY_TILES_LOAD	;or enemy_no > 80, then the bank for the current enemy is bank 9
	inc b							;else bank no += 1
	
	cp 120
	jr z, COMBAT_ENEMY_TILES_LOAD	;if enemy_no = 120 
	jr c, COMBAT_ENEMY_TILES_LOAD	;or enemy_no > 120, then the bank for the current enemy is bank 10
	inc b							;else bank no += 1
	
	cp 160
	jr z, COMBAT_ENEMY_TILES_LOAD 	;if enemy_no = 160
	jr c, COMBAT_ENEMY_TILES_LOAD	;or enemy_no > 160, then the bank for the current enemy is bank 11
	inc b							;else bank no += 1
	
	cp 200
	jr z, COMBAT_ENEMY_TILES_LOAD	;if enemy_no = 200 
	jr c, COMBAT_ENEMY_TILES_LOAD	;or enemy_no > 200, then the bank for the current enemy is bank 12
	inc b							;else bank no += 1
	
	cp 240
	jr z, COMBAT_ENEMY_TILES_LOAD 	;if enemy_no = 240
	jr c, COMBAT_ENEMY_TILES_LOAD	;or enemy_no > 240, then the bank for the current enemy is bank 13
	inc b							;else bank no += 1, so the bank must be bank 14

COMBAT_ENEMY_TILES_LOAD:	
	ld a, [hl+]
	ld e, a
	ld a, [hl]
	ld d, a							;load into de the memory reference stored at [hl] and [hl+1]
	
	ld a, b
	ld [$2000], a					;set the bank to the bank containing the enemy tiles
	
	ld bc, 25*16					;no of tiles * bytes per tile
	ld hl, $8050 					;first memory location for sprite data to be output
.loop:								;copies the tile data into memory

	ld a, [de]
	ld [hl+], a
	inc de
	
	dec bc
	ld a, b
	or c
	jr nz, .loop
	
	ld a, [ENEMY_HEALTH]
	ld [ENEMY_MAXHEALTH], a
	
	call COMBAT_ENEMY_SHOW
 
	ld hl, HealthGrowRate			
	ld de, CALC_MAXHEALTH
	call PLAYER_STATS_CALC			;calculates the player stats
	
	ld a, BANK_STRING 				;sets the current bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	ld hl, AWildAppeared
	ld de, RAM_MESSAGE
	ld b, 7
.loop1:								;copies the first section of the message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, .loop1
	
	ld a, BANK_COMBAT				;sets the current bank to bank 6 so that we can get the enemy name and insert it into the message
	ld [$2000], a
	
	push hl							;hl needs to be retained so that we keep our place in the message
	push de							;de needs to be retained so that we keep our place in RAM_MESSAGE
	ld hl, $4001
	ld a, [ENEMY_NO]
	dec a
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ENEMY_LENGTH
	call Multiply					;hl = $4001 + enemy_no-1 * enemy_length, so hl points to the current enemy again
	
	pop de							
	ld b, 10
NAME_COPY:							;inserts the name of the enemy into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, NAME_COPY
	
	ld a, BANK_STRING				;sets the current bank back to 5 so that we can copy the rest of the message
	ld [$2000], a
	
	pop hl
	ld b, 11
APPEARED_RAM:						;copies the rest of the message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, APPEARED_RAM
	
	
	ld a, BANK_TILESET				;sets the bank to bank 3 so that we can get the tile references required
	ld [$2000], a
	
	ld hl, _SCRN0 + 32*9			;load into hl the first byte to output data
	ld de, CombatHealthOut			;load into de the pointer to the tile references
	ld b, 20
	ld c, 2
.loop:								;runs 20*2 times, outputting data from [CombatHealthOut] onto the screen at [hl]			
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, .loop
	ld b, 20
	
	push de
	ld de, 12
	add hl, de						;increment hl by 12 so that it points to the start of the next line
	pop de
	
	dec c
	jr nz, .loop
	
	ld a, [ENEMY_HEALTH]
	ld [input], a					;stores the enemy health in input so that it can be used for bcd conversion
	ld bc, $0A00
	call DIVIDE						;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]
	and $0F							
	add $91							;add $91 so that a now contains the tile no of the number in the lower half of upper_result
	ld [$992B], a					;As the enemy must be at max health at the start of the battle,
	ld [$992F], a					;output their health at both sections
	
	ld a, [lower_result]
	and $F0							;and $F0 so that the lower half doesn't affect the tile we end up with
	swap a							;swap so that instead of being 16X, it becomes X
	add $91							
	ld [$992C], a
	ld [$9930], a
	
	ld a, [lower_result]
	and $0F							;and $0F so that the upper half doesn't affect the tile we end up with
	add $91
	ld [$992D], a
	ld [$9931], a
	
	ld a, [HEALTH]
	ld b, a
	ld a, [CALC_MAXHEALTH]
	cp b							;if HEALTH <= CALC_MAXHEALTH
	jr nc, BCD_CALC_START			;then jump to BCD_CALC_START
	ld [HEALTH], a					;Else, HEALTH > CALC_MAXHEALTH which shouldn't be allowed, so HEALTH = CALC_MAXHEALTH
	
BCD_CALC_START:						;This next section is almost the same as the previous, except the players health and
									;max health may be different, so they are output separately 
	ld a, [HEALTH]
	ld [input], a
	ld bc, $0A00
	call DIVIDE						;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]
	and $0F
	add $91
	ld [$9948], a					;Outputs the first no of health onto the screen
	
	ld a, [lower_result]
	and $F0
	swap a
	add $91
	ld [$9949], a					;Outputs the 2nd no of health onto the screen
	
	ld a, [lower_result]
	and $0F
	add $91
	ld [$994A], a					;Outputs the 3rd no of health onto the screen
	
	ld a, [CALC_MAXHEALTH]
	ld [input], a
	ld bc, $0A00
	call DIVIDE						;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]
	and $0F
	add $91
	ld [$994C], a					;Outputs the first no of max health onto the screen
	
	ld a, [lower_result]
	and $F0
	swap a
	add $91
	ld [$994D], a					;Outputs the 2nd no of max health onto the screen
	
	ld a, [lower_result]
	and $0F
	add $91
	ld [$994E], a					;Outputs the 3rd no of max health onto the screen
	
	pop af							;turn the screen back on
	ld [rLCDC], a
	
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;output "A wild ", enemy_name,"appeared!"
	
WAIT_BUTTON:
	halt
	call READ_JOYPAD
	ld a, [joypad_down]
	or a							;if the player is not pressing any buttons
	jr z, WAIT_BUTTON 				;then jump to WAIT_BUTTON

COMBAT_MAIN_INIT::
	ld a, BANK_COMBAT		;set the current bank to bank 6 so that we can get the encounter number for the enemy
	ld [$2000], a
	
	ld hl, EnemyData		;We want hl to point to the encounter number of the current enemy
	ld a, [ENEMY_NO]		;so we want hl to contain EnemyData + ENEMY_LENGTH(ENEMY_NO-1) + 30
	dec a
	ld c, a
	ld b, 8
	ld d, 0
	ld e, ENEMY_LENGTH
	call Multiply
	ld de, 30
	add hl, de				
	ld a, [hl]					;hl now points to the encounter number , so we can load it into a
	
	ld hl, Encounter0			;we want hl to point to the code for the encounter number in a
	ld b, 8						;so we want hl to contain Encounter0 + a(ENCOUNTER_LENGTH)
	ld c, a 					;a instead of a-1, as encounter0 is used for the default case
	ld d, 0
	ld e, ENCOUNTER_LENGTH 
	call Multiply
	push hl						;push the memory location to run code from
	ret							;and return to that section
	
COMBAT_MAIN_INIT_RET:				;encounter code returns to this point
	ld a, BANK_TILESET				;set the current bank to bank 3 so that we can get the frame data
	ld [$2000], a
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a					;turns the window off
	
	ld de, _SCRN1
	ld hl, CombatFrame1
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD			;loads the menu	frame
	
	ld a, [rLCDC]
	set 5, a
	ld [rLCDC], a					;turns the window back on
	
	xor a
	ld [CURSOR_STATE], a			;sets the cursor state to 0
	
	ld a, 16						;set the cursor (x,y) to (16,128) so that it points to the first option
	ld [CURSOR_X], a
	ld a, 128
	ld [CURSOR_Y], a
	
COMBAT_MAIN::
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	and $F0							;and $F0 as dpad state is stored in upper byte
	or a							
	jr z, COMBAT_MAIN_A_TEST		;if no buttons on the dpad are being pressed, then jump to COMBAT_MAIN_A_TEST
	
COMBAT_MAIN_UP_TEST:	
	bit 6, a						;if the player is not pressing up
	jr z, COMBAT_MAIN_DOWN_TEST		;then jump to COMBAT_MAIN_DOWN_TEST
	
	ld a, [CURSOR_STATE]
	cp 2							;if the cursor state < 2
	jr c, COMBAT_MAIN_DOWN_TEST		;then jump to COMBAT_MAIN_DOWN_TEST
	
	sub 2							;sub 2 so that the cursor state is for the option above the current one
	ld [CURSOR_STATE], a
	jp COMBAT_CURSOR_UPDATE			;and jump to COMBAT_CURSOR_UPDATE so that we can move the cursor to the correct x,y
	
COMBAT_MAIN_DOWN_TEST:
	bit 7, a						;if the player is not pressing down
	jr z, COMBAT_MAIN_LEFT_TEST		;then jump to COMBAT_MAIN_LEFT_TEST
	
	ld a, [CURSOR_STATE]
	cp 2							;if cursor_state >= 2, then the cursor is on the bottom row so it can't move down 
	jr nc, COMBAT_MAIN_LEFT_TEST	;so jump to COMBAT_MAIN_LEFT_TEST
	
	add 2							;else add 2 to move the cursor up
	ld [CURSOR_STATE], a
	jp COMBAT_CURSOR_UPDATE			;and jump to COMBAT_CURSOR_UPDATE so that we can move the cursor to the correct x,y
	
COMBAT_MAIN_LEFT_TEST:
	bit 5, a						;if the player is not pressing left
	jr z, COMBAT_MAIN_RIGHT_TEST	;then jump to COMBAT_MAIN_RIGHT_TEST
	
	ld a, [CURSOR_STATE]
	bit 0, a						;if bit 0 of cursor_state is not set, then it is in state 0 or 2 so it can't move left 
	jr z, COMBAT_MAIN_RIGHT_TEST	;so, jump to COMBAT_MAIN_RIGHT_TEST
	
	dec a
	ld [CURSOR_STATE], a
	jp COMBAT_CURSOR_UPDATE			;and jump to COMBAT_CURSOR_UPDATE so that we can move the cursor to the correct x,y
	
COMBAT_MAIN_RIGHT_TEST:	
	bit 4, a						;if the player is not pressing right
	jr z, COMBAT_MAIN				;then something must have gone wrong, so jump back to COMBAT_MAIN, instead of assuming input 
	
	ld a, [CURSOR_STATE]
	bit 0, a						;if bit 0 of cursor_state is set, then it is in state 1 or 3 so it can't move right
	jr nz, COMBAT_MAIN				;so, jump to COMBAT_MAIN
	
	inc a							;increment so that the cursor state is for the state next to the current one
	ld [CURSOR_STATE], a
	jp COMBAT_CURSOR_UPDATE			;and jump to COMBAT_CURSOR_UPDATE so that we can move the cursor to the correct x,y
	
COMBAT_MAIN_A_TEST:
	ld a, [joypad_pressed]
	bit 0, a						;if a is not being pressed
	jr z , COMBAT_MAIN				;then jump to COMBAT_MAIN
	
	call RANDOMISE					;reset the random seed so that it if we need to generate an attack for the enemy,
									;then it can be random
	
	ld a, [CURSOR_STATE]
	or a
	jp z, COMBAT_ATTACK				;if the cursor state = 0, then we are pointing to attack, so jump to COMBAT_ATTACK

	cp 1
	jp z, COMBAT_MOVES				;else, if the cursor state = 0, then we are pointing to moves, so jump to COMBAT_MOVES
	
	cp 2
	jp z, COMBAT_ITEMS				;else,if the cursor state = 0, then we are pointing to items, so jump to COMBAT_ITEMS
	
	jp COMBAT_ESCAPE				;else, we are pointing at escape, so call COMBAT_ESCAPE 

COMBAT_CURSOR_UPDATE:
	ld a, [CURSOR_STATE]
	or a					
	jr nz, COMBAT_CURSOR_TEST2		;if the cursor state != 0, then jump to COMBAT_CURSOR_TEST2
	
	ld a, 16
	ld [CURSOR_X], a
	ld a, 128
	ld [CURSOR_Y], a				;else, set the cursor x,y so that it points to Attack
	jp COMBAT_MAIN					;and jump back to COMBAT_MAIN
	
COMBAT_CURSOR_TEST2:
	cp 1
	jr nz, COMBAT_CURSOR_TEST3		;if the cursor state != 1, then jump to COMBAT_CURSOR_TEST3
	
	ld a, 88
	ld [CURSOR_X], a
	ld a, 128
	ld [CURSOR_Y], a				;else, set the cursor x,y so that it points to Moves
	jp COMBAT_MAIN					;and jump back to COMBAT_MAIN
	
COMBAT_CURSOR_TEST3:
	cp 2
	jr nz, COMBAT_CURSOR_TEST4		;if the cursor state != 2, then jump to COMBAT_CURSOR_TEST4
	
	ld a, 32
	ld [CURSOR_X], a
	ld a, 144
	ld [CURSOR_Y], a				;else, set the cursor x,y so that it points to Items
	jp COMBAT_MAIN					;and jump back to COMBAT_MAIN
	
COMBAT_CURSOR_TEST4:
	ld a, 96
	ld [CURSOR_X], a
	ld a, 144
	ld [CURSOR_Y], a				;else, set the cursor x,y so that it points to Escape
	jp COMBAT_MAIN					;and jump back to COMBAT_MAIN

COMBAT_ATTACK::
	ld [NEW_TILES+4], a				;load into NEW+TILES+4 the attack the player is using so that we can later use this value again
	ld b, a							
	
	xor a							;move the cursor to 0,0 so that it can't be seen
	ld [CURSOR_X], a
	ld [CURSOR_Y], a
	
	ld a, BANK_ITEMDB				;set the current bank to bank 7 so that we can get move data
	ld [$2000], a
	
	ld a, b
	or a							;if the move the player is using != 0
	jr nz, PLAYER_MOVE_GET_DATA		;then jump to PLAYER_MOVE_GET_DATA
	ld b, %00000011					;else load into b the data for a normal attack
	ld a, [CALC_ATTACK]
	ld c, a							;and store the player's attack in c
	jr COMBAT_ATTACK_ENEMY_GEN		;then jump to COMBAT_ATTACK_ENEMY_GEN
PLAYER_MOVE_GET_DATA:	
	dec a
	ld e, a
	ld d, 0
	ld b, 8
	ld c, MOVE_LENGTH
	ld hl, MoveData
	call Multiply					;hl = MoveData + (MoveNo-1)*MOVE_LENGTH, so it points to the move referenced
	
	ld de, 10
	add hl, de						;add 10 so that we skip over the move name and get the data about the move
	ld a, [hl+]
	ld b, a							;load the data about the move into b
	ld a, [hl]
	ld c, a							;and the change in stat into c
	
COMBAT_ATTACK_ENEMY_GEN:
	ld a, b
	ld [NEW_TILES], a				;load the data about the move into NEW_TILES
	ld a, c
	ld [NEW_TILES+1], a				;and the change in stat in NEW_TILES+1

	call COMBAT_ENEMY_ATTACK_GENERATE	;then generate an attack for the enemy (stored in NEW_TILES+2,+3 and +5)
	
COMBAT_ATTACK_FAST:
	ld a, [CALC_SPEED]
	ld b, a
	ld a, [ENEMY_SPEED]
	cp b
	jr c, COMBAT_PLAYER_FIRST			;if the player speed is >= enemy speed, then jump to COMBAT_PLAYER_FIRST
	jr z, COMBAT_PLAYER_FIRST
;enemy_first
	call COMBAT_ENEMY_TURN				;else the enemy is faster so take the enemy turn first
	call COMBAT_PLAYER_TURN
	jp COMBAT_MAIN_INIT

COMBAT_PLAYER_FIRST:
	call COMBAT_PLAYER_TURN
	call COMBAT_ENEMY_TURN
	jp COMBAT_MAIN_INIT 

COMBAT_PLAYER_TURN::
	ld a, [NEW_TILES]					;Load into a the data about the move the player is using
	bit 0, a							;If the move the player is using doesn't affect health
	jr z, COMBAT_PLAYER_TURN_CHANGE		;then jump COMBAT_PLAYER_TURN_CHANGE
	bit 7, a							;If the move the player is using is targeting the player
	jr nz, COMBAT_PLAYER_TURN_CHANGE	;then jump to COMBAT_PLAYER_TURN_CHANGE
										;Else, the move the player is using
	ld a, [ENEMY_DEFENCE]
	ld d, a								;Load ENEMY_DEFENCE into d in preparation for damage calculations
	ld a, [CALC_ATTACK]
	ld c, a								;Load player attack into c in preparation for damage calculations
	ld a, [NEW_TILES]					
	bit 1, a							;If bit 1 is set, then the move is physical, so jump to 
	jr nz, COMBAT_PLAYER_TURN_DMG_CALC	;COMBAT_PLAYER_TURN_DMG_CALC and keep ENEMY_DEFENCE and player attack
	
	ld a, [ENEMY_MAGIC_DEFENCE]			;Else the move is magic, so load ENEMY_MAGIC_DEFENCE into d
	ld d, a
	ld a, [CALC_MAGIC_ATTACK]			;As the move is magic, use the players magic attack instead of attack
	ld c, a
COMBAT_PLAYER_TURN_DMG_CALC:	
	ld a, [NEW_TILES+1]
	ld b, a								;Load the move dmg into b in preparation for damage calculations

	DamageCalc							;The user defined macro DamageCalc defines how damage done is calculated
										;The result is stored in a
	ld [NEW_TILES+1], a					;Replace the damage done with the value calculated
	
COMBAT_PLAYER_TURN_CHANGE:
	ld a, [NEW_TILES]					
	bit 7, a							;If the move the player is using targets the enemy
	jr z, COMBAT_PLAYER_TURN_ENEMY_AFFECTED ;then jump to COMBAT_PLAYER_TURN_ENEMY_AFFECTED
	
	ld hl, HEALTH 
	bit 0, a								;If the move the player is using will cause a change in health
	jr nz, COMBAT_PLAYER_TURN_STAT_CHANGE	;then jump to COMBAT_PLAYER_TURN_STAT_CHANGE
	ld hl, CALC_MAXHEALTH					;Else, the stat to change is near CALC_MAXHEALTH, so load that into hl
	jr COMBAT_PLAYER_TURN_STAT_CHANGE		;and jump to COMBAT_PLAYER_TURN_STAT_CHANGE 
	
COMBAT_PLAYER_TURN_ENEMY_AFFECTED:
	ld hl, ENEMY_HEALTH

COMBAT_PLAYER_TURN_STAT_CHANGE:
	;hl now points to either enemy_health, calc_maxhealth or health, so we can now inc hl by an amount to get to the right stat
	and %00111111							;now the only bits set are those corresponding to the stats
.loop:										;this loop shifts a right and increments hl until hl points to the correct stat
	bit 0, a
	jr nz, .loop_escape
	sra a
	inc hl					
	jr .loop
.loop_escape:	
	push hl									
	ld a, [hl]								;load into a the stat to change
	ld h, 0
	ld l, a
	
	ld a, [NEW_TILES]
	ld b, a									;Load into b the player's move data
	ld a, [NEW_TILES+1]
	ld d, 0
	ld e, a									;Load into de the move damage
	
	bit 6, b								;if bit 6 isn't set, then the move causes a decrease in a stat,
	jr z, COMBAT_PLAYER_TURN_DECREASING		;so jump to COMBAT_PLAYER_TURN_DECREASING
	
	bit 0, b								;if bit 0 = 1, then we need to check if the increase in health will cause health > max health 
	jr z, COMBAT_ADD_STAT					;so if bit 0 = 0, then skip that check and jump to COMBAT_ADD_STAT
	
	bit 7, b								;if bit 7 = 0, then we need to check the enemy health instead of the player health
	jr z, COMBAT_PLAYER_ENEMY_HEALTH_CHECK	;so jump to COMBAT_PLAYER_ENEMY_HEALTH_CHECK

COMBAT_PLAYER_HEALTH_CHECK:
	;compare change in health with max health - current health
	;if change in health is greater than max health - current health, the change in health = max health - current health
	push hl
	push de
	
	ld a, [CALC_MAXHEALTH]
	ld e, a
	ld d, 0					;de = max health
	ld a, h					;we want to calculate max health - current health, so as hl contains current health we need to set it to be -ve
	cpl						;so we complement h and l and then add 1
	ld h, a					
	ld a, l
	cpl
	ld l, a
	inc hl
	add hl, de				;hl now contains max health - current health
	ld b, l
	pop de
	pop hl
	ld a, [NEW_TILES+1]		;load into a the change in stat  
	cp b					;if the change in stat is less than or equal to max health - current health
	jr c, COMBAT_ADD_STAT	;then jump to COMBAT_ADD_STAT
	jr z, COMBAT_ADD_STAT	
	
	ld a, b					;else change in stat = max health - current health
	ld [NEW_TILES+1], a
	ld d, 0
	ld e, a
	jr COMBAT_ADD_STAT
	
COMBAT_PLAYER_ENEMY_HEALTH_CHECK:
	push hl
	push de
	
	ld a, [ENEMY_MAXHEALTH]
	ld e, a
	ld d, 0					;de = max health
	ld a, h					;we want to calculate max health - current health, so as hl contains current health we need to set it to be -ve
	cpl						;so we complement h and l and then add 1
	ld h, a
	ld a, l
	cpl
	ld l, a
	inc hl
	add hl, de				;hl now contains max health - current health
	ld b, l
	pop de
	pop hl
	ld a, [NEW_TILES+1]		;load into a the change in stat  
	cp b					;compare with max health - current health
	jr c, COMBAT_ADD_STAT	;if the change in stat is less than or equal to max health - current health
	jr z, COMBAT_ADD_STAT	;then jump to COMBAT_ADD_STAT
	
	ld a, b					;else change in stat = max health - current health
	ld [NEW_TILES+1], a		
	ld d, 0
	ld e, a
	
COMBAT_ADD_STAT:	
	add hl, de				;add the current stat and the change in stat
	ld a, h
	cp 1									;if h != 1, then l did not overflow
	jr nz, COMBAT_PLAYER_TURN_OUTPUT_INIT	;so jump to COMBAT_PLAYER_TURN_OUTPUT_INIT
	ld hl, 255								;else l did overflow, so set hl to 255
	jr COMBAT_PLAYER_TURN_OUTPUT_INIT
	
COMBAT_PLAYER_TURN_DECREASING:
	ld a, d									;as the change in stat is stored as an absolute value, we have to set it to negative
	cpl 									;so we complement de and then add 1
	ld d, a
	ld a, e
	cpl
	ld e, a
	inc de
	add hl, de								;stat = stat - change in stat
	ld a, h
	cp $FF									;if h !=FF, the l did not underflow
	jr nz, COMBAT_PLAYER_TURN_OUTPUT_INIT	;so jump to COMBAT_PLAYER_TURN_OUTPUT_INIT
	ld hl, 0								;else l did underflow, so set hl to 0
	jr COMBAT_PLAYER_TURN_OUTPUT_INIT
	
COMBAT_PLAYER_TURN_OUTPUT_INIT:	
	ld a, l									;load into a the result of the calculation
	pop hl									;get the stat memory location from the stack
	ld [hl], a								;and load the new value for the stat into memory

	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld a, [NEW_TILES+4]						;load into a the move no
	or a
	jr z,  COMBAT_PLAYER_ATTACKED			;if the move no is 0, then jump to COMBAT_PLAYER_ATTACKED
	
	ld de, YouUse							;Else we want to output "You use ",MoveName
	ld b, 8
	ld hl, RAM_MESSAGE
USE_COPY:									;Copy "You use " into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, USE_COPY
	
	ld a, BANK_ITEMDB						;set the current bank to bank 7 as it contains the move data and we need the move names
	ld [$2000], a
	
	push hl									;push hl so that we keep our place in RAM_MESSAGE
	ld a, [NEW_TILES+4]						;load into a the move no 
	dec a									;We want hl to point to the move referenced
	ld b, 8									;So we want hl to contain MoveData + MOVE_LENGTH(MoveNo-1)
	ld c, a
	ld hl, MoveData
	ld de, MOVE_LENGTH
	call Multiply							
	ld d, h									;hl now points to the move referenced, 
	ld e, l									;so load hl into de as hl needs to contain our location in RAM_MESSAGE
	pop hl									

	ld b, 10
MOVE_NAME_COPY:								;copy the move name into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, MOVE_NAME_COPY
	
	jr COMBAT_USE_OR_ATTACK_OUT
	
COMBAT_PLAYER_ATTACKED:
	ld de, YouAttacked
	ld b, 18
	ld hl, RAM_MESSAGE
MSG_COPY:									;Adds "You attacked the " to RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, MSG_COPY
	
	push hl									;push hl so that we can keep our place in RAM_MESSAGE
	ld a, BANK_COMBAT						;set the current bank to bank 6 so that we can get the enemy name
	ld [$2000], a
	
	ld a, [ENEMY_NO]
	dec a
	ld hl, EnemyData
	ld b, 8
	ld c, ENEMY_LENGTH
	ld d, 0
	ld e, a
	call Multiply							;hl = EnemyData + ENEMY_LENGTH(ENEMY_NO-1), so hl points to the enemy referenced
	ld d, h
	ld e, l
	pop hl
	ld b, 10
	
COMBAT_NAME_COPY:							;copies the enemy name into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_NAME_COPY

COMBAT_USE_OR_ATTACK_OUT:
	ld a, $80								;add the null terminator at the end of the message
	ld [hl], a

	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT			;Outputs "You attacked" or "You used",MoveName
	
.loop:							;Loops until the player presses a or b
	halt
	call READ_JOYPAD
	ld a, [joypad_down]
	and %00000011
	or a			
	jr z, .loop
	
COMBAT_STAT_CHANGED_BY:
	;need to split into 4 branches here based on if the target is you or the enemy and based on if stats rise or fall
	;Due to similarities in the messages output, we split once for target then again for stats
	
	call RAM_MESSAGE_CLEAR
	
	ld a, BANK_STRING				;Sets the current bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	ld a, [NEW_TILES]					;Load into a the data about the move the player is using
	bit 7, a							;If bit 7 = 0, then the enemy stats are changing, not the players
	jr z, COMBAT_STAT_CHANGED_BY_ENEMY	;so jump to COMBAT_STAT_CHANGED_BY_ENEMY
	
	;As the player stats rising or falling are the same length, we can insert the stat name into RAM_MESSAGE at this point
	ld a, [NEW_TILES]								;Load into a the data about the move the player is using
	ld hl, RAM_MESSAGE+5
	ld de, HealthShort
	bit 0, a										;if bit 0 = 1, then the move causes a change in health,
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME	;so jump to COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
	ld de, AttackShort								;else see if it causes a change in attack
	bit 1, a
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
	ld de, DefenceShort
	bit 2, a
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
	ld de, MagicAttackShort
	bit 3, a
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME	
	ld de, MagicDefenceShort
	bit 4, a
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
	ld de, SpeedShort
	bit 5, a
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME:			;Copies the stat names into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	ld a, [de]										
	cp 128											;As the stat names are null terminated, if the next character is not null
	jr nz, COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME	;then we are not at the end of the name, so jump to COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
	
	ld a, [NEW_TILES]								;Load into a the data about the move the player is using
	bit 6, a										;If bit 6 = 0, then the move used causes a decrease in stat, 
	jr z, COMBAT_PLAYER_STAT_FELL					;so jump to COMBAT_PLAYER_STAT_FELL
	
	ld hl, YourStatRoseBy							;Else, load a different value into hl and then jump to COMBAT_PLAYER_STAT_COPY1
	ld de, RAM_MESSAGE								;We can reuse the same code for outputting if the stat fell or rose as
	ld b, 5											;they are the same length
	jr COMBAT_PLAYER_STAT_COPY1
	
COMBAT_PLAYER_STAT_FELL:
	ld hl, YourStatFellBy
	ld de, RAM_MESSAGE
	ld b, 5
	
COMBAT_PLAYER_STAT_COPY1:							;Copies the "Your " section of the message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_PLAYER_STAT_COPY1
	
	ld b, 8
	ld de, RAM_MESSAGE+8							
	ld a, [RAM_MESSAGE+7]							;Last position in RAM_MESSAGE to be written to if the stat written was hp
	or a											;If there is nothing for the third character of the stat name, then
	jr z, COMBAT_PLAYER_STAT_COPY2					;we continue output at RAM_MESSAGE+8
	ld de, RAM_MESSAGE+9
	ld a, [RAM_MESSAGE+8]
	or a											;Else if there is nothing for the 4th character of the stat name, then
	jr z, COMBAT_PLAYER_STAT_COPY2					;we continue output at RAM_MESSAGE+9
	ld de, RAM_MESSAGE+13							;Else, the stat is mg atk or mg def, so to not overwrite their text,
													;we continue output at RAM_MESSAGE+11
COMBAT_PLAYER_STAT_COPY2:							;Copies the rest of the output message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_PLAYER_STAT_COPY2
	jp UPDATE_HP_OUT
	
COMBAT_STAT_CHANGED_BY_ENEMY:
	;As the enemy stats rising or falling are the same length, we can insert the stat name into RAM_MESSAGE at this point
	ld a, [NEW_TILES]						;Load into a the data about the move the player is using
	ld hl, RAM_MESSAGE+18					;load into hl the point to output the stat name
	ld de, HealthShort
	bit 0, a								;if bit 0 = 1, then the move causes a change in health,
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME;so jump to COMBAT_PLAYER_STAT_CHANGE_STAT_COPY_NAME
	ld de, AttackShort						;else see if it causes a change in attack
	bit 1, a
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME
	ld de, DefenceShort
	bit 2, a
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME
	ld de, MagicAttackShort
	bit 3, a
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME	
	ld de, MagicDefenceShort
	bit 4, a
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME
	ld de, SpeedShort
	bit 5, a
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME						

COMBAT_STAT_CHANGE_STAT_COPY_NAME:			;Copies the stat name into memory
	ld a, [de]
	ld [hl+], a
	inc de
	ld a, [de]
	cp 128
	jr nz, COMBAT_STAT_CHANGE_STAT_COPY_NAME

	;Next we need to insert enemy name into RAM_MESSAGE
	
	ld a, BANK_COMBAT						;Set the current bank to bank 6 so that we can get the enemy name
	ld [$2000], a
	
	ld a, [ENEMY_NO]						;We want hl to point to the enemy referenced
	dec a									;So we want hl to contain EnemyData + ENEMY_LENGTH(ENEMY_NO-1)
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ENEMY_LENGTH
	ld hl, EnemyData
	call Multiply
	
	ld b, 10
	ld de, RAM_MESSAGE+4					;Load into de the part in RAM_MESSAGE to output the enemy name
.loop:										;Copy the enemy name into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, .loop
	
	;stat name and enemy name are now inserted into RAM_MESSAGE, now we need to put the message around it
	
	ld a, BANK_STRING						;Set the current bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	ld a, [NEW_TILES]						;Load into a the data about the move the player used
	bit 6, a								;If bit 6 = 0, then the move causes a decrease in a stat
	jr z, COMBAT_STAT_ENEMY_FELL			;so jump to COMBAT_STAT_ENEMY_FELL
	
	
COMBAT_STAT_ENEMY_ROSE:
	ld hl, TheEnemyStatRoseBy				;Else, load a different value into hl and then jump to COMBAT_PLAYER_STAT_COPY1
	ld de, RAM_MESSAGE						;We can reuse the same code for outputting if the stat fell or rose as
	ld b, 4									;they are the same length
	jr COMBAT_STAT_ENEMY_FELL_COPY1
	
COMBAT_STAT_ENEMY_FELL:
	ld hl, TheEnemyStatFellBy
	ld de, RAM_MESSAGE
	ld b, 4
COMBAT_STAT_ENEMY_FELL_COPY1:				;Copies "The " into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_STAT_ENEMY_FELL_COPY1
	
	ld a, e									;Increments de so that it points to the last character in the enemy name
	add 9
	ld e, a
	ld a, d									;add 9 set the carry flag if it caused an overflow
	adc 0									;so add with carry will add the overflow to d, causing de to increment by 9
	ld d, a
	
.loop:										;Decrements de until it finds a character that isn't a space
											;This is so that if an enemy name is padded with spaces then we can still
											;have "'s" after the enemy name without akward spacing issues
	ld a, [de]
	cp $81									;if the current character isn't a space
	jr nz, COMBAT_STAT_ENEMY_CONTINUE		;then jump to COMBAT_STAT_ENEMY_CONTINUE
	dec de
	jr .loop								;else, dec de and jump to .loop
	
	
COMBAT_STAT_ENEMY_CONTINUE:					;Continues to copy the message into RAM_MESSAGE
	inc de									;increment de so that we don't overwrite the first non space character
	ld a, [hl+]								;Copies the "'s" into RAM_MESSAGE
	ld [de], a								;If this were done as a loop, it would only run 2 times, so the loop has been unrolled
	inc de
	ld a, [hl+]
	ld [de], a
	inc de
	
	ld b, 9
	ld de, RAM_MESSAGE+24
	ld a, [RAM_MESSAGE+23]
	or a									;if the stat name meant that the 24th character has been filled,
	jr nz, COMBAT_STAT_ENEMY_FELL_COPY2		;then jump to COMBAT_STAT_ENEMY_FELL_COPY2 and continue output from RAM_MESSAGE+24
	ld de, RAM_MESSAGE+21
	ld a, [RAM_MESSAGE+20]
	or a									;else if the stat name meant that the 21st character has been filled,
	jr nz, COMBAT_STAT_ENEMY_FELL_COPY2		;then jump to COMBAT_STAT_ENEMY_FELL_COPY2 and continue output from RAM_MESSAGE+21
	ld de, RAM_MESSAGE+20					;else the stat name is 2 characters long, so continue output from RAM_MESSAGE+20
	
COMBAT_STAT_ENEMY_FELL_COPY2:				;copies the last part of the message
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_STAT_ENEMY_FELL_COPY2	
	
UPDATE_HP_OUT:
	push de						;push the current position in RAM_MESSAGE
	
	ld a, [NEW_TILES+1]			;Load the change in stat caused by the player into the stat and then convert it
	ld [input], a
	ld bc, $0A00
	call DIVIDE					;divide a by 10 and store the result in c. This is necessary for the bcd function to work
	ld a, [input]				;reload the input into a 
	call BcdConvert_init
	
	pop de
	ld a, [upper_result]
	and $0F
	add $91						;add $91 so that a contains the tile reference for that number
	ld [de], a					;load the tile into [de]
	inc de
	
	ld a, [lower_result]
	and $F0
	swap a						;and $F0 and swap so that we are only dealing with the number in the top half
	add $91
	ld [de], a
	inc de
	
	ld a, [lower_result]
	and $0F
	add $91
	ld [de], a
	inc de
	
	ld a, $80
	ld [de], a					;add the null terminator to the end of the message
								;the change in stat and the message have been put into RAM_MESSAGE, so we can now output it
								
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT			;Output the message
	
	call COMBAT_UPDATE_HEALTH
	
WAIT_A_LOOP:
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	ld a, [ENEMY_HEALTH]
	or a							;If the enemy's health is 0
	jp z, COMBAT_END_ENEMY			;then jump to COMBAT_END_ENEMY
	ret								;else, return

	
COMBAT_ENEMY_TURN::
	ld a, [NEW_TILES+2]					;Load into a the data about the move the player is using
	bit 0, a							;If the move the player is using doesn't affect health
	jr z, COMBAT_ENEMY_TURN_CHANGE		;then jump COMBAT_ENEMY_TURN_CHANGE
	bit 7, a							;If the move the player is using is targeting the player
	jr z, COMBAT_ENEMY_TURN_CHANGE		;then jump to COMBAT_ENEMY_TURN_CHANGE
										;Else, the move the player is using
	ld a, [CALC_DEFENCE]
	ld d, a								;Load CALC_DEFENCE into d in preparation for damage calculations
	ld a, [ENEMY_ATTACK]
	ld c, a								;Load enemy attack into c in preparation for damage calculations
	ld a, [NEW_TILES+2]					
	bit 1, a							;If bit 1 is set, then the move is physical, so jump to 
	jr nz, COMBAT_ENEMY_TURN_DMG_CALC	;COMBAT_ENEMY_TURN_DMG_CALC and keep CALC_DEFENCE and enemy attack
	
	ld a, [CALC_MAGIC_DEFENCE]			;Else the move is magic, so load CALC_MAGIC_DEFENCE into d
	ld d, a
	ld a, [ENEMY_MAGIC_ATTACK]			;As the move is magic, use the enemy magic attack instead of attack
	ld c, a
COMBAT_ENEMY_TURN_DMG_CALC:	
	ld a, [NEW_TILES+3]
	ld b, a								;Load the move dmg into b in preparation for damage calculations

	EnemyDamageCalc						;The user defined macro EnemyDamageCalc defines how damage done is calculated
										;The result is stored in a
	ld [NEW_TILES+3], a					;Replace the damage done with the value calculated
	
COMBAT_ENEMY_TURN_CHANGE:
	ld a, [NEW_TILES+2]					
	bit 7, a							   ;If the move the enemy is using targets the enemy
	jr z, COMBAT_ENEMY_TURN_ENEMY_AFFECTED ;then jump to COMBAT_ENEMY_TURN_ENEMY_AFFECTED
	
	ld hl, HEALTH 
	bit 0, a								;If the move the enemy is using will cause a change in health
	jr nz, COMBAT_ENEMY_TURN_STAT_CHANGE	;then jump to COMBAT_ENEMY_TURN_STAT_CHANGE
	ld hl, CALC_MAXHEALTH					;Else, the stat to change is near CALC_MAXHEALTH, so load that into hl
	jr COMBAT_ENEMY_TURN_STAT_CHANGE		;and jump to COMBAT_ENEMY_TURN_STAT_CHANGE 
	
COMBAT_ENEMY_TURN_ENEMY_AFFECTED:
	ld hl, ENEMY_HEALTH

COMBAT_ENEMY_TURN_STAT_CHANGE:
	;hl now points to either enemy_health, calc_maxhealth or health, so we can now inc hl by an amount to get to the right stat
	and %00111111							;now the only bits set are those corresponding to the stats
.loop:										;this loop shifts a right and increments hl until hl points to the correct stat
	bit 0, a
	jr nz, .loop_escape
	sra a
	inc hl					
	jr .loop
.loop_escape:	
	push hl									
	ld a, [hl]								;load into a the stat to change
	ld h, 0
	ld l, a
	
	ld a, [NEW_TILES+2]
	ld b, a									;Load into b the enemy's move data
	ld a, [NEW_TILES+3]
	ld d, 0
	ld e, a									;Load into de the move damage
	
	bit 6, b								;if bit 6 isn't set, then the move causes a decrease in a stat,
	jr z, COMBAT_ENEMY_TURN_DECREASING		;so jump to COMBAT_ENEMY_TURN_DECREASING
	
	bit 0, b								;if bit 0 = 1, then we need to check if the increase in health will cause health > max health 
	jr z, COMBAT_ENEMY_ADD_STAT				;so if bit 0 = 0, then skip that check and jump to COMBAT_ENEMY_ADD_STAT
	
	bit 7, b								;if bit 7 = 0, then we need to check the enemy health instead of the player health
	jr z, COMBAT_ENEMY_ENEMY_HEALTH_CHECK	;so jump to COMBAT_ENEMY_ENEMY_HEALTH_CHECK

COMBAT_ENEMY_HEALTH_CHECK:
	;compare change in health with max health - current health
	;if change in health is greater than max health - current health, the change in health = max health - current health
	push hl
	push de
	
	ld a, [CALC_MAXHEALTH]
	ld e, a
	ld d, 0					;de = max health
	ld a, h					;we want to calculate max health - current health, so as hl contains current health we need to set it to be -ve
	cpl						;so we complement h and l and then add 1
	ld h, a					
	ld a, l
	cpl
	ld l, a
	inc hl
	add hl, de				;hl now contains max health - current health
	ld b, l
	pop de
	pop hl
	ld a, [NEW_TILES+3]		;load into a the change in stat  
	cp b					;if the change in stat is less than or equal to max health - current health
	jr c, COMBAT_ENEMY_ADD_STAT	;then jump to COMBAT_ENEMY_ADD_STAT
	jr z, COMBAT_ENEMY_ADD_STAT	
	
	ld a, b					;else change in stat = max health - current health
	ld [NEW_TILES+3], a
	ld d, 0
	ld e, a
	jr COMBAT_ENEMY_ADD_STAT
	
COMBAT_ENEMY_ENEMY_HEALTH_CHECK:
	push hl
	push de
	
	ld a, [ENEMY_MAXHEALTH]
	ld e, a
	ld d, 0					;de = max health
	ld a, h					;we want to calculate max health - current health, so as hl contains current health we need to set it to be -ve
	cpl						;so we complement h and l and then add 1
	ld h, a
	ld a, l
	cpl
	ld l, a
	inc hl
	add hl, de				;hl now contains max health - current health
	ld b, l
	pop de
	pop hl
	ld a, [NEW_TILES+3]		;load into a the change in stat  
	cp b					;compare with max health - current health
	jr c, COMBAT_ENEMY_ADD_STAT	;if the change in stat is less than or equal to max health - current health
	jr z, COMBAT_ENEMY_ADD_STAT	;then jump to COMBAT_ENEMY_ADD_STAT
	
	ld a, b					;else change in stat = max health - current health
	ld [NEW_TILES+3], a		
	ld d, 0
	ld e, a
	
COMBAT_ENEMY_ADD_STAT:	
	add hl, de				;add the current stat and the change in stat
	ld a, h
	cp 1									;if h != 1, then l did not overflow
	jr nz, COMBAT_ENEMY_TURN_OUTPUT_INIT	;so jump to COMBAT_ENEMY_TURN_OUTPUT_INIT
	ld hl, 255								;else l did overflow, so set hl to 255
	jr COMBAT_ENEMY_TURN_OUTPUT_INIT
	
COMBAT_ENEMY_TURN_DECREASING:
	ld a, d									;as the change in stat is stored as an absolute value, we have to set it to negative
	cpl 									;so we complement de and then add 1
	ld d, a
	ld a, e
	cpl
	ld e, a
	inc de
	add hl, de								;stat = stat - change in stat
	ld a, h
	cp $FF									;if h !=FF, the l did not underflow
	jr nz, COMBAT_ENEMY_TURN_OUTPUT_INIT	;so jump to COMBAT_ENEMY_TURN_OUTPUT_INIT
	ld hl, 0								;else l did underflow, so set hl to 0
	jr COMBAT_ENEMY_TURN_OUTPUT_INIT
	
COMBAT_ENEMY_TURN_OUTPUT_INIT:	
	ld a, l									;load into a the result of the calculation
	pop hl									;get the stat memory location from the stack
	ld [hl], a								;and load the new value for the stat into memory

	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	call RAM_MESSAGE_CLEAR
	
	ld a, [NEW_TILES+5]						;load into a the move no
	or a
	jr z,  COMBAT_ENEMY_ATTACKED			;if the move no is 0, then jump to COMBAT_ENEMY_ATTACKED
	
	ld de, TheEnemyUsed						;Else we want to output "The ",EnemyName," used ", MoveName
	ld b, 4
	ld hl, RAM_MESSAGE
COMBAT_ENEMY_USE_COPY:						;Copy "The " into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_USE_COPY
	
	ld a, BANK_COMBAT						;set the current bank to bank 6 so that we can get the enemy name
	ld [$2000], a
	
	ld d, h									;ld hl into de so that our place in RAM_MESSAGE is not lost
	ld e, l									;and so that hl can be used to calculate the memory location of the enemy name
	push de
	ld a, [ENEMY_NO]
	dec a
	ld hl, EnemyData
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ENEMY_LENGTH
	call Multiply
	pop de
	
	ld b, 10
COMBAT_ENEMY_USE_NAME_COPY:					;Copies the enemy name into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_USE_NAME_COPY 
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld h, d									;load de into hl so that hl now contains our position in RAM_MESSAGE
	ld l, e									
	ld de, TheEnemyUsed+3					;load into de the memory location to continue copying from
	ld b, 6
	dec hl
.loop:										;Decrements de until it finds a character that isn't a space
	ld a, [hl]
	inc hl
	cp $81								;if the current character isn't a space
	jr nz, COMBAT_ENEMY_USE_COPY2		;then jump to COMBAT_ENEMY_USE_COPY2
	dec hl
	dec hl
	jr .loop
	
COMBAT_ENEMY_USE_COPY2:									;Copy " used " into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_USE_COPY2
	
	ld a, BANK_ITEMDB						;set the current bank to bank 7 as it contains the move data and we need the move names
	ld [$2000], a
	
	push hl									;push hl so that we keep our place in RAM_MESSAGE
	ld a, [NEW_TILES+5]						;load into a the move no 
	dec a									;We want hl to point to the move referenced
	ld b, 8									;So we want hl to contain MoveData + MOVE_LENGTH(MoveNo-1)
	ld c, a
	ld hl, MoveData
	ld de, MOVE_LENGTH
	call Multiply							
	ld d, h									;hl now points to the move referenced, 
	ld e, l									;so load hl into de as hl needs to contain our location in RAM_MESSAGE
	pop hl									

	ld b, 10
COMBAT_ENEMY_MOVE_NAME_COPY:								;copy the move name into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_MOVE_NAME_COPY
	
	jr COMBAT_ENEMY_USE_OR_ATTACK_OUT
	
COMBAT_ENEMY_ATTACKED:
	ld de, TheEnemyAttacked
	ld b, 4
	ld hl, RAM_MESSAGE
COMBAT_ENEMY_MSG_COPY:									;Adds "You attacked the " to RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_MSG_COPY
	
	push hl									;push hl so that we can keep our place in RAM_MESSAGE
	ld a, BANK_COMBAT						;set the current bank to bank 6 so that we can get the enemy name
	ld [$2000], a
	
	ld a, [ENEMY_NO]
	dec a
	ld hl, EnemyData
	ld b, 8
	ld c, ENEMY_LENGTH
	ld d, 0
	ld e, a
	call Multiply							;hl = EnemyData + ENEMY_LENGTH(ENEMY_NO-1), so hl points to the enemy referenced
	ld d, h
	ld e, l
	pop hl
	ld b, 10
	
COMBAT_ENEMY_NAME_COPY:							;copies the enemy name into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_NAME_COPY
	
	dec hl										;dec hl so that we point to the last character output
.loop:											;decrements hl until it points to a non space character
	ld a, [hl]
	cp $81
	jr nz, COMBAT_ENEMY_MSG_COPY2_INIT
	dec hl
	jr .loop
	
COMBAT_ENEMY_MSG_COPY2_INIT:
	ld a, BANK_STRING
	ld [$2000], a

	inc hl										;inc hl twice so that hl doesn't overwrite the current [hl], or the space after it
	inc hl										
	ld b, 8										
	ld de, TheEnemyAttacked+4					;load into de the point in memory to continue copying from
	
COMBAT_ENEMY_MSG_COPY2:
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_MSG_COPY2
	
COMBAT_ENEMY_USE_OR_ATTACK_OUT:
	ld a, $80								;add the null terminator at the end of the message
	ld [hl], a

	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT			;Outputs "The ",EnemyName," attacked" or "The ",EnemyName," used ",MoveName
	
.loop:							;Loops until the player presses a or b
	halt
	call READ_JOYPAD
	ld a, [joypad_down]
	and %00000011
	or a			
	jr z, .loop
	
COMBAT_ENEMY_STAT_CHANGED_BY:
	;need to split into 4 branches here based on if the target is you or the enemy and based on if stats rise or fall
	;Due to similarities in the messages output, we split once for target then again for stats
	
	call RAM_MESSAGE_CLEAR
	
	ld a, BANK_STRING				;Sets the current bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	ld a, [NEW_TILES+2]					;Load into a the data about the move the enemy is using
	bit 7, a							;If bit 7 = 0, then the enemy stats are changing, not the players
	jr z, COMBAT_ENEMY_STAT_CHANGED_BY_ENEMY	;so jump to COMBAT_ENEMY_STAT_CHANGED_BY_ENEMY
	
	;As the player stats rising or falling are the same length, we can insert the stat name into RAM_MESSAGE at this point
	ld a, [NEW_TILES+2]								;Load into a the data about the move the enemy is using
	ld hl, RAM_MESSAGE+5
	ld de, HealthShort
	bit 0, a										;if bit 0 = 1, then the move causes a change in health,
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME	;so jump to COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, AttackShort								;else see if it causes a change in attack
	bit 1, a
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, DefenceShort
	bit 2, a
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, MagicAttackShort
	bit 3, a
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME	
	ld de, MagicDefenceShort
	bit 4, a
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, SpeedShort
	bit 5, a
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME
COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME:			;Copies the stat names into RAM_MESSAGE
	ld a, [de]
	ld [hl+], a
	inc de
	ld a, [de]										
	cp 128											;As the stat names are null terminated, if the next character is not null
	jr nz, COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME	;then we are not at the end of the name, so jump to COMBAT_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	
	ld a, [NEW_TILES+2]								;Load into a the data about the move the enemy is using
	bit 6, a										;If bit 6 = 0, then the move used causes a decrease in stat, 
	jr z, COMBAT_ENEMY_STAT_FELL					;so jump to COMBAT_ENEMY_STAT_FELL
	
	ld hl, YourStatRoseBy							;Else, load a different value into hl and then jump to COMBAT_ENEMY_STAT_COPY1
	ld de, RAM_MESSAGE								;We can reuse the same code for outputting if the stat fell or rose as
	ld b, 5											;they are the same length
	jr COMBAT_ENEMY_STAT_COPY1
	
COMBAT_ENEMY_STAT_FELL:
	ld hl, YourStatFellBy
	ld de, RAM_MESSAGE
	ld b, 5
	
COMBAT_ENEMY_STAT_COPY1:							;Copies the "Your " section of the message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_STAT_COPY1
	
	ld b, 8
	ld de, RAM_MESSAGE+8							
	ld a, [RAM_MESSAGE+7]							;Last position in RAM_MESSAGE to be written to if the stat written was hp
	or a											;If there is nothing for the third character of the stat name, then
	jr z, COMBAT_ENEMY_STAT_COPY2					;we continue output at RAM_MESSAGE+8
	ld de, RAM_MESSAGE+9
	ld a, [RAM_MESSAGE+8]
	or a											;Else if there is nothing for the 4th character of the stat name, then
	jr z, COMBAT_ENEMY_STAT_COPY2					;we continue output at RAM_MESSAGE+9
	ld de, RAM_MESSAGE+11							;Else, the stat is mg atk or mg def, so to not overwrite their text,
													;we continue output at RAM_MESSAGE+11
COMBAT_ENEMY_STAT_COPY2:							;Copies the rest of the output message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_STAT_COPY2
	jp COMBAT_ENEMY_UPDATE_HP_OUT
	
COMBAT_ENEMY_STAT_CHANGED_BY_ENEMY:
	;As the enemy stats rising or falling are the same length, we can insert the stat name into RAM_MESSAGE at this point
	ld a, [NEW_TILES+2]						;Load into a the data about the move the enemy is using
	ld hl, RAM_MESSAGE+18					;load into hl the point to output the stat name
	ld de, HealthShort
	bit 0, a								;if bit 0 = 1, then the move causes a change in health,
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME;so jump to COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, AttackShort						;else see if it causes a change in attack
	bit 1, a
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, DefenceShort
	bit 2, a
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, MagicAttackShort
	bit 3, a
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME	
	ld de, MagicDefenceShort
	bit 4, a
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME
	ld de, SpeedShort
	bit 5, a
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME						

COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME:			;Copies the stat name into memory
	ld a, [de]
	ld [hl+], a
	inc de
	ld a, [de]
	cp 128
	jr nz, COMBAT_ENEMY_ENEMY_STAT_CHANGE_STAT_COPY_NAME

	;Next we need to insert enemy name into RAM_MESSAGE
	
	ld a, BANK_COMBAT						;Set the current bank to bank 6 so that we can get the enemy name
	ld [$2000], a
	
	ld a, [ENEMY_NO]						;We want hl to point to the enemy referenced
	dec a									;So we want hl to contain EnemyData + ENEMY_LENGTH(ENEMY_NO-1)
	ld d, 0
	ld e, a
	ld b, 8
	ld c, ENEMY_LENGTH
	ld hl, EnemyData
	call Multiply
	
	ld b, 10
	ld de, RAM_MESSAGE+4					;Load into de the part in RAM_MESSAGE to output the enemy name
.loop:										;Copy the enemy name into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, .loop
	
	;stat name and enemy name are now inserted into RAM_MESSAGE, now we need to put the message around it
	
	ld a, BANK_STRING						;Set the current bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	ld a, [NEW_TILES+2]						;Load into a the data about the move the enemy used
	bit 6, a								;If bit 6 = 0, then the move causes a decrease in a stat
	jr z, COMBAT_ENEMY_STAT_ENEMY_FELL		;so jump to COMBAT_ENEMY_STAT_ENEMY_FELL
	
	
COMBAT_ENEMY_STAT_ENEMY_ROSE:
	ld hl, TheEnemyStatRoseBy				;Else, load a different value into hl and then jump to COMBAT_ENEMY_STAT_ENEMY_FELL_COPY1
	ld de, RAM_MESSAGE						;We can reuse the same code for outputting if the stat fell or rose as
	ld b, 4									;they are the same length
	jr COMBAT_ENEMY_STAT_ENEMY_FELL_COPY1
	
COMBAT_ENEMY_STAT_ENEMY_FELL:
	ld hl, TheEnemyStatFellBy
	ld de, RAM_MESSAGE
	ld b, 4
COMBAT_ENEMY_STAT_ENEMY_FELL_COPY1:				;Copies "The " into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_STAT_ENEMY_FELL_COPY1
	
	ld a, e									;Increments de so that it points to the last character in the enemy name
	add 9
	ld e, a
	ld a, d									;add 9 set the carry flag if it caused an overflow
	adc 0									;so add with carry will add the overflow to d, causing de to increment by 9
	ld d, a
	
.loop:										;Decrements de until it finds a character that isn't a space
											;This is so that if an enemy name is padded with spaces then we can still
											;have "'s" after the enemy name without awkward spacing issues
	ld a, [de]
	cp $81									;if the current character isn't a space
	jr nz, COMBAT_ENEMY_STAT_ENEMY_CONTINUE		;then jump to COMBAT_ENEMY_STAT_ENEMY_CONTINUE
	dec de
	jr .loop								;else, dec de and jump to .loop
	
	
COMBAT_ENEMY_STAT_ENEMY_CONTINUE:			;Continues to copy the message into RAM_MESSAGE
	inc de									;increment de so that we don't overwrite the first non space character
	ld a, [hl+]								;Copies the "'s" into RAM_MESSAGE
	ld [de], a								;If this were done as a loop, it would only run 2 times, so the loop has been unrolled
	inc de
	ld a, [hl+]
	ld [de], a
	inc de
	
	ld b, 9
	ld de, RAM_MESSAGE+24
	ld a, [RAM_MESSAGE+23]
	or a									;if the stat name meant that the 24th character has been filled,
	jr nz, COMBAT_ENEMY_STAT_ENEMY_FELL_COPY2		;then jump to COMBAT_ENEMY_STAT_ENEMY_FELL_COPY2 and continue output from RAM_MESSAGE+24
	ld de, RAM_MESSAGE+21
	ld a, [RAM_MESSAGE+20]
	or a									;else if the stat name meant that the 21st character has been filled,
	jr nz, COMBAT_ENEMY_STAT_ENEMY_FELL_COPY2		;then jump to COMBAT_ENEMY_STAT_ENEMY_FELL_COPY2 and continue output from RAM_MESSAGE+21
	ld de, RAM_MESSAGE+20					;else the stat name is 2 characters long, so continue output from RAM_MESSAGE+20
	
COMBAT_ENEMY_STAT_ENEMY_FELL_COPY2:				;copies the last part of the message
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	jr nz, COMBAT_ENEMY_STAT_ENEMY_FELL_COPY2	
	
COMBAT_ENEMY_UPDATE_HP_OUT:
	push de						;push the current position in RAM_MESSAGE
	
	ld a, [NEW_TILES+3]			;Load the change in stat caused by the player into the stat and then convert it
	ld [input], a
	ld bc, $0A00
	call DIVIDE					;divide a by 10 and store the result in c. This is necessary for the bcd function to work
	ld a, [input]				;reload the input into a 
	call BcdConvert_init
	
	pop de
	ld a, [upper_result]
	and $0F
	add $91						;add $91 so that a contains the tile reference for that number
	ld [de], a					;load the tile into [de]
	inc de
	
	ld a, [lower_result]
	and $F0
	swap a						;and $F0 and swap so that we are only dealing with the number in the top half
	add $91
	ld [de], a
	inc de
	
	ld a, [lower_result]
	and $0F
	add $91
	ld [de], a
	inc de
	
	ld a, $80
	ld [de], a					;add the null terminator to the end of the message
								;the change in stat and the message have been put into RAM_MESSAGE, so we can now output it
								
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT			;Output the message
	
	call COMBAT_UPDATE_HEALTH	
	
COMBAT_ENEMY_TURN_WAIT_A_LOOP:
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	ld a, [HEALTH]
	or a							;If the player's health is 0
	jp z, COMBAT_END_PLAYER			;then jump to COMBAT_END_PLAYER
	ret								;else, return
	
COMBAT_MOVES::
	ld a, [rLCDC]					;Turn the window off so that the player can't see the frame change
	res 5, a
	ld [rLCDC], a
	
	ld de, _SCRN1
	ld hl, LargeWindowFrame
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD			;Set the window to the large frame
	
	xor a							;a xor a = 0
	ld [rWY], a						;Move the window to WindowX,0
	ld [CURSOR_X], a				;Move the cursor to 0,0
	ld [CURSOR_Y], a
	
	call COMBAT_ENEMY_HIDE
	
	ld hl, COMBAT_MOVES_LIST		;Load into hl the pointer to the list of available movees
	ld a, h
	ld [MOVES_LIST_PTR], a
	ld a, l
	ld [MOVES_LIST_PTR+1], a		;and load that into MOVES_LIST_PTR
	
COUNT_LOOP_INIT:					
	;We want to calculate the no of moves in the list after and including the move pointed to by the pointer
	;To do that we first need to calculate how many potential entries there are
	;So, we want hl to contain the end of the list +1 and de to contain -move ptr
	ld a, [MOVES_LIST_PTR]
	cpl								;flip the bits so that we get 2's complement
	ld d, a
	ld a, [MOVES_LIST_PTR+1]
	cpl								;flip the bits so that we get 2's complement
	ld e, a
	inc de							;increment so that de = -move_list_ptr
	
	ld hl, COMBAT_MOVES_LIST+255
	add hl, de						;add hl and de so that l now contains the length of the list
	
	;now that l contains the no of potential entries, we want to check how many entries there actually are 
	
	ld b, l							;Load into b, l so that we can use it as a loop counter
	ld a, [MOVES_LIST_PTR]
	ld h, a							;Load into hl the pointer to the move list
	ld a, [MOVES_LIST_PTR+1]
	ld l, a
	ld c, 0							;C is used to count the no of moves, so set it to 0
.loop:								;Loops through the list, checking how many non 0 values there are
	ld a, [hl+]
	or a							;if the value hl pointed to = 0, then there are no more non 0 values,
	jr z, .loop_escape				;so jump to .loop_escape
	inc c							;else, we are on a non 0 value, so increment our item counter
	dec b							;and decrement the loop counter
	jr nz, .loop
	
.loop_escape:
	ld a, c							;if the no of items in the list is >16, then cp 16 will cause an underflow
	cp 16							;causing the carry bit to be set
	jr c, COMBAT_MOVES_ARROW_TEST2 	;so if the carry bit is set, jump to COMBAT_MOVES_ARROW_TEST2
	
	call WAIT_VBLANK				;Wait for vblank so that we are able to output the tile
	ld a, $F4 
	ld [$9E32], a					;else load $f4 into [$9E32] which loads the tile no for a right facing arrow
									;into the bottom right of the window layer
	
COMBAT_MOVES_ARROW_TEST2:
	;We want to test if the move list pointer points to the top of the list
	;So, if COMBAT_MOVES_LIST - MOVES_LIST_PTR = 0, then they are the same so we are pointing to the top
	
	ld a, [MOVES_LIST_PTR]
	cpl								;flip the bits so that we get 2's complement
	ld d, a
	ld a, [MOVES_LIST_PTR+1]
	cpl								;flip the bits so that we get 2's complement
	ld e, a
	inc de							;increment so that de = -move_list_ptr
	
	ld hl, COMBAT_MOVES_LIST
	add hl, de						;hl now contains COMBAT_MOVES_LIST - MOVES_LIST_PTR
	
	;if we are pointing to the top of the list, then hl = 0
	;(h OR l) can only = 0 if h and l both = 0 
	
	
	xor a
	or h									
	or l
	or a									;if h OR l = 0,
	jr z, COMBAT_MOVES_LOOP_COUNTER_SETUP 	;then jump to COMBAT_MOVES_LOOP_COUNTER_SETUP
	
	call WAIT_VBLANK				;Wait for vblank so that we are able to output the tile
	ld a, $F3						;load $f3 into [$9E21] which loads the tile no for a left facing arrow
	ld [$9E21], a					;into the bottom left of the window layer
	
COMBAT_MOVES_LOOP_COUNTER_SETUP:
	ld a, c
	or a
	jr z, COMBAT_MOVES_OUTPUT_DONE	  ;If the list is empty, then jump to COMBAT_MOVES_OUTPUT_DONE
	cp 16							  ;If there are < 16 moves in the list, then cp 16 will cause an underflow
	jr c, COMBAT_MOVES_NAME_LOOP_INIT ;so if the carry bit is set, jump to COMBAT_MOVES_NAME_LOOP_INIT 
	ld c, 16
	
COMBAT_MOVES_NAME_LOOP_INIT:
	ld a, BANK_ITEMDB				;Set the current bank to bank 7 as that is where the move data is stored
	ld [$2000], a
	
	ld hl, $9C22					;Load into hl the first location in the window to output move names
	ld a, [MOVES_LIST_PTR]
	ld d, a
	ld a, [MOVES_LIST_PTR+1]
	ld e, a 						;Load into de the ptr to the list
	
COMBAT_MOVES_NAME_LOOP:
	;We want to copy the move name into CUR_ITEM_NAME so that we can then output it
	
	ld a, [de]						;Load into a the move no
	push de
	push hl							;push de, hl and bc so that we can keep their values and
	push bc							;use them in the next calculation
									
	;We want hl to point to the data for the move referenced
	;So we want hl to contain MoveData + (moveNo-1)(MOVE_LENGTH)
	dec a
	ld d, 0
	ld e, a
	ld b, 8
	ld c, MOVE_LENGTH
	ld hl,MoveData
	call Multiply				;hl = MoveData + (moveNo-1)(MOVE_LENGTH)
	
	ld b, 10
	ld de, CUR_ITEM_NAME		;CUR_ITEM_NAME is resused here as it is the correct length and it does not need
								;the values in it to be retained, so it can be freely reused
								
.loop:							;Copies the move name into CUR_ITEM_NAME
	ld a, [hl+]					;load the current letter into a and increment hl
	ld [de], a					;load the current letter into [de] and inc de
	inc de
	dec b
	jr nz, .loop				;if the loop counter != 0, jump to .loop
	
	pop bc						;pop bc and hl so that we can access the loop counter and our output position
	pop hl
	
	
	;We now want to copy the current name into the window
	
	ld b, 10					;Set our 2nd loop counter to the length of the move name
	ld de, CUR_ITEM_NAME		;and load into de the location of the move name
NAME_OUTPUT:
	;Before each letter is output, we need to check if we are in vblank
	;if we are not in vblank then it is not definite that loading the letter into memory will work
	;so we have to be sure that we are in vblank
	
	ld a, [rLY]				
	cp 153						;if the current scanline = 153
	call z, WAIT_VBLANK			;then we are not in vblank, so call WAIT_VBLANK
	cp 144						;if the current scanline < 144
	call c, WAIT_VBLANK			;then we are not in vblank, so call WAIT_VBLANK

	ld a, [de]					;load into a the current letter
	ld [hl+], a					;and output the current letter
	inc de		
	dec b
	jr nz, NAME_OUTPUT			
	
	ld de, 22
	add hl, de					;increment hl by 22 so that it points to the start of the next line
	
	pop de						;pop de so that we can get the next move from the list
	inc de
	
	dec c							;decrement our main loop counter
	jr nz, COMBAT_MOVES_NAME_LOOP	;if c != 0, then there are still moves left so jump to COMBAT_MOVES_NAME_LOOP
	
COMBAT_MOVES_OUTPUT_DONE:	
	ld a, [rLCDC]					;turn the window back on
	set 5, a
	ld [rLCDC], a
	
	ld a, 16
	ld [CURSOR_X], a
	ld a, 24
	ld [CURSOR_Y], a				;set the cursor x,y to (16,24) so that it points to the first move
	
COMBAT_MOVES_MAIN:
	halt							;halt until the vblank interupt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	
	bit 5, a
	jp nz, COMBAT_MOVES_LEFT		;if the player is pressing left then jump to COMBAT_MOVES_LEFT
	
	bit 4, a
	jp nz, COMBAT_MOVES_RIGHT		;if the player is pressing right then jump to COMBAT_MOVES_RIGHT
	
	bit 6, a
	jp nz, COMBAT_MOVES_UP			;if the player is pressing up then jump to COMBAT_MOVES_UP
	
	bit 7, a
	jp nz, COMBAT_MOVES_DOWN		;if the player is pressing down then jump to COMBAT_MOVES_DOWN
	
	bit 1, a
	jr nz, COMBAT_MOVES_A_OR_B		;if the player is pressing B then jump to COMBAT_MOVES_A_OR_B
	
	bit 0, a
	jr z, COMBAT_MOVES_MAIN			;if the player isn't pressing A then jump to COMBAT_MOVES_MAIN

COMBAT_MOVES_A_OR_B:
	ld a, MESSAGE_Y 
	ld [rWY], a						;Move the window back to the correct position
	
	ld a, BANK_ENEMYTILES1 
	ld [$2000], a					;sets the bank to bank 8 as the layout for the sprites is stored there
	
	call WAIT_VBLANK				;Wait for vblank so that all the sprites are moved correctly
	
	;We want to set the enemy sprites back to their original positions
	call COMBAT_ENEMY_SHOW
	
	ld a, [rLCDC]						;turn the window off so that the player can't see it change
	res 5, a
	ld [rLCDC], a
	
	ld a, BANK_TILESET					;set the current bank to bank 3 so that we can correctly load in the normal window frame
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD				;Load the default frame
	
	ld a, [rLCDC]
	set 5, a
	ld [rLCDC], a						;turn the window back on
	
	ld a, [joypad_pressed]
	bit 1, a							;if the player pressed b earlier instead of a
	jp nz, COMBAT_MAIN_INIT_RET 			;then jump to COMBAT_MAIN_INIT
	
	ld a, [MOVES_LIST_PTR]
	ld h, a
	ld a, [MOVES_LIST_PTR+1]
	ld l, a								;else load into hl [MOVES_LIST_PTR]
	
	ld a, [CURSOR_Y]
	sub 24
	srl a
	srl a
	srl a								;a = (cursor_y-24)/8
										;this means that if the cursor was pointing to the first item, a = 0. The second item, a = 1, etc
	
	ld d, 0 
	ld e, a
	add hl, de							;hl now points to the move that the cursor is pointing to
	
	ld a, [hl]							;load into a the move no
	or a								;if the cursor points to move 0
	jp z, COMBAT_MAIN_INIT_RET			;then return back to the menu so that the player can't use a move that doesn't exist
	jp COMBAT_ATTACK					;else then jump to COMBAT_ATTACK
	

COMBAT_MOVES_LEFT:
	ld a, [$9E21]
	cp $F3								;if [$9E21] doesn't contain the code for a left facing arrow
	jp nz, COMBAT_MOVES_MAIN			;then jump to COMBAT_MOVES_MAIN
	
	ld a, [MOVES_LIST_PTR]
	ld h, a
	ld a, [MOVES_LIST_PTR+1]
	ld l, a								;hl = [MOVES_LIST_PTR]
	
	ld de, SUBTRACT_16
	add hl, de							;hl = hl -16
	
	ld a, h
	ld [MOVES_LIST_PTR], a
	ld a, l
	ld [MOVES_LIST_PTR+1], a			;list ptr = list ptr - 16
	
	ld a, BANK_TILESET					;set the current bank to bank 3
	ld [$2000], a
	
	ld a, [rLCDC]						;turn off the window
	res 5, a
	ld [rLCDC], a
	
	ld de, _SCRN1
	ld hl, LargeWindowFrame
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD				;Load the large window frame into the window
	jp COUNT_LOOP_INIT					;and jump to COUNT_LOOP_INIT so that we can output the new set of moves
	
COMBAT_MOVES_RIGHT:
	ld a, [$9E32]							
	cp $F4								;if [$9E32] doesn't contain the code for a right facing arrow
	jp nz, COMBAT_MOVES_MAIN			;then jump to COMBAT_MOVES_MAIN
	
	ld a, [MOVES_LIST_PTR]
	ld h, a
	ld a, [MOVES_LIST_PTR+1]
	ld l, a								;hl = list ptr
	
	ld de, 16
	add hl, de							;hl = hl +16
	
	ld a, h
	ld [MOVES_LIST_PTR], a
	ld a, l
	ld [MOVES_LIST_PTR+1], a			;list ptr = list ptr + 16
	
	ld a, BANK_TILESET					;set the current bank to bank 3
	ld [$2000], a
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a						;turn off the window
	
	ld de, _SCRN1
	ld hl, LargeWindowFrame
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD				;Load the large window frame into the window
	jp COUNT_LOOP_INIT					;and jump to COUNT_LOOP_INIT so that we can output the new set of moves
	
COMBAT_MOVES_UP:
	ld a, [CURSOR_Y]
	cp 24								;if the cursor is at the top of the screen (y = 24)
	jp z, COMBAT_MOVES_MAIN				;then jump to COMBAT_MOVES_MAIN
	
	sub 8								
	ld [CURSOR_Y], a					;else cursor y = cursor y -8
	jp COMBAT_MOVES_MAIN
	
COMBAT_MOVES_DOWN:
	ld a, [CURSOR_Y]
	cp 144								;if the cursor is at the bottom of the screen (y=144)
	jp z, COMBAT_MOVES_MAIN				;jump to COMBAT_MOVES_MAIN
	
	sub 24
	srl a
	srl a
	srl a
	inc a								;a = (cursor_y-24)/8 + 1
										;this means that if the cursor was pointing to the first item, a = 1. The second item, a = 2, etc
	
	ld hl, $9C22						;hl = first position in the window to output move names
	ld b, 8
	ld c, a
	ld de, 32
	call Multiply						;hl = $9C22 + 32((cursor_y-24)/8 + 1) 
	;hl now points to the text on the line under the cursor
	ld a, [hl]
	cp $81								;if the text starts with a space then there is no text there
	jp z, COMBAT_MOVES_MAIN				;so jump to COMBAT_MOVES_MAIN
	
	ld a, [CURSOR_Y]					;else, the cursor is not at the bottom of the screen
	add 8								;and there is a move below the current one being pointed to by the cursor
	ld [CURSOR_Y], a					;so, cursor y = cursor y + 8
	jp COMBAT_MOVES_MAIN
	
COMBAT_ITEMS::
	call COMBAT_ENEMY_HIDE				;Hide the enemy so that they don't block the menu
	call MENU_ITEMS						;call MENU_ITEMS as it is able to display our items and is now able to
										;return to COMBAT_MAIN_INIT_RET
	
	;If the player exits the menu without doing anything, then the enemy sprite will not be visible,
	;So we need to move the enemy sprites back into the correct position
	;But we don't know if we are in vblank, so we need to wait for vblank so that all 
	;enemy sprites get output correctly
	call WAIT_VBLANK					
	call COMBAT_ENEMY_SHOW
	
	jp COMBAT_MAIN_INIT_RET 

COMBAT_ESCAPE::
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a				;Set the cursor x,y to 0,0 so that it is not visible

	ld a, 100
	call RANDOM_NUM					;Generates a random no between 0 and 99
	ld a, [RANDOM_NO]
	inc a							;Increment so that random no is now between 1 and 100
	
	ld b, ESCAPE_CHANCE
	cp b							;if ESCAPE_CHANCE > RANDOM_NO, then there will be a carry
	jp c, COMBAT_END_ESCAPE			;so jump to COMBAT_END_ESCAPE
	
	ld a, BANK_STRING				;Else, set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, YouCouldntGetAway
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT
	
COMBAT_ESCAPE_WAIT_A_LOOP:			;Waits until the player presses a
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	call COMBAT_ENEMY_ATTACK_GENERATE	;Generates an attack for the enemy
	call COMBAT_ENEMY_TURN				;And then takes the enemy turn
	
	jp COMBAT_MAIN_INIT_RET 

	
	
COMBAT_ENEMY_ATTACK_GENERATE::
	ld a, [$4000]
	push af									;push the current bank to the stack so that we can set the bank back to what it previously was
	
	call RAM_MESSAGE_CLEAR					;clear RAM_MESSAGE as we use it to store data here
											;we use RAM_MESSAGE instead of NEW_TILES as a section of NEW_TILES is already used in the combat functions
	
	ld a, BANK_COMBAT						;set the current bank to bank 6 so that we can get enemy data
	ld [$2000], a
	
											;We want hl to point to the enemy
	ld hl, EnemyData						;so we want hl to contain EnemyData + (ENEMY_NO-1)*ENEMY_LENGTH
	ld b, 8
	ld c, ENEMY_LENGTH
	ld a, [ENEMY_NO]
	dec a
	ld d, 0
	ld e, a
	call Multiply
	
	ld de, 22
	add hl, de								;hl = hl+22 so that we point to the list of moves the enemy can learn
	
	ld b, 8									;b is used as the loop counter
	ld c, 0									;c is used to store the length of the list
	ld de, RAM_MESSAGE
.loop:
	ld a, [hl+]
	or a									;if the move currently being pointed to = move 0
	jr z, .loop_inc							;then jump to .loop_inc	
	push hl
	push de
	push bc									;else push hl, de and bc so that we can retain their values
	
	ld d, 0
	dec a
	ld e, a
	ld a, BANK_ITEMDB
	ld [$2000], a
	ld hl, MoveData
	ld b, 8
	ld c, MOVE_LENGTH
	call Multiply							;hl = MoveData + MOVE_LENGTH(MOVE_NO-1)
	
	ld de, 12
	add hl, de								;hl = hl+12 so that we point to the level that the move is learnt at
	
	ld a, [hl]
	ld b, a									;b = level the current move is learnt at
	
	ld a, MAX_LEVEL+1
	cp b									;if the move is learnt at MAX_LEVEL+1, then it is a move only for enemies
	jr z, .loop_output						;so add it to the list
	
	ld a, [ENEMY_LEVEL]
	cp b
	jr z, .loop_output						;if enemy_level = level the current move is learnt at then jump to .loop_output
	jr nc, .loop_output						;else if enemy_level > level the current move is learnt at then jump to .loop_output
	
	pop bc
	pop de									
	pop hl									;pop all values so that de and b can be altered and so that we don't need to pop after the loop
.loop_inc:
	inc de
	dec b
	jr nz, .loop
	jr .loop_out
	
.loop_output:	
	pop bc
	pop de
	pop hl
	
	ld a, BANK_COMBAT						;change the bank to bank 6 so that we can get move data 
	ld [$2000], a
	
	dec hl									;as hl was previously incremented and we want the current move, decrement hl
	ld a, [hl+]								;get the current move
	ld [de], a								;and output it in the list
	
	inc de
	inc c									;increment the list length
	dec b									;decrement the loop counter
	jr nz, .loop

.loop_out:
	
	inc c								;increment c so that the list contains 0 as a final value
	ld a, c
	call RANDOM_NUM						;generate a random no between 0 and c
	ld a, [RANDOM_NO]					;load the result into a
	
	ld de, RAM_MESSAGE
	ld h, 0
	ld l, a
	add hl, de							;hl = RAM_MESSAGE + RANDOM_NO
	ld a, [hl]							;so a = a random value from the list
	
	ld [NEW_TILES+5], a						;Load the move no into NEW_TILES+5
	or a									;if the move no is not 0
	jr nz, ENEMY_MOVE_GET_DATA				;then jump ENEMY_MOVE_GET_DATA
	ld b, %10000011							;else, load into b the byte saying a physical attack targeting the player
	ld a, [ENEMY_ATTACK]
	ld c, a									;load the enemy attack into c
	jr COMBAT_ENEMY_ATTACK_GENERATE_DONE	;and jump to COMBAT_ENEMY_ATTACK_GENERATE_DONE
ENEMY_MOVE_GET_DATA:						;Load the move data and damage into b and c
	dec a
	ld e, a
	ld d, 0
	ld b, 8
	ld c, MOVE_LENGTH
	ld hl, MoveData
	call Multiply							;hl = MoveData + Move_Length(MoveNo-1), so hl points to the move referenced
	
	ld a, BANK_ITEMDB						;Set the current bank to bank 7 so that we can get move data
	ld [$2000], a
	
	ld de, 10
	add hl, de								;Increment hl by 10 so that we point to the move data
	ld a, [hl+]
	ld b, a									;Load the move data into b
	ld a, [hl]
	ld c, a									;Load the move damage into c
	
COMBAT_ENEMY_ATTACK_GENERATE_DONE:	
	ld a, b
	ld [NEW_TILES+2], a						;load the move data into NEW_TILES+2
	ld a, c
	ld [NEW_TILES+3], a						;load the move damage into NEW_TILES+3
	
	pop af
	ld [$2000], a
	
	ret
	
COMBAT_END_ENEMY::
	call RAM_MESSAGE_CLEAR					;Clears RAM_MESSAGE
	
	ld a, BANK_STRING						;Sets the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld hl, YouHaveDefeated
	ld de, RAM_MESSAGE
	ld c, 21
	
.loop:										;Copies the message into RAM_MESSAGE
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, .loop
	
	ld a, BANK_COMBAT						;Sets the bank to bank 6 so that we can get the enemy name
	ld [$2000], a
											
											;We want hl to point to the enemy
	ld hl, EnemyData						;so we want hl to contain EnemyData + (ENEMY_NO-1)*ENEMY_LENGTH
	ld b, 8
	ld c, ENEMY_LENGTH
	ld a, [ENEMY_NO]
	dec a
	ld d, 0
	ld e, a
	call Multiply
	
	ld c, 10
	ld de, RAM_MESSAGE+22
.loop2:										;Copies the enemy name into RAM_MESSAGE so that it is inserted after the message
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, .loop2
	
	ld a, $80								;Adds the null terminator to the message
	ld [de], a
	
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;Outputs "You have defeated the ", ENEMY_NAME
	call WAIT_FOR_A_OR_B					;Wait for the player to press A or B

	call FADE_SPRITES_WHITE					;Fades the enemy sprites to white
	
	call RAM_MESSAGE_CLEAR					;Clears RAM_MESSAGE
	ld a, BANK_STRING						;Set the current bank to bank 5
	ld [$2000], a
	
	ld hl, YouGotGoldAndExp
	ld de, RAM_MESSAGE 
	ld c, 29
.loop3:										;Copies the message into RAM_MESSAGE
											;This time I left spaces in the message as it makes the code much cleaner compared to inserting
											;data in part way through
	ld a, [hl+]
	ld [de], a
	inc de
	dec c
	jr nz, .loop3
	
	ld a, $80								;adds the null terminator at the end of the message
	ld [de], a
	
	ld a, BANK_COMBAT						;Sets the bank to bank 6 so that we can get the gold and exp gained from the enemy
	ld [$2000], a
											;We want hl to point to the enemy
	ld hl, EnemyData						;so we want hl to contain EnemyData + (ENEMY_NO-1)*ENEMY_LENGTH
	ld b, 8
	ld c, ENEMY_LENGTH
	ld a, [ENEMY_NO]
	dec a
	ld d, 0
	ld e, a
	call Multiply
	
	ld de, 33								;Add 33 so that we point to the gold gained from the enemy
	add hl, de
	
	ld a, [hl+]
	ld [NEW_TILES], a						;store the gold gained in NEW_TILES
	ld a, [hl]
	ld [NEW_TILES+1], a						;and store the exp gained in NEW_TILES+1
	
	ld a, [NEW_TILES]						;load the amount of gold gained into a 
	ld [input], a							;and then load a into input so that we can convert it to bcd
	ld bc, $0A00
	call DIVIDE								;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]
	add $91									;add $91 as $91 is the hex no for the tile for "0"
	ld [RAM_MESSAGE+8], a					;adds the first digit of the gold gained to RAM_MESSAGE
	
	ld a, [lower_result]
	and $F0									;and $F0 so that the lower nibble containing the third no isn't considered here
	swap a									;swap so that adding $91 will give us the correct tile no
	add $91									;add $91 as $91 is the hex no for the tile for "0"
	ld [RAM_MESSAGE+9], a					;adds the 2nd digit of the gold gained to RAM_MESSAGE
	
	ld a, [lower_result]
	and $0F									;and $0F so that the upper nibble containing the 2nd no isn't considered here
	add $91									;add $91 as $91 is the hex no for the tile for "0"
	ld [RAM_MESSAGE+10], a					;adds the 3rd digit of the gold gained to RAM_MESSAGE
	
	ld a, [NEW_TILES+1]						;load the amount of exp gained into a
	ld [input], a							;and then load a into input so that we can convert it to bcd
	ld bc, $0A00
	call DIVIDE								;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init					;converts the amount of exp gained into bcd so that we can output it
	
	ld a, [upper_result]
	add $91									;add $91 as $91 is the hex no for the tile for "0"
	ld [RAM_MESSAGE+22], a					;adds the 1st digit of the exp gained to RAM_MESSAGE
	
	ld a, [lower_result]
	and $F0									;and $F0 so that the lower nibble containing the third no isn't considered here
	swap a									;swap so that adding $91 will give us the correct tile no
	add $91									;add $91 as $91 is the hex no for the tile for "0"
	ld [RAM_MESSAGE+23], a					;adds the 2nd digit of the exp gained to RAM_MESSAGE
	
	ld a, [lower_result]
	and $0F									;and $0F so that the upper nibble containing the 2nd no isn't considered here
	add $91									;add $91 as $91 is the hex no for the tile for "0"
	ld [RAM_MESSAGE+24], a					;adds the 3rd digit of the exp gained to RAM_MESSAGE
	
	ld de, RAM_MESSAGE
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;Outputs how much gold and exp the player gained
	call WAIT_FOR_A_OR_B					;Waits for the player to press A or B
	
	ld a, [GOLD]
	ld b, a
	ld a, [NEW_TILES]						;load into a the amount of gold gained
	add b									;add it the the current amount
	jr nc, exp_add							;if there is not a carry, then jump to exp_add
	ld a, 255								;else, set the amount of gold to the max value
	
exp_add:
	ld [GOLD], a							;store the new amount of gold in memory
	
	ld a, [EXP]
	ld b, a
	ld a, [NEW_TILES+1]						;load into a the amount of exp gained
	add b									;add it the the current amount
	jr nc, level_check						;if there is not a carry, then jump to level_check
	ld a, 255								;else, set the amount of exp to the max value

level_check:
	ld [EXP], a								;store the new amount of exp in memory
	
	ld b, a									;load the new amount of exp into b so that we can do a comparison with it later
	ld a, [LEVEL]
	cp MAX_LEVEL							;if the player is at the max level, 
	jr z, COMBAT_END_ENEMY_SCRN_OFF			;then jump to COMBAT_END_ENEMY_SCRN_OFF
	
	ld hl, ExpRequired
	ld d, 0
	ld e, a									;load into de the player level
	add hl, de								;and increment hl by that amount so that we can get the exp required for the next level
	
	ld a, [hl]								;load into a the exp required for the next level
	cp b									;compare it with the current amount of exp
	jr z, COMBAT_END_ENEMY_LVL_UP			;if they are equal, then jump to COMBAT_END_ENEMY_LVL_UP
	jr nc, COMBAT_END_ENEMY_SCRN_OFF		;else, if the carry flag isn't set (amount required > curr exp) jump to COMBAT_END_ENEMY_SCRN_OFF
COMBAT_END_ENEMY_LVL_UP:	
	ld c, a									;load into c the exp required to level up
	ld a, b									;load into a the current amount of exp
	sub c									
	ld [EXP], a								;exp = exp - exp required to level up
	ld a, [LEVEL]
	inc a
	ld [LEVEL], a							;level = level + 1
	
	ld a, BANK_STRING
	ld [$2000], a
	
	ld de, YouLeveledUp
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;Output "You leveled up"
	call WAIT_FOR_A_OR_B					;Wait for the player to press A or B
	
COMBAT_END_ENEMY_SCRN_OFF:
	xor a
	ld [rLCDC], a							;Turn the screen off
	
	call COMBAT_ENEMY_HIDE					;hide the enemy sprites
	
	ld a, %11100100
	ld [rOBP0], a							;set object palette 0 back to normal
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a							;move the player sprite back to the correct x,y
	
	ld a, BANK_TILESET
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call FRAME_LOAD					;loads the empty portrait frame into the window as that is what the program expects to be there
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to the bank that the current map is stored in
	
	ld a, [CURR_MAP_ADR]
	ld h, a
	ld a, [CURR_MAP_ADR+1]
	ld l, a									;hl = current map address
	call MAP_INITIALISE						;initialise the map
	
	call MAP_MUSIC							;set the correct music to play
	
	ld a, %11000011	
	ld [rLCDC], a							;turn the screen back on
	
	ld a, GAMESTATE_OVERWORLD
	ld [GAMESTATE], a						;set gamestate back to GAMESTATE_OVERWORLD
	
	inc sp									;increment the stack pointer by 2 so that it skips over the return address from
	inc sp									;the program calling COMBAT_ENEMY_TURN or COMBAT_PLAYER_TURN
	
	pop af									;get the previous bank off of the stack
	ld [$2000], a							;and set the current bank back to what it previously was
	ret
	
	
COMBAT_END_PLAYER::
	ld de, YouDied
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;Output "You died"
	call WAIT_FOR_A_OR_B			;Wait for the player to press A or B
	
	call FADE_BLACK
	
	call COMBAT_ENEMY_HIDE			;Hide the enemy sprites
	
	ld b, 60
	call DELAY						;Wait about 1 second
	jp Start						;jump back to the start of the program

COMBAT_END_ESCAPE::
	ld a, BANK_STRING				;set the current bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	ld de, YouEscaped
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT				;output "You escaped"
	
	call WAIT_FOR_A_OR_B
	dec sp							;decrement stack pointer by 2 so that it points to the same value as it would
	dec sp							;if we were jumping to COMBAT_END_ENEMY
	jr COMBAT_END_ENEMY_SCRN_OFF	
	
	
COMBAT_ENEMY_HIDE::
	xor a
	ld b, 25						;Set the loop counter to 25 as there are 25 enemy sprites						
	ld hl, $FE08					;load into hl the location of the first enemy sprite in OAM
	
	ld de, 3						;load into de the offset we need
.loop:
	ld [hl+], a						;load into the sprite y, a
	ld [hl], a						;load into the sprite x, a
	add hl, de						;increment hl by 3 so that it points to the next sprite
	dec b							
	jr nz, .loop					;if b != 0, then jump to .loop
	ret
	
COMBAT_ENEMY_SHOW::
	ld a, BANK_ENEMYTILES1 
	ld [$2000], a					;sets the bank to bank 8 as the layout for the sprites is stored there
	
	ld hl, $FE08					;first location in OAM to output sprite data
	ld c, 25						;no of sprites
	ld b, 3							;used as a second loop counter
	ld de, ENEMY_TILE_LAYOUT 
tile_reference_loop:				;copies 3 bytes from [de] and then sets the 4th byte to 0
	ld a, [de]
	ld [hl+], a
	inc de
	dec b
	jr nz, tile_reference_loop 		
	xor a
	ld [hl+], a
	ld b, 3
	
	dec c
	jr nz,tile_reference_loop
	ret

COMBAT_UPDATE_HEALTH::
	call WAIT_VBLANK			;Wait for vblank so that we can write to VRAM
	ld a, [HEALTH]				;Load the player health into [input] so that we can output the player health on the screen
	ld [input], a
	ld bc, $0A00
	call DIVIDE						;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]
	and $0F
	add $91
	ld [$9948], a					;Outputs the first no of health onto the screen
	
	ld a, [lower_result]
	and $F0
	swap a
	add $91
	ld [$9949], a					;Outputs the 2nd no of health onto the screen
	
	ld a, [lower_result]
	and $0F
	add $91
	ld [$994A], a					;Outputs the 3rd no of health onto the screen
	
	ld a, [ENEMY_HEALTH]
	ld [input], a					;stores the enemy health in input so that it can be used for bcd conversion
	ld bc, $0A00
	call DIVIDE						;Divides a by 10 and stores the result in c. This is required for the bcd conversion to work
	ld a, [input]				
	call BcdConvert_init
	
	ld a, [upper_result]
	and $0F							
	add $91							;add $91 so that a now contains the tile no of the number in the lower half of upper_result
	ld [$992B], a					
	
	ld a, [lower_result]
	and $F0							;and $F0 so that the lower half doesn't affect the tile we end up with
	swap a							;swap so that instead of being 16X, it becomes X
	add $91							
	ld [$992C], a
	
	ld a, [lower_result]
	and $0F							;and $0F so that the upper half doesn't affect the tile we end up with
	add $91
	ld [$992D], a	
	ret
	
COMBAT_INIT_0::
	xor a							;clears the byte used to tell if the player has moved
	ld [COMBAT_INIT_BYTE], a
	ret

PLAYER_STATS_CALC::
	ld a, [$4000]
	push af

	ld a, BANK_COMBAT
	ld [$2000], a

	ld c, 6
STATS_CALC_LOOP:
	push bc							;bc and de need to be retained, so they are pushed to the stack
	push de
	ld a, [LEVEL]
	ld b, 8
	ld c, a
	ld a, [hl+]
	ld d, 0
	ld e, a
	ld a, [hl+]						
	push hl
	ld h, 0
	ld l, a							;loads the c term into hl
	call Multiply					;multiplies level by the m term for that stat
	ld a, h							
	or a							;if h = 0
	jr z, STATS_CALC_INC			;then jump to STATS_CALC_INC
	ld hl, 255						;else, the calculation overflowed so load the maximum value (255) into l
STATS_CALC_INC:
	ld a, l							;load into a the result of the calculation
	pop hl
	pop de
	ld [de], a						;and store it in the memory location for that stat
	inc de							;increment de so that it points to the next stat
	pop bc
	dec c							;c = c-1
	jr nz, STATS_CALC_LOOP			;if c !=0, then jump to STATS_CALC_LOOP
	
	pop af
	ld [$2000], a
	ret
	
WAIT_FOR_A_OR_B::	
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]			;get the state of the buttons
	and %00000011					;bits 0 and 1 represent the state of the A and B buttons (up or down)
	or a							;so if a and %00000011 = 0, then the player is not pressing a or b
	jr z, WAIT_FOR_A_OR_B			;so jump back to the start of the loop
	ret

FADE_SPRITES_WHITE::
	ld a, %11100100					;load a normal palette into a
	ld [rOBP0], a
	
	ld c, 3							;set our loop counter to 3
	ld e, %01111111					
FADE_W_LOOP:						;resets the 3 most significant bits of a to 0 and loads it into rOBP0
	and e							;and with e to set the most significant 1 to 0
	sra e							;shift e right so that it will affect the next bit 
	ld [rOBP0], a					;load the current state of a into rOBP0
	ld b, FADE_DELAY_TIME
	call DELAY						;delay by 15/60 seconds
	dec c
	jr nz, FADE_W_LOOP				;if c!= 0, jump to FADE_W_LOOP
	
	res 2, a						;set bit 2 to 0
	ld [rOBP0], a
	ld b, FADE_DELAY_TIME
	call DELAY						;wait 15/60 seconds
	ret								;all bits are now 0, so return
	
FADE_BLACK::
	ld a, %11100100					;load a normal pallette into a
	ld [rBGP], a
	ld [rOBP0], a
	ld [rOBP1], a					;and load that into the background and both object pallettes
	
	ld c, 5
	ld e, %00010000
FADE_LOOP:	
	or e							;or e so that a bit in a gets set
	sra e							;shift e so that it affects the next bit next time around the loop
	ld [rBGP], a
	ld [rOBP0], a
	ld [rOBP1], a
	ld b, FADE_DELAY_TIME
	call DELAY						;wait for FADE_DELAY_TIME/60 seconds
	dec c
	jr nz, FADE_LOOP
	ret								;pallette is $FF now, so we can return

FADE_BACKGROUND_BLACK::
	ld a, %11100100					;load a normal pallette into a
	ld [rBGP], a
	
	ld c, 5
	ld e, %00010000
.loop:	
	or e							;or e so that a bit in a gets set
	sra e							;shift e so that it affects the next bit next time around the loop
	ld [rBGP], a
	ld b, FADE_DELAY_TIME
	call DELAY
	dec c
	jr nz, .loop
	ret								;pallette is $FF now, so we can return	
	
SLOW_FADE_BACKGROUND_WHITE::
	ld a, %11100100					;load a normal palette into a
	ld [rBGP], a
	
	ld c, 3							;set our loop counter to 3
	ld e, %01111111					
.loop:								;resets the 3 most significant bits of a to 0 and loads it into rOBP0
	and e							;and with e to set the most significant 1 to 0
	sra e							;shift e right so that it will affect the next bit 
	ld [rBGP], a					;load the current state of a into rOBP0
	ld b, FADE_DELAY_TIME*3
	call DELAY						;delay by 30/60 seconds
	dec c
	jr nz, .loop					;if c!= 0, jump to .loop
	
	res 2, a						;set bit 2 to 0
	ld [rBGP], a
	ld b, FADE_DELAY_TIME*3
	call DELAY						;wait 30/60 seconds
	ret								;all bits are now 0, so return
;****************************************************************************************************************************************************
;*	Encounter code
;****************************************************************************************************************************************************
DefaultEncounter::
	ret

Boss1Encounter::
	ld a, [$C000]
	set 1, a			;set bit 1 of $C000 as that is the bit representing if the player has fought the 1st boss
	ld [$C000], a
	ret	

Boss2Encounter::
	ld a, [$C000]
	set 2, a			;set bit 2 of $C000 as that is the bit representing if the player has fought the 2nd boss
	ld [$C000], a
	ret
	
FinalBossEncounter::
	ld a, [COUNTER]
	inc a
	ld [COUNTER], a		;increment counter
	
	ld a, [$4000]		;get the current bank number and push it to the stack
	push af
	
	ld a, BANK_TILESET
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD		;load the portrait window frame
	
	ld a, BANK_STRING
	ld [$2000], a

	ld b, DEFAULT_TEXT_SPEED
	ld a, [COUNTER]
	ld de, Five
	cp 1									;if counter = 1, then it is the first turn, so we want to output "5"
	jr z, FinalBossEncounter_MessageOut		;so jump to FinalBossEncounter_MessageOut 
	ld de, Four
	cp 2									;if counter = 2, then it is the 2nd turn, so we want to output "4"
	jr z, FinalBossEncounter_MessageOut		;so jump to FinalBossEncounter_MessageOut
	ld de, Three
	cp 3									;if counter = 3, then it is the 3rd turn, so we want to output "3"
	jr z, FinalBossEncounter_MessageOut		;so jump to FinalBossEncounter_MessageOut
	ld de, Two
	cp 4									;if counter = 4, then it is the 4th turn, so we want to output "2"
	jr z, FinalBossEncounter_MessageOut		;so jump to FinalBossEncounter_MessageOut
	ld de, One
	cp 5									;if counter = 5, then it is the 5th turn, so we want to output "1"
	jr z, FinalBossEncounter_MessageOut		;so jump to FinalBossEncounter_MessageOut
	jr nz, FinalBossEncounter_End			;else, counter = 6, so the player has run out of time so jump to FinalBossEncounter_End
FinalBossEncounter_MessageOut: 
	call PORTRAIT_MESSAGE_OUTPUT			;output the message
	call WAIT_FOR_A_OR_B					;wait for the player to press A or B
	
	pop af									;get the starting bank off the stack
	ld [$2000], a							;and set the current bank
	ret

FinalBossEncounter_End:
	ld a, [rLCDC]							;Get the state of the screen
	push af									;And push it to the stack
	
	xor a									;turn the screen off so that we can fill it without the player
	ld [rLCDC], a							;noticing
	
	ld bc, 32 * 32
	ld de, _SCRN0
.loop:										;for all 32x32 tiles,
	ld a, 2									
	ld [de], a								;output tile 2
	inc de
	dec bc
	ld a, b
	or c
	jr nz, .loop							;if the loop counter != 0, jump to .loop 
	
	pop af									;set the screen back to how it was so that the player can
	ld [rLCDC], a							;now see the updated background
	
	ld b, DEFAULT_TEXT_SPEED+10 
	ld de, Perish
	call MESSAGE_OUTPUT						;slowly output "Perish"
	
	
	ld hl, $0150							;memory location of the start of the program
	ld b, 20								;no of times to output on x axis
	ld c, 13								;no of times to output on y axis
	ld de, _SCRN0							;memory location to output to
.loop2:										;fill the screen with "garbage" data
	ld a, [hl+]
	ld [de], a
	inc de
	dec b
	
	ld a, b
	or a
	jr nz, .loop2 							;if b != 0, jump to .loop2
	
	push hl
	ld hl, 12
	add hl, de
	ld d, h
	ld e, l
	pop hl									;increment de by 12 so that de points to the first tile of the next row
	
	push bc									;push bc so that we can preserve our loop counters
	ld b, 5
	call DELAY								;wait 1/12 seconds
	pop bc									
	
	ld b, 20								;set b back to 20						
	
	dec c
	jr nz, .loop2 							;if c != 0, then jump to .loop2
	
	
	ld b, 120
	call DELAY								;wait 2 seconds
	jp Start								;jump back to the start of the program, resetting it
	
;****************************************************************************************************************************************************
;*	Event code
;****************************************************************************************************************************************************	
BLANK_MAP_EVENT::
	ret

	
TITLESCREEN::
	halt
	
	ld a, [COUNTER]
	inc a
	ld [COUNTER], a						;increment the counter
	
	cp 60
	jr c, TITLESCREEN_INPUTS			;if the counter is less than 60, jump to TITLESCREEN_INPUTS
	
	
	ld a, $81							
	ld [CURSOR_SPRITE], a				;else, set the cursor sprite to $81 (blank tile used for space)
	
	ld a, [COUNTER]
	cp 90								
	jr c, TITLESCREEN_INPUTS			;if the counter is less than 90, jump to TITLESCREEN_INPUTS
	
	ld a, 5
	ld [CURSOR_SPRITE], a				;else, set the cursor sprite back to 5
	
	xor a
	ld [COUNTER], a						;and set the counter back to 0
	
TITLESCREEN_INPUTS:	
	call READ_JOYPAD
	
	ld a, [joypad_pressed]
	bit 0, a							;if the player is pressing A
	jr nz, TITLESCREEN_A				;then jump to TITLESCREEN_A
	
	bit 6, a							;if the player is pressing UP
	jr nz, TITLESCREEN_UP				;then jump to TITLESCREEN_UP
	
	bit 7, a							;if the player is pressing DOWN
	jr nz, TITLESCREEN_DOWN				;then jump to TITLESCREEN_DOWN
	
	jr TITLESCREEN						;else, jump to TITLESCREEN

TITLESCREEN_UP:
	ld a, [CURSOR_Y]
	cp 11*8 + 16						;if cursor_y = 11*8 + 16
	jr z, TITLESCREEN					;then jump to TITLESCREEN
	
	ld a, 11*8 + 16 
	ld [CURSOR_Y], a					;else, cursor_y = 11*8 + 16
	jr TITLESCREEN
	
TITLESCREEN_DOWN:
	ld a, [CURSOR_Y]					
	cp 13*8 + 16 						;if cursor_y = 13*8 + 16
	jr z, TITLESCREEN					;then jump to TITLESCREEN
	
	ld a, 13*8 + 16
	ld [CURSOR_Y], a					;else, cursor_y = 13*8 + 16
	jr TITLESCREEN
	
TITLESCREEN_A:
	ld a, [CURSOR_Y]
	cp 11*8 + 16						;if cursor_y != 11*8 + 16, then the cursor is on "Continue"
	jp nz, TITLESCREEN_CON				;so jump to TITLESCREEN_CON (in bank 0 as it needs to change bank for strings)
TITLESCREEN_NEW:
	call SAVE_CHECK
	or a								;if a save file exists
	jr nz, TITLESCREEN_NEW_DEL			;then jump to TITLESCREEN_NEW_DEL
	jp TITLESCREEN_NEW_DEL_NEW			;else TITLESCREEN_NEW_DEL_NEW	
	
TITLESCREEN_NEW_DEL::
	ld a, BANK_STRING
	ld [$2000], a
	
	ld b, DEFAULT_TEXT_SPEED
	ld de, Warning
	call MESSAGE_OUTPUT				;output "Warning! Starting a new game will delete save data. Are you sure you want to start a new game?"
	call WAIT_FOR_A_OR_B			;wait for the player to press A or B
	
	ld b, 0
	ld de, YesNo
	call MESSAGE_OUTPUT				;outputs "Yes         No"
	
	call WAIT_VBLANK				;wait for vblank so that we can change sprites
	
	ld a, 4
	ld [CURSOR_SPRITE], a			;set the cursor sprite to the default pointer (sprite 4)
	
	
	ld a, 3*8
	ld [CURSOR_X], a				;move the cursor to (24,136) so that it points to "Yes"
	
	ld a, 15*8 + 16
	ld [CURSOR_Y], a

TITLESCREEN_NEW_DEL_LOOP:	
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	
	
	bit 0, a								;if the player is pressing A
	jr nz, TITLESCREEN_NEW_DEL_LOOP_A		;then jump to TITLESCREEN_NEW_DEL_LOOP_A
	
	bit 4, a								;if the player is pressing RIGHT
	jr nz, TITLESCREEN_NEW_DEL_LOOP_RIGHT	;then jump to TITLESCREEN_NEW_DEL_LOOP_RIGHT
	
	bit 5, a								;if the player is pressing LEFT
	jr nz, TITLESCREEN_NEW_DEL_LOOP_LEFT	;then jump to TITLESCREEN_NEW_DEL_LOOP_LEFT
	jr TITLESCREEN_NEW_DEL_LOOP				;else, jump to TITLESCREEN_NEW_DEL_LOOP
	
TITLESCREEN_NEW_DEL_LOOP_A:
	ld a, [CURSOR_X]
	cp 3*8									;if cursor_x = 24, then it is pointing to "Yes"
	jr z, TITLESCREEN_NEW_DEL_NEW			;so jump to TITLESCREEN_NEW_DEL_NEW so that we can create a new save file
	jr TITLESCREEN_NEW_DEL_RETURN			;else jump to TITLESCREEN_NEW_DEL_RETURN so that the title screen can return to normal

TITLESCREEN_NEW_DEL_LOOP_LEFT:
	ld a, [CURSOR_X]
	cp 3*8									;if cursor_x = 24, then it is pointing to "Yes", so it can't move to the left
	jr z, TITLESCREEN_NEW_DEL_LOOP			;so, jump to TITLESCREEN_NEW_DEL_LOOP
	
	ld a, 3*8
	ld [CURSOR_X], a						;else, cursor_x = 24
	jr TITLESCREEN_NEW_DEL_LOOP
	
TITLESCREEN_NEW_DEL_LOOP_RIGHT:
	ld a, [CURSOR_X]
	cp 15*8									;if cursor_x = 120, then it is pointing to "No", so it can't move to the right
	jr z, TITLESCREEN_NEW_DEL_LOOP			;so, jump to TITLESCREEN_NEW_DEL_LOOP
	
	ld a, 15*8
	ld [CURSOR_X], a						;else, cursor_x = 120
	jr TITLESCREEN_NEW_DEL_LOOP

TITLESCREEN_NEW_DEL_RETURN:
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off so that the player can't see the message anymore
	
	ld a, 11*8 + 16
	ld [CURSOR_Y], a
	ld a, 8*6
	ld [CURSOR_X], a						;moves the cursor so that it points to New game again
	ld a, 5
	ld [CURSOR_SPRITE], a					;sets the sprite to reference the cursor
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to the bank no stored in CURR_MAP_BANK
	jp TITLESCREEN							;and jump back to TITLESCREEN
	
TITLESCREEN_NEW_DEL_NEW:
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a							
	
	call SAVE_DELETE						;delete any existing save data
	
	ld a, 10								;set the player health
	ld [HEALTH], a
	ld a, 1									;set the player level
	ld [LEVEL], a
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, BANK_TILESET						;sets the current bank to bank 3 so that we can load window data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call FRAME_LOAD							;load the portrait window frame into the window
	
	xor a
	ld [CURSOR_Y], a
	ld [CURSOR_X], a						;move the cursor to 0,0 so that it can't be seen
	ld a, 4
	ld [CURSOR_SPRITE], a					;set the cursor sprite back to the default cursor
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a							;sets the player x,y coords
	
	ld a, BANK_MAP1
	ld [$2000], a							;set the bank containing the map
	ld [CURR_MAP_BANK], a
	ld a, 13
	ld [MAP_X], a
	ld a, 109								;set our coords on the new map
	ld [MAP_Y], a
	ld hl, Map1								;set the pointer to the new map
	
	;ld a, BANK_MAP3
	;ld [$2000], a							;set the bank containing the map
	;ld [CURR_MAP_BANK], a
	;ld a, 2
	;ld [MAP_X], a
	;ld a, 61						;set our coords on the new map
	;ld [MAP_Y], a
	;ld hl, Map4								;set the pointer to the new map
	
	;ld a, BANK_MAP2
	;ld [$2000], a							;set the bank containing the map
	;ld [CURR_MAP_BANK], a
	;ld a, 7
	;ld [MAP_X], a
	;ld a, 14								;set our coords on the new map
	;ld [MAP_Y], a
	;ld hl, Map6								;set the pointer to the new map
	
	;ld a, BANK_MAP2
	;ld [$2000], a							;set the bank containing the map
	;ld [CURR_MAP_BANK], a
	;ld a, 16-PLAYER_X
	;ld [MAP_X], a
	;ld a, 20-PLAYER_Y						;set our coords on the new map
	;ld [MAP_Y], a
	;ld hl, Map2								;set the pointer to the new map
	call MAP_INITIALISE
	add sp, 2								;as the old map is in a different bank, ret will return to the same location in the new bank
											;so we need to increment the sp by 2 to skip over the return address
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	jp MAIN_EVENT_END						;and jump to MAIN_EVENT_END to end the event 

TITLESCREEN_CON_NO_SAVE:
	ld a, BANK_STRING						;change the bank to bank 5 so that we can get the message data
	ld [$2000], a
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a						;move the cursor to 0,0 so that it can't be seen
	
	ld de, SaveFile
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;output "A save file does not exist."
	call WAIT_FOR_A_OR_B					;waits for the player to press A or B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, 8*6
	ld [CURSOR_X], a
	ld a, 13*8 + 16
	ld [CURSOR_Y], a						;move the cursor so that it points back to "Continue"
	
	ld a, [CURR_MAP_BANK]					;set the current bank to the one containing the current map
	ld [$2000], a 
	jp TITLESCREEN							;jump back to TITLESCREEN 
	
TITLESCREEN_CON::
	call SAVE_CHECK
	or a									;if a save file does not exist,
	jr z, TITLESCREEN_CON_NO_SAVE			;then jump to TITLESCREEN_CON_NO_SAVE
	

	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a							
	
	call SAVE_LOAD							;load the save
	
	ld a, BANK_TILESET						;sets the current bank to bank 3 so that we can load window data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call FRAME_LOAD							;load the portrait window frame into the window
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	xor a
	ld [CURSOR_Y], a
	ld [CURSOR_X], a						;move the cursor to 0,0 so that it can't be seen
	ld a, 4
	ld [CURSOR_SPRITE], a					;set the cursor sprite back to the default cursor
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a							;sets the player x,y coords
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set current bank to be the bank containing the new map
	
	ld a, [CURR_MAP_ADR]
	ld h, a
	ld a, [CURR_MAP_ADR+1]
	ld l, a									;set the pointer to the new map
	
	call MAP_INITIALISE
	add sp, 2								;as we don't want to return to the event code here, we add 2 to sp to skip over the return address	
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	jp MAIN_EVENT_END						;and jump to MAIN_EVENT_END to end the event 


	
MAP1_EVENT1::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP							;if the player is not facing up
	ret nz									;then return
	
	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing a
	ret z									;then return
	
	ld a, BANK_STRING
	ld [$2000], a							;set the current bank to bank 5 so that we can get message data
	
	ld de, YouReadTheSign
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;Outputs "You Read the sign"
	call WAIT_FOR_A_OR_B
	
	ld de, ItWarnsYou
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;Outputs "It warns you about littering"
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;loads the portrait frame into the window
	
	ld a, [CURR_MAP_BANK]					;set the current bank back to the map bank
	ld [$2000], a
	ret
	
MAP1_EVENT2::
	ld a, [PLAYER_DIR]						
	cp PLAYER_LEFT							;if the player is not facing left
	ret nz									;then return
	
	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing a
	ret z									;then return
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, YouCant
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;Outputs "You can't read the sign from here"
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;loads the portrait frame into the window
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a
	ret

MAP1_EVENT3::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a							
	
	ld a, BANK_MAP2
	ld [$2000], a							;set the bank containing the map
	ld [CURR_MAP_BANK], a
	ld a, 16-PLAYER_X
	ld [MAP_X], a
	ld a, 20-PLAYER_Y						;set our coords on the new map
	ld [MAP_Y], a
	ld hl, Map2								;set the pointer to the new map
	call MAP_INITIALISE
	add sp, 2								;as the old map is in a different bank, ret will return to the same location in the new bank
											;so we need to increment the sp by 2 to skip over the return address
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	jp MAIN_EVENT_END

MAP1_EVENT4::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP							;if the player is not facing up
	ret nz									;then return

	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing a
	ret z									;then return

	ld a, BANK_COMBAT						;set the bank to bank 6 so that we can get the growth rate for different stats
	ld [$2000], a
	
	ld hl, HealthGrowRate			
	ld de, CALC_MAXHEALTH
	call PLAYER_STATS_CALC					;calculate the player stats
	
	ld a, [CALC_MAXHEALTH]
	ld [HEALTH], a							;Health = max health
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, YourHealth
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT			;outputs "Your health has been restored"
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]							;turn the window off
	res 5, a
	ld [rLCDC], a
	
	ld a, [CURR_MAP_BANK]					;set the current bank to the bank storing the current map
	ld [$2000], a
	ret

MAP1_EVENT5::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP							;if the player is not facing up
	ret nz									;then return

	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing A
	ret z									;then return
	
	ld a, BANK_STRING
	ld [$2000], a
	
	ld de, BeCareful
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT			;outputs "Be careful ahead! The dark patches have monsters hiding in them" 
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, [CURR_MAP_BANK]					;set the current bank to the bank holding the current map
	ld [$2000], a
	ret

MAP1_EVENT6::
	call COMBAT_INIT_0						;reset COMBAT_INIT_BYTE
	ret

MAP1_EVENT7::
	COMBAT_TILE_1					;test COMBAT_INIT_BYTE so that this function can only run once per tile				
	; ld hl, NEW_TILES				;NEW_TILES is reused to save memory
	; ld a, 1							;3 enemy numbers and levels are stored in NEW_TILES
	; ld [hl+], a
	; ld a, 2
	; ld [hl+], a
	; ld a, 1
	; ld [hl+], a
	; ld a, 2
	; ld [hl+], a
	; ld a, 1
	; ld [hl+], a
	; ld a, 2
	; ld [hl+], a
	; COMBAT_INIT_ENEMY_PICK
	ld a, 01					;set the enemy to be Crab
	ld [ENEMY_NO], a
	ld a, 02					;and set their level to 2
	ld [ENEMY_LEVEL], a
	call COMBAT					;and start Combat
	ret

MAP1_EVENT8::
	COMBAT_TILE_2				;test COMBAT_INIT_BYTE so that this function can only run once per tile
	ld a, 01					;set the enemy to be Crab
	ld [ENEMY_NO], a
	ld a, 02					;and set their level to 2
	ld [ENEMY_LEVEL], a
	call COMBAT					;and start Combat
	ret	

MAP1_EVENT9::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP						;if the player is not facing up
	ret nz								;then return

	ld a, [joypad_pressed]
	bit 0, a							;if the player is not pressing A
	ret z								;then return
	
	ld a, BANK_STRING					;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, BossAhead
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT		;Outputs "Be careful, the next area has a boss."
	call WAIT_FOR_A_OR_B
	
	ld de, TakeThese
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT		;Outputs "Take these, they might help"
	call WAIT_FOR_A_OR_B
	
	ld de, YouGotTheSwordAndPotions
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT					;Outputs "You got the Sword and 2 Potions"
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a						;turn the window off
	
	ld a, BANK_TILESET					;set the current bank to bank 3 so that we can get frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD				;loads the portrait frame into the window
	
	ld a, 1
	call INVENTORY_ADD					 
	
	ld a, 1
	call INVENTORY_ADD					;adds 2 potions (item code 1) to the player inventory
	
	ld a, 2
	call INVENTORY_ADD					;adds a sword (item code 2) to the player inventory
	
	ld a, [EVENT_PERMANENCE+1]
	set 0, a
	ld [EVENT_PERMANENCE+1], a
	
	ld a, [CURR_MAP_BANK]				;set the current bank to the bank holding the current map
	ld [$2000], a
	ret
	

MAP2_EVENT6::
	ld a, [joypad_pressed]
	bit 0, a							;if the player is not pressing A
	ret z								;then return

	ld a, BANK_TILESET					;set the current bank to bank 3 so that we can get portrait data
	ld [$2000], a
	
	ld hl, Boss1Portrait
	call ACTIVE_PORTRAIT_LOAD			;load the first boss's portrait 
	
	ld a, BANK_STRING					;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, BirdNoises
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT		;output "*various bird noises*"
	call WAIT_FOR_A_OR_B
	
	ld de, ItSeems
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT					;output "It seems you won't get past without a fight"
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a						;turns the window off
	
	ld a, BANK_TILESET					;sets the current bank to bank 3
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD				;loads the portrait frame into the window
	
	ld a, 02							;set the enemy to be Bird
	ld [ENEMY_NO], a
	ld a, 02							;and their level to 2
	ld [ENEMY_LEVEL], a
	call COMBAT							;and start combat
	
	ld a, [CURR_MAP_BANK]				;set the current bank to the bank holding the current map
	ld [$2000], a
	ret
	
MAP2_EVENT7::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get portrait data
	ld [$2000], a
	
	ld hl, Portrait1
	call PORTRAIT_LOAD						;as the first bosses portrait is still loaded in, load the npc portrait
	
	ld a, [MAP_Y]
	cp $0F									;if the player y = 15, then we are at the bottom of the map
	jr z, MAP2_EVENT7_MAP1					;so, jump to MAP2_EVENT7_MAP1 so that we can load map 1
	
	ld a, 16-PLAYER_X						;else, set the player coords
	ld [MAP_X], a
	ld a, 21-PLAYER_Y
	ld [MAP_Y], a
	
	ld a, [CURR_MAP_BANK]					;set the current bank to the bank holding the current map
	ld [$2000], a							;we can do this as maps 2 and 3 are stored in the same bank
	ld hl, Map3
	call MAP_INITIALISE 					;load map 3
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	ret

MAP2_EVENT7_MAP1::
	ld a, 16-PLAYER_X						;set the player coords
	ld [MAP_X], a
	ld a, 11-PLAYER_Y
	ld [MAP_Y], a
	
	ld a, BANK_MAP1
	ld [$2000], a
	ld [CURR_MAP_BANK], a
	ld hl, Map1
	call MAP_INITIALISE
	add sp, 2								;as we don't want to return to the event code here, we add 2 to sp to skip over the return address	
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	jp MAIN_EVENT_END
	
MAP3_EVENT1::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, 7									;set the player coords
	ld [MAP_X], a
	ld a, 3
	ld [MAP_Y], a
	
	ld a, [CURR_MAP_BANK]					;set the current bank to be the one containing the current map
	ld [$2000], a							;we can do this as maps 2 and 3 are stored in the same bank
	
	ld hl, Map2
	call MAP_INITIALISE 					;load map2
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	xor a									;set joypad_down and joypad_pressed to 0 so that when this returns to the main loop,
	ld [joypad_down], a						;if the player was pressing down before the event then it doesn't move them down 
	ld [joypad_pressed], a					
	ret

MAP3_EVENT2::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, 78								;set the player coords
	ld [MAP_X], a
	ld a, 3
	ld [MAP_Y], a
	
	ld a, BANK_MAP3					
	ld [$2000], a							;change bank and curr_map_bank as map 4 is in a different bank
	ld [CURR_MAP_BANK], a	
	ld hl, Map4
	call MAP_INITIALISE 					;load map 4
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	add sp, 2								;as the old map is in a different bank, ret will return to the same location in the new bank
											;so we need to increment the sp by 2 to skip over the return address
	jp MAIN_EVENT_END						;and jump to MAIN_EVENT_END to end the event 

MAP3_EVENT4::
	;Move the player to map6
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, $07								;set the player coords
	ld [MAP_X], a
	ld a, $0E
	ld [MAP_Y], a
	
	ld a, [CURR_MAP_BANK]					;set the current bank to be the one containing the current map
	ld [$2000], a							;we can do this as maps 3 and 6 are stored in the same bank
	
	ld hl, Map6
	call MAP_INITIALISE 					;load map6
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	xor a									;set joypad_down and joypad_pressed to 0 so that when this returns to the main loop,
	ld [joypad_down], a						;if the player was pressing down before the event then it doesn't move them down 
	ld [joypad_pressed], a					
	ret
	
MAP3_EVENT5::
	;Item shop
	ld a, [PLAYER_DIR]
	cp PLAYER_UP						;if the player is not facing up
	ret nz								;then return
	
	ld a, [joypad_pressed]
	bit 0, a							;if the player is not pressing A
	ret z								;then return
	
	ld a, BANK_TILESET
	ld [$2000], a
	
	ld hl, Portrait1
	call ACTIVE_PORTRAIT_LOAD		;load portrait in
	
	ld a, BANK_STRING				;set the bank back to bank 5 so we can output the 2nd message
	ld [$2000], a
	
	ld de, WelcomeToMyShop
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT	;outputs "Welcome to my shop! If you touch something, you have to buy it!"
	call WAIT_FOR_A_OR_B

MAP3_EVENT5_BUY_TALK_LOOP_INIT:
	ld a, 40
	ld [CURSOR_X], a
	ld a, 136
	ld [CURSOR_Y], a				;Move the cursor so that it points to "Buy"
	
	ld de, BuyTalk
	ld b, 0
	call PORTRAIT_MESSAGE_OUTPUT	;outputs "Buy		Talk"
MAP3_EVENT5_BUY_TALK_LOOP:
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	bit 4, a	
	jr nz, MAP3_EVENT5_BUY_TALK_LOOP_RIGHT
	bit 5, a
	jr nz, MAP3_EVENT5_BUY_TALK_LOOP_LEFT
	
	bit 1, a								;if the player is pressing B,
	jp nz, MAP3_EVENT5_BUY_TALK_LOOP_ESCAPE	;then jump to MAP3_EVENT5_BUY_TALK_LOOP_ESCAPE
	
	bit 0, a								;if the player is not pressing A,
	jr z, MAP3_EVENT5_BUY_TALK_LOOP			;then go back to the start of this loop
	ld a, [CURSOR_X]
	cp 40
	jr z, MAP3_EVENT5_BUY					;if cursor_x = 40, then the player has selected buy
	jp MAP3_EVENT5_TALK						;else they have selected talk

MAP3_EVENT5_BUY_TALK_LOOP_LEFT:
	ld a, [CURSOR_X]
	cp 112									;if the cursor doesn't have the max value
	jr nz, MAP3_EVENT5_BUY_TALK_LOOP		;then jump to MAP3_EVENT5_BUY_TALK_LOOP
	
	ld a, 40
	ld [CURSOR_X], a						;else, cursor_x = 40
	jr MAP3_EVENT5_BUY_TALK_LOOP
	
MAP3_EVENT5_BUY_TALK_LOOP_RIGHT:
	ld a, [CURSOR_X]
	cp 40									;if the cursor doesn't have the minimum value
	jr nz, MAP3_EVENT5_BUY_TALK_LOOP		;then jump to MAP3_EVENT5_BUY_TALK_LOOP 
	
	ld a, 112
	ld [CURSOR_X], a						;else, cursor_x = 112
	jr MAP3_EVENT5_BUY_TALK_LOOP
	
	
MAP3_EVENT5_BUY:
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off so that the player can't see it changing

	ld a, BANK_TILESET						;change to bank 3 so that we can get frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, ItemShop
	ld bc, 20*18
	call ACTIVE_FRAME_LOAD					;load the itemshop frame
	
	xor a
	ld [rWY], a								;move the window to x,0
	
	ld a, [rLCDC]
	set 5, a
	ld [rLCDC], a							;turn the window back on
	
	call WAIT_VBLANK						;wait for vblank so that we are always able to move the player
	xor a
	ld [$FE00], a							;move the player to 0,0 so that they can't be seen
	ld [$FE01], a
	
	ld a, 16
	ld [CURSOR_X], a				
	ld a, 24
	ld [CURSOR_Y], a						;move the cursor to 16,24 so that it points to the first item
	
ITEMSHOP_LOOP:
	halt
	call READ_JOYPAD
	
	ld a, [joypad_pressed]
	bit 1, a								;if the player is pressing B
	jp nz, ITEMSHOP_ESCAPE					;then jump to ITEMSHOP_ESCAPE 
	
	bit 6, a
	jp nz, ITEMSHOP_UP
	
	bit 7, a
	jp nz, ITEMSHOP_DOWN
	
	bit 0, a								;if the player is not pressing A
	jr z, ITEMSHOP_LOOP						;then go back to the start of the loop
	
	ld b, 10								;cost
	ld c, 1									;item code
	ld a, [CURSOR_Y]
	cp 24									;if cursor_y = 24, then we are pointing to the first item
	jr z, ITEMSHOP_BUY_CHECK				;so jump to ITEMSHOP_BUY_CHECK 
	ld b, 20								;cost
	ld c, 3									;item code
	cp 32									;if cursor_y = 32, then we are pointing to the 2nd item
	jr z, ITEMSHOP_BUY_CHECK				;so jump to ITEMSHOP_BUY_CHECK
	ld b, 30								;else, we are pointing to the 3rd item, so load the cost and
	ld c, 4									;item code into b and c
ITEMSHOP_BUY_CHECK:
	ld a, [GOLD]
	cp b									;b contains the item cost
	jp c, ITEMSHOP_NOT_ENOUGH				;if there is a carry, then GOLD < b, so jump to ITEMSHOP_NOT_ENOUGH
	
	sub b									;else, GOLD = GOLD - b
	ld [GOLD], a
	
	push bc
	
	ld a, c
	call INVENTORY_ADD						;add the item to the inventory
	
	call WAIT_VBLANK						;Wait for vblank so that we can change the player and cursor xy coords
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a						;move the cursor to 0,0 so that it is not visible
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8					;and move the player to normal coords
	ld [$FE01], a
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off so that the player can't see it changing

	ld a, BANK_TILESET						;change to bank 3 so that we can get frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, WindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;load the message frame
	
	ld a, MESSAGE_Y							;move the window to MESSAGE_X,MESSAGE_Y
	ld [rWY], a	
	
	ld a, [rLCDC]
	set 5, a
	ld [rLCDC], a							;turn the window back on
	
	ld a, BANK_STRING						;change the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	pop bc
	ld de,YouGotPotion 						
	ld a, c
	cp 1									;if the item code is 1, then we want to output "You got the potion",
	jr z,ITEMSHOP_BUY_OUTPUT 				;so jump to ITEMSHOP_BUY_OUTPUT 
	
	ld de,YouGotShield						
	cp 3									;else, if item code is 3 then we want to output "You got the Shield",
	jr z, ITEMSHOP_BUY_OUTPUT				;so jump to ITEMSHOP_BUY_OUTPUT
	
	ld de, YouGotAmulet						;Else, the player has bought the Amulet
	
ITEMSHOP_BUY_OUTPUT:
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;output "You got the",ItemName
	call WAIT_FOR_A_OR_B
	
	
	jp MAP3_EVENT5_BUY						;and jump back MAP3_EVENT5_BUY

ITEMSHOP_UP:
	ld a, [CURSOR_Y]
	cp 24									;if the cursor y = 24
	jp z, ITEMSHOP_LOOP						;then jump to ITEMSHOP_LOOP
	
	sub 8									;else, cursor_y = cursor_y - 8
	ld [CURSOR_Y], a
	jp ITEMSHOP_LOOP
	
ITEMSHOP_DOWN:	
	ld a, [CURSOR_Y]
	cp 40									;if the cursor y = 40
	jp z, ITEMSHOP_LOOP						;then jump to ITEMSHOP_LOOP
	
	add 8									;else, cursor_y = cursor_y + 8
	ld [CURSOR_Y], a
	jp ITEMSHOP_LOOP
	
ITEMSHOP_ESCAPE:
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a						;move the cursor to 0,0 so that it can't be seen
	
	ld a, PLAYER_Y * 8 + 16
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8					;and move the player to normal coords
	ld [$FE01], a
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, MESSAGE_Y							;move the window back to MESSAGE_X,MESSAGE_Y
	ld [rWY], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;load the portrait window frame
	
	ld a, [rLCDC]
	set 5, a
	ld [rLCDC], a							;turn the window back on
	
	ld a, BANK_STRING
	ld [$2000], a							;set the current bank to bank 5 so that we can get message data
	jp MAP3_EVENT5_BUY_TALK_LOOP_INIT
	
ITEMSHOP_NOT_ENOUGH:
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a						;move the cursor to 0,0 so that it can't be seen
	
	ld a, PLAYER_Y * 8 + 16					;move the player to normal coords
	ld [$FE00], a
	ld a, PLAYER_X * 8 + 8
	ld [$FE01], a
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, MESSAGE_Y							;move the window back to MESSAGE_X,MESSAGE_Y
	ld [rWY], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;load the portrait window frame
	
	ld a, [rLCDC]
	set 5, a
	ld [rLCDC], a
	
	ld a, BANK_STRING
	ld [$2000], a
	
	ld de, YouDontHaveEnough
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT			;outputs "You don't have enough gold to buy that!"
	call WAIT_FOR_A_OR_B 
	jp MAP3_EVENT5_BUY						;jump to MAP3_EVENT5_BUY so that we can redisplay the itemshop
	
MAP3_EVENT5_TALK:
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a						;moves the cursor to 0,0 so that it can't be seen

	ld de, TheNextArea
	ld a, [EVENT_PERMANENCE]
	bit 2, a								;if bit 2 is not set, then the player hasn't beat the 2nd boss
	jr z, MAP3_EVENT5_TALK_OUTPUT			;so, jump to MAP3_EVENT5_TALK_OUTPUT
	ld de, GoodLuck							;else, load a new message into de
MAP3_EVENT5_TALK_OUTPUT:	
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT
	call WAIT_FOR_A_OR_B
	jp MAP3_EVENT5_BUY_TALK_LOOP_INIT
	
	
MAP3_EVENT5_BUY_TALK_LOOP_ESCAPE:
	call WAIT_VBLANK						;wait for vblank so that we can always move the cursor
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a						;move the cursor to 0,0 so that it can't be seen

	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	ret
	
	
	
MAP4_EVENT1::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, 12-PLAYER_X						;set the player coords
	ld [MAP_X], a
	ld a, 15-PLAYER_Y
	ld [MAP_Y], a
	
	ld a, BANK_MAP2					
	ld [$2000], a							;change bank and curr_map_bank as map 4 is in a different bank
	ld [CURR_MAP_BANK], a	
	ld hl, Map3
	call MAP_INITIALISE 					;load map 4
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a	
	add sp, 2								;as the old map is in a different bank, ret will return to the same location in the new bank
											;so we need to increment the sp by 2 to skip over the return address	
	jp MAIN_EVENT_END						;and jump to MAIN_EVENT_END to end the event 

MAP4_EVENT2::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, 12								;set the player coords
	ld [MAP_X], a
	ld a, 15
	ld [MAP_Y], a
	
	ld a, BANK_MAP2					
	ld [$2000], a							;change bank and curr_map_bank as map 5 is in a different bank
	ld [CURR_MAP_BANK], a	
	ld hl, Map5
	call MAP_INITIALISE 					;load map 5
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	add sp, 2								;as the old map is in a different bank, ret will return to the same location in the new bank
											;so we need to increment the sp by 2 to skip over the return address
	jp MAIN_EVENT_END						;and jump to MAIN_EVENT_END to end the event 
	ret
	
MAP4_EVENT3::
	call COMBAT_INIT_0
	ret

MAP4_EVENT4::
	COMBAT_TILE_1				;test COMBAT_INIT_BYTE so that this function can only run once per tile
	ld a, 03					;set the enemy to be Spirit
	ld [ENEMY_NO], a
	ld a, 04					;and set their level to 4
	ld [ENEMY_LEVEL], a
	call COMBAT					;and start Combat
	ret
	
MAP4_EVENT5::
	COMBAT_TILE_2				;test COMBAT_INIT_BYTE so that this function can only run once per tile
	ld a, 03					;set the enemy to be Spirit
	ld [ENEMY_NO], a
	ld a, 04					;and set their level to 4
	ld [ENEMY_LEVEL], a
	call COMBAT					;and start Combat
	ret
	


MAP5_EVENT1::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, 2									;set the player coords
	ld [MAP_X], a
	ld a, 61
	ld [MAP_Y], a
	
	ld a, BANK_MAP3					
	ld [$2000], a							;change bank and curr_map_bank as map 4 is in a different bank
	ld [CURR_MAP_BANK], a	
	ld hl, Map4
	call MAP_INITIALISE 					;load map 4
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	
	ld a, BANK_TILESET						;sets the current bank to bank 3
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;loads the portrait frame into the window
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	add sp, 2								;as the old map is in a different bank, ret will return to the same location in the new bank
											;so we need to increment the sp by 2 to skip over the return address
	jp MAIN_EVENT_END						;and jump to MAIN_EVENT_END to end the event

MAP5_EVENT2::
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, 12-PLAYER_X						;set the player coords
	ld [MAP_X], a
	ld a, 16-PLAYER_Y
	ld [MAP_Y], a
	
	ld a, [CURR_MAP_BANK]					;set the current bank to the bank holding the current map
	ld [$2000], a							;we can do this as maps 5 and 3 are stored in the same bank
	ld hl, Map3
	call MAP_INITIALISE 					;load map 3
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	
	ld a, BANK_TILESET						;sets the current bank to bank 3
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;loads the portrait frame into the window
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	ret
	
MAP5_EVENT3::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP							;if the player is not facing up
	ret nz									;then return

	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing A
	ret z									;then return
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get portrait data
	ld [$2000], a
	
	ld hl, Boss2Portrait
	call ACTIVE_PORTRAIT_LOAD				;load the 2nd boss's portrait 
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, TreeNoises
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT			;outputs "*Various tree noises*"
	call WAIT_FOR_A_OR_B
	
	
	ld de, ItSeems
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;output "It seems you won't get past without a fight"
	call WAIT_FOR_A_OR_B
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turns the window off
	
	ld a, BANK_TILESET						;sets the current bank to bank 3
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;loads the portrait frame into the window
	
	ld a, 04								;set the enemy to be Tree
	ld [ENEMY_NO], a
	ld a, 05								;and their level to 5
	ld [ENEMY_LEVEL], a
	call COMBAT								;and start combat
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get portrait data
	ld [$2000], a
	
	ld hl, Portrait1
	call ACTIVE_PORTRAIT_LOAD				;load the default portrait 
	
	ld a, [CURR_MAP_BANK]					;set the current bank to the bank holding the current map
	ld [$2000], a
	ret
	
MAP5_EVENT7::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP							;if the player is not facing up
	ret nz									;then return

	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing A
	ret z									;then return
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, OpenChest
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;outputs "You open the chest"
	call WAIT_FOR_A_OR_B
	
	call WAIT_VBLANK						;Wait for vblank so that we can change bkg data
	ld a, $53
	ld [$98EB], a							;set the tile number for the tile the chest is on to the tile no for an open chest
	
	ld de, YouGotSwordPlus
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;outputs "You got the Sword+"
	call WAIT_FOR_A_OR_B

	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a							;turn the window off
	
	ld a, 5
	call INVENTORY_ADD						;adds item 5 to the player inventory
	
	ld a, [$C001]
	set 1, a
	ld [$C001], a							;set bit 1 of $C001 so that the player can't open the chest again
	
	ld a, [CURR_MAP_BANK]
	ld [$2000], a
	ret
	
	
MAP6_EVENT1::
	;Move the player to map3
	call FADE_BLACK							;fade the screen to black

	xor a
	ld [rLCDC], a							;turn the screen off
	
	ld a, %11100100							;load a normal palette back into the background palette and object palette 0
	ldh [rOBP0], a
	ldh [rBGP], a
	
	ld a, $07								;set the player coords
	ld [MAP_X], a
	ld a, $03
	ld [MAP_Y], a
	
	ld a, [CURR_MAP_BANK]					;set the current bank to be the one containing the current map
	ld [$2000], a							;we can do this as maps 3 and 6 are stored in the same bank
	
	ld hl, Map3
	call MAP_INITIALISE 					;load map6
	
	ld a, %11000011		
	ldh [rLCDC], a							;set the screen back to the correct setting
	
	call MAP_MUSIC							;get the correct music playing
	ld a, [CURR_MAP_BANK]
	ld [$2000], a							;set the current bank to be the one containing the current map
	
	xor a									;set joypad_down and joypad_pressed to 0 so that when this returns to the main loop,
	ld [joypad_down], a						;if the player was pressing down before the event then it doesn't move them down 
	ld [joypad_pressed], a					
	ret
	
MAP6_EVENT3::
	ld a, [PLAYER_DIR]
	cp PLAYER_UP							;if the player is not facing up
	ret nz									;then return

	ld a, [joypad_pressed]
	bit 0, a								;if the player is not pressing A
	ret z									;then return
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get frame data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;load the portrait window frame
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data
	ld [$2000], a
	
	ld de, OpenTheChest
	ld b, DEFAULT_TEXT_SPEED
	call MESSAGE_OUTPUT						;outputs "Open the chest?  Yes No"
	
	call WAIT_VBLANK						;wait for vblank so that we can move the cursor
	ld a, 40
	ld [CURSOR_X], a
	ld a, 136
	ld [CURSOR_Y], a						;move the cursor so that it points to "Yes"
	
MAP6_EVENT3_OPEN_LOOP:
	halt
	call READ_JOYPAD
	ld a, [joypad_pressed]
	
	bit 5, a								;if the player is pressing left
	jr nz, MAP6_EVENT3_LEFT					;then jump to MAP6_EVENT3_LEFT
	
	bit 4, a								;else if the player is pressing right
	jr nz, MAP6_EVENT3_RIGHT				;jump to MAP6_EVENT3_LEFT

	bit 0, a								;else if the player is pressing A
	jr nz, MAP6_EVENT3_PERISH				;then jump to MAP6_EVENT3_PERISH
	jr MAP6_EVENT3_OPEN_LOOP				;else, jump back to the start of the loop

MAP6_EVENT3_LEFT:
	ld a, [CURSOR_X]
	cp 40									;if cursor x = 40, it is pointing at "Yes" and cannot move left
	jr z, MAP6_EVENT3_OPEN_LOOP				;so jump back to the loop
	
	ld a, 40								;else, cursor x = 40
	ld [CURSOR_X], a
	jr MAP6_EVENT3_OPEN_LOOP
	
MAP6_EVENT3_RIGHT:
	ld a, [CURSOR_X]					
	cp 104									;if cursor x = 104, it is pointing at "No" and cannot move right
	jr z, MAP6_EVENT3_OPEN_LOOP				;so jump back to the loop
	
	ld a, 104								;else, cursor x = 104
	ld [CURSOR_X], a
	jr MAP6_EVENT3_OPEN_LOOP
	
MAP6_EVENT3_PERISH:
	ld a, [CURSOR_X]
	cp 104									;if cursor x = 104, it is pointing at "No"
	jp z, MAP6_EVENT3_EXIT					;so jump to MAP6_EVENT3_EXIT to allow the player to move again 
	
	call WAIT_VBLANK						;call vblank so we can write to OAM
	
	xor a
	ld [CURSOR_X], a						;move the cursor to (0,0) so that it can't be seen
	ld [CURSOR_Y], a
	
	ld a, PLAYER_Y * 8
	ld [$FE08], a							;sprite 3 y = player sprite y - 16
	
	ld a, PLAYER_X * 8 + 8					;sprite 3 x = player sprite x
	ld [$FE09], a
	
	ld a, $1E
	ld [$FE0A], a							;sprite 3 tile = $1E (sprite tile for the chest)
	
	ld a, %00010000							;sets the pallette for sprite 3 to OBP1
	ld [$FE0B], a
	
	xor a									;sets the background tile with the chest to 0 so that the chest is
	ld [$98EF], a							;not part of the background anymore 
	
	ld a, %11100001							;load an altered pallette into OBP1 which has colours 0 and 1 swapped
	ldh [rOBP1], a							;this is done as the chest sprite uses colour 0, which is by default 
											;the invisible colour for sprites, but doesn't use colour 1
	
	
	ld a, PLAYER_Y * 8 + 8					;sprite 4 y = player sprite y - 8
	ld [$FE0C], a
	
	ld a, PLAYER_X * 8 + 8 					;sprite 4 x = player sprite x
	ld [$FE0D], a
	
	ld a, $1F
	ld [$FE0E], a							;sprite 4 tile = $1F (sprite tile for the legs)
	
	ld a, BANK_TILESET						;set the current bank to bank 3 so that we can get portrait data
	ld [$2000], a
	
	ld hl, Boss3Portrait
	call ACTIVE_PORTRAIT_LOAD				;load the 3rd boss's portrait
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD					;load the portrait window frame
	
	ld a, BANK_STRING						;set the current bank to bank 5 so that we can get message data 
	ld [$2000], a
	
	ld de, ThenPerish
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT			;outputs "Then perish"
	call WAIT_FOR_A_OR_B 

MAP6_EVENT3_COMBAT:
	xor a
	ld [COUNTER], a							;clear counter as it is used by the boss's encounter code
	
	
	ld a, 05							;set the enemy to be Chest
	ld [ENEMY_NO], a
	ld a, 10							;and their level to 10
	ld [ENEMY_LEVEL], a
	call COMBAT							;and start combat
	
	;if the program reaches this point, the player has either defeated the boss or ran away
	;if enemy_health == 0, then the player has defeated the boss
	;else, they have not
	
	ld a, [ENEMY_HEALTH]
	or a						;if the enemy_health !=0, the player has run away instead of beating the boss
	jp nz, MAP6_EVENT3_RUN		;so jump to MAP6_EVENT3_RUN
	jr MAP6_EVENT3_END
	
MAP6_EVENT3_RUN:
	ld de, Fool
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT						;outputs "Fool, there is no running from me!"
	call WAIT_FOR_A_OR_B
	jp MAP6_EVENT3_COMBAT								;jumps to MAP6_EVENT3_COMBAT so that the player is forced back into combat
	
MAP6_EVENT3_EXIT:
	call WAIT_VBLANK									;wait for VBLANK so that we can write to OAM
	
	xor a
	ld [CURSOR_X], a
	ld [CURSOR_Y], a									;move the cursor to (0,0) so that it can't be seen
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a										;turn the window off
	
	ld a, BANK_TILESET									;set the current bank to bank 3 so that we can get portrait data
	ld [$2000], a
	
	ld de, _SCRN1
	ld hl, PortraitWindowFrame
	ld bc, 20*5
	call ACTIVE_FRAME_LOAD								;load the portrait window frame as the rest of the program expects it to be there
	
	ld a, [CURR_MAP_BANK]								;set the currrent bank to the bank containing the current map
	ld [$2000], a
	ret

MAP6_EVENT3_END:
	call WAIT_VBLANK									;wait for vblank so that we can write to OAM
	
	ld a, PLAYER_Y * 8
	ld [$FE08], a							;sprite 3 y = player sprite y - 16
	
	ld a, PLAYER_X * 8 + 8					;sprite 3 x = player sprite x
	ld [$FE09], a
	
	ld a, $1E
	ld [$FE0A], a							;sprite 3 tile = $1E (sprite tile for the chest)
	
	ld a, %00010000							;sets the pallette for sprite 3 to OBP1
	ld [$FE0B], a
	
	xor a									;sets the background tile with the chest to 0 so that the chest is
	ld [$98EF], a							;not part of the background anymore 
	
	ld a, %11100001							;load an altered pallette into OBP1 which has colours 0 and 1 swapped
	ldh [rOBP1], a							;this is done as the chest sprite uses colour 0, which is by default 
											;the invisible colour for sprites, but doesn't use colour 1

	ld a, PLAYER_Y * 8 + 8					;sprite 4 y = player sprite y - 8
	ld [$FE0C], a
	
	ld a, PLAYER_X * 8 + 8 					;sprite 4 x = player sprite x
	ld [$FE0D], a
	
	ld a, $1F
	ld [$FE0E], a							;sprite 4 tile = $1F (sprite tile for the legs)
	

	ld b, 30
	call DELAY								;wait 1/2 a second
	
	;this next section of code moves the legs back and forth
	;it is done like this as if it were done as a loop I would need a lookup table to store the offset
	ld a, PLAYER_X * 8 + 8 + 1				
	ld [$FE0D], a
	ld b, 20
	call DELAY
	
	ld a, PLAYER_X * 8 + 8
	ld [$FE0D], a
	ld b, 20
	call DELAY
	
	ld a, PLAYER_X * 8 + 8 - 1
	ld [$FE0D], a
	ld b, 20
	call DELAY
	
	ld a, PLAYER_X * 8 + 8 - 1
	ld [$FE0D], a
	ld b, 20
	call DELAY
	
	ld a, PLAYER_X * 8 + 8
	ld [$FE0D], a
	ld b, 20
	call DELAY
	
	ld c,88
.loop:							;moves the legs off screen
	add a, 2					
	ld [$FE0D], a				;move the sprite by 2 pixels
	ld b, 2
	call DELAY					;and wait 2/60 seconds
	dec c
	jr nz, .loop				;if c != 0, jump to .loop 
	
	
	ld a, PLAYER_Y * 8			;chest sprite's current y position
	ld c, 8
.loop2:
	inc a
	ld [$FE08], a				;increment to move the sprite down by 1
	ld b, 2
	call DELAY					;wait 2/60 seconds
	dec c
	jr nz, .loop2
	
	ld a, BANK_STRING			;set the current bank to bank 5 so we can get message data
	ld [$2000], a
	
	ld de, YouHaveBested
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT	;output "You have bested me"
	call WAIT_FOR_A_OR_B
	
	ld de, ThisWorld
	ld b, DEFAULT_TEXT_SPEED
	call PORTRAIT_MESSAGE_OUTPUT	;output "Now this world will disappear"
	call WAIT_FOR_A_OR_B
	
	call gbt_stop					;stops the music
	
	ld a, [rLCDC]
	res 5, a
	ld [rLCDC], a					;turn the screen off
	
	xor a							;move all recently used sprites to (0,0) so that they can't be seen
	ld [$FE00], a
	ld [$FE01], a
	ld [$FE08], a
	ld [$FE09], a
	ld [$FE0C], a
	ld [$FE0D], a
	
	call FADE_BACKGROUND_BLACK		;fade the background to black
	ld a, [rLCDC]
	push af							;push the current state of the screen to the stack
	xor a
	ld [rLCDC], a					;and turn the screen off
	
	ld a, %11100100					;load a normal pallette into a
	ld [rBGP], a
	
	ld a, 16-PLAYER_X						;set the map coords that we will see
	ld [MAP_X], a
	ld a, 15-PLAYER_Y
	ld [MAP_Y], a
	
	ld a, BANK_MAP1
	ld [$2000], a							;set the current bank to bank 1 so that we can load map1
	ld [CURR_MAP_BANK], a
	ld hl, Map1
	call MAP_INITIALISE						;load map 1
	
	pop af 
	ld [rLCDC], a							;turn the screen back on	
	
	ld b, LONG_PAUSE						;Wait 1 second
	call DELAY
	
	call SLOW_FADE_BACKGROUND_WHITE			;fade the background to white
	
	ld a, [rLCDC]
	push af									;push the current state of the screen to the stack
	xor a
	ld [rLCDC], a							;and turn the screen off
	
	ld a, %11100100							;load a normal pallette into a
	ld [rBGP], a
	
	ld a, 78								;set the map coords that we will see
	ld [MAP_X], a
	ld a, 3
	ld [MAP_Y], a
	
	ld a, BANK_MAP3					
	ld [$2000], a							;change bank and curr_map_bank as map 4 is in a different bank
	ld [CURR_MAP_BANK], a	
	ld hl, Map4
	call MAP_INITIALISE 					;load map 4
	
	pop af
	ld [rLCDC], a							;turn the screen back on
	
	ld b, LONG_PAUSE						;Wait 1 second
	call DELAY
	
	call SLOW_FADE_BACKGROUND_WHITE			;fade the background to white
	
	ld a, [rLCDC]
	push af									;push the current state of the screen to the stack
	xor a
	ld [rLCDC], a							;and turn the screen off
	
	ld a, %11100100							;load a normal pallette into a
	ld [rBGP], a
	
	ld a, $07								;set the map coords that we will see
	ld [MAP_X], a
	ld a, $0E
	ld [MAP_Y], a
	
	ld a, BANK_MAP2							;set the current bank to bank 2 so that we can get map6 data
	ld [$2000], a							
	
	ld hl, Map6
	call MAP_INITIALISE 					;load map6
	
	pop af
	ld [rLCDC], a							;turn the screen back on
	
	ld b, LONG_PAUSE						;Wait 1 second
	call DELAY
	
	call SLOW_FADE_BACKGROUND_WHITE			;fade the background to white
	
	ld b, LONG_PAUSE						;Wait 1 second
	call DELAY
	
	
	ld a, BANK_STRING						;Set the current bank to bank 5, so that we can get message data
	ld [$2000], a

	ld de, ThankYou
	ld c, 5*8								;Initial x position to output to
	ld hl, $FE00
.loop3:										;Slowly outputs "Thank you" using sprites instead of the background
	ld a, 16+8*8							
	ld [hl+], a								;sets the y coord for the current letter
	
	ld a, c
	add 8
	ld c, a									;c = c + 8
	ld [hl+], a								;sets the x coord for the current letter, each letter is 8 pixels apart
	
	ld a, [de]
	ld [hl+], a
	
	xor a
	ld [hl+], a								;xor a so that the byte containing palette no is cleared
	
	ld b, 20
	call DELAY
	
	inc de
	ld a, [de]
	cp $80									;if the next character to output is the null terminator
	jr nz, .loop3							;then jump to .loop3
	
	ld b, 240
	call DELAY								;wait 4 seconds
	
	call FADE_SPRITES_WHITE					;fade the message to white
	ld b, 240
	call DELAY								;wait 4 seconds again
	jp Start								;jump to Start to reset the program
	
;****************************************************************************************************************************************************
;*	RAM Variables
;****************************************************************************************************************************************************
	
SECTION "RAM Vars",WRAM0[$C000]
EVENT_PERMANENCE:
DS 32
NEW_TILES:
DS 20
CURR_MAP_ADR:
DS 2
CURR_MAP_HEIGHT:
DB
CURR_MAP_WIDTH:
DB
CURR_MAP_EVENTMP_ADR:
DS 2
CURR_MAP_EVENTS_ADR:
DS 2
MAP_X:
DB
MAP_Y:
DB
CURR_MAP_BANK:
DB
PLAYER_DIR:
DB
joypad_down:
db                   ;dow/up/lef/rig/sta/sel/b/a
joypad_pressed:
db
COUNTER:
db
RANDOM_NO:
DB
RANDOM_NO_SEED:
DB	
MESSAGE_END_D:
DB
MESSAGE_END_E:
DB
input:
DB
upper_result:
DB
lower_result:
DB
RAM_MESSAGE:
DS 54
GAMESTATE:
DB
CURSOR_STATE:
DB
INVENTORY:
DS 510
ITEMCODE_DISP:
DS 16*2
CUR_ITEM_NAME:
DS 10
TOP_ITEMCODE:
DS 2
HEALTH:
DB
LEVEL:
DB
EXP:
DB
CALC_MAXHEALTH:
DB
CALC_ATTACK:
DB
CALC_DEFENCE:
DB
CALC_MAGIC_ATTACK:
DB
CALC_MAGIC_DEFENCE:
DB
CALC_SPEED:
DB
ATTACK_ITEM:
DB
DEFENCE_ITEM:
DB
GENERAL_ITEM:
DB
COMBAT_INIT_BYTE:
DB
ENEMY_NO:
DB
ENEMY_LEVEL:
DB
ENEMY_HEALTH:
DB
ENEMY_ATTACK:
DB
ENEMY_DEFENCE:
DB
ENEMY_MAGIC_ATTACK:
DB
ENEMY_MAGIC_DEFENCE:
DB
ENEMY_SPEED:
DB
ENEMY_MAXHEALTH:
DB
GOLD:
DB
MOVES_LIST_PTR:
DS 2
COMBAT_MOVES_LIST:
DS 255
;*** End Of File ***